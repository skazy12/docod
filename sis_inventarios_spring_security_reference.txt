Estructura: .
Archivo: .gitignore
--------------------------------------------------
[Archivo no incluido en la documentación detallada: .gitignore]


Estructura: .
Archivo: HELP.md
--------------------------------------------------
[Archivo no incluido en la documentación detallada: HELP.md]


Estructura: .
Archivo: mvnw
--------------------------------------------------
[Archivo no incluido en la documentación detallada: mvnw]


Estructura: .
Archivo: mvnw.cmd
--------------------------------------------------
[Archivo no incluido en la documentación detallada: mvnw.cmd]


Estructura: .
Archivo: pom.xml
--------------------------------------------------
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
	<modelVersion>4.0.0</modelVersion>
	<parent>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-parent</artifactId>
		<version>3.2.6</version>
		<relativePath/> <!-- lookup parent from repository -->
	</parent>
	<groupId>com.invcontrol</groupId>
	<artifactId>inventarios</artifactId>
	<version>0.0.1-SNAPSHOT</version>
	<name>inventarios</name>
	<description>control de inventarios</description>
	<url/>
	<licenses>
		<license/>
	</licenses>
	<developers>
		<developer/>
	</developers>
	<scm>
		<connection/>
		<developerConnection/>
		<tag/>
		<url/>
	</scm>
	<properties>
		<java.version>17</java.version>
	</properties>
	<dependencies>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-data-jpa</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-security</artifactId>
		</dependency>
		<dependency>
			<groupId>com.auth0</groupId>
			<artifactId>java-jwt</artifactId>
			<version>4.2.1</version>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-validation</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-web</artifactId>
		</dependency>

		<dependency>
			<groupId>org.postgresql</groupId>
			<artifactId>postgresql</artifactId>
			<scope>runtime</scope>
		</dependency>
		<dependency>
			<groupId>org.projectlombok</groupId>
			<artifactId>lombok</artifactId>
			<optional>true</optional>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-test</artifactId>
			<scope>test</scope>
		</dependency>
		<dependency>
			<groupId>org.springframework.security</groupId>
			<artifactId>spring-security-test</artifactId>
			<scope>test</scope>
		</dependency>
	</dependencies>

	<build>
		<plugins>
			<plugin>
				<groupId>org.springframework.boot</groupId>
				<artifactId>spring-boot-maven-plugin</artifactId>
			</plugin>
		</plugins>
	</build>

</project>


Estructura: .idea
Archivo: .gitignore
--------------------------------------------------
[Archivo no incluido en la documentación detallada: .gitignore]


Estructura: .idea
Archivo: compiler.xml
--------------------------------------------------
<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CompilerConfiguration">
    <annotationProcessing>
      <profile default="true" name="Default" enabled="true" />
      <profile name="Maven default annotation processors profile" enabled="true">
        <sourceOutputDir name="target/generated-sources/annotations" />
        <sourceTestOutputDir name="target/generated-test-sources/test-annotations" />
        <outputRelativeToContentRoot value="true" />
        <module name="inventarios" />
      </profile>
    </annotationProcessing>
  </component>
  <component name="JavacSettings">
    <option name="ADDITIONAL_OPTIONS_OVERRIDE">
      <module name="inventarios" options="-parameters" />
    </option>
  </component>
</project>

Estructura: .idea
Archivo: encodings.xml
--------------------------------------------------
<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="Encoding">
    <file url="file://$PROJECT_DIR$/src/main/java" charset="UTF-8" />
  </component>
</project>

Estructura: .idea
Archivo: jarRepositories.xml
--------------------------------------------------
<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="RemoteRepositoriesConfiguration">
    <remote-repository>
      <option name="id" value="central" />
      <option name="name" value="Central Repository" />
      <option name="url" value="https://repo.maven.apache.org/maven2" />
    </remote-repository>
    <remote-repository>
      <option name="id" value="central" />
      <option name="name" value="Maven Central repository" />
      <option name="url" value="https://repo1.maven.org/maven2" />
    </remote-repository>
    <remote-repository>
      <option name="id" value="jboss.community" />
      <option name="name" value="JBoss Community repository" />
      <option name="url" value="https://repository.jboss.org/nexus/content/repositories/public/" />
    </remote-repository>
  </component>
</project>

Estructura: .idea
Archivo: misc.xml
--------------------------------------------------
<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ExternalStorageConfigurationManager" enabled="true" />
  <component name="MavenProjectsManager">
    <option name="originalFiles">
      <list>
        <option value="$PROJECT_DIR$/pom.xml" />
      </list>
    </option>
  </component>
  <component name="ProjectRootManager" version="2" languageLevel="JDK_17" default="true" project-jdk-name="17" project-jdk-type="JavaSDK" />
</project>

Estructura: .idea
Archivo: workspace.xml
--------------------------------------------------
<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="AutoImportSettings">
    <option name="autoReloadType" value="SELECTIVE" />
  </component>
  <component name="ChangeListManager">
    <list default="true" id="38f8e107-c32c-4bcd-b9ed-208e09030328" name="Changes" comment="" />
    <option name="SHOW_DIALOG" value="false" />
    <option name="HIGHLIGHT_CONFLICTS" value="true" />
    <option name="HIGHLIGHT_NON_ACTIVE_CHANGELIST" value="false" />
    <option name="LAST_RESOLUTION" value="IGNORE" />
  </component>
  <component name="FileTemplateManagerImpl">
    <option name="RECENT_TEMPLATES">
      <list>
        <option value="Interface" />
        <option value="Class" />
      </list>
    </option>
  </component>
  <component name="MavenImportPreferences">
    <option name="generalSettings">
      <MavenGeneralSettings>
        <option name="mavenHomeTypeForPersistence" value="WRAPPER" />
      </MavenGeneralSettings>
    </option>
  </component>
  <component name="ProjectColorInfo">{
  &quot;associatedIndex&quot;: 8
}</component>
  <component name="ProjectId" id="2in85gvVsBTkLqEZ50dBue6J63O" />
  <component name="ProjectViewState">
    <option name="hideEmptyMiddlePackages" value="true" />
    <option name="showLibraryContents" value="true" />
  </component>
  <component name="PropertiesComponent"><![CDATA[{
  "keyToString": {
    "Application.InventariosApplication.executor": "Run",
    "RunOnceActivity.ShowReadmeOnStart": "true",
    "kotlin-language-version-configured": "true",
    "last_opened_file_path": "F:/CLASES/SEMESTRE_2_2024/TALLER_SOFTWARE/DEMOS/email"
  }
}]]></component>
  <component name="SpellCheckerSettings" RuntimeDictionaries="0" Folders="0" CustomDictionaries="0" DefaultDictionary="application-level" UseSingleDictionary="true" transferred="true" />
  <component name="TaskManager">
    <task active="true" id="Default" summary="Default task">
      <changelist id="38f8e107-c32c-4bcd-b9ed-208e09030328" name="Changes" comment="" />
      <created>1720114799812</created>
      <option name="number" value="Default" />
      <option name="presentableId" value="Default" />
      <updated>1720114799812</updated>
    </task>
    <servers />
  </component>
</project>

Estructura: .mvn > wrapper
Archivo: maven-wrapper.properties
--------------------------------------------------
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
wrapperVersion=3.3.2
distributionType=only-script
distributionUrl=https://repo.maven.apache.org/maven2/org/apache/maven/apache-maven/3.9.7/apache-maven-3.9.7-bin.zip


Estructura: src > main > java > com > invcontrol
Archivo: InventariosApplication.java
--------------------------------------------------
package com.invcontrol;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class InventariosApplication {

	public static void main(String[] args) {
		SpringApplication.run(InventariosApplication.class, args);
	}

}


Estructura: src > main > java > com > invcontrol > config
Archivo: SecurityConfig.java
--------------------------------------------------
package com.invcontrol.config;

import com.invcontrol.config.filter.JwTokenValidator;
import com.invcontrol.service.UserDetailServiceImpl;
import com.invcontrol.util.JwtUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import org.springframework.http.HttpMethod;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.AuthenticationProvider;
import org.springframework.security.authentication.dao.DaoAuthenticationProvider;
import org.springframework.security.config.Customizer;
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.www.BasicAuthenticationFilter;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.CorsConfigurationSource;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;
import org.springframework.web.servlet.config.annotation.CorsRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

import java.util.Arrays;


@Configuration
@EnableWebSecurity
public class SecurityConfig {
    @Autowired
    private JwtUtils jwtUtils;
    @Bean
    public CorsConfigurationSource corsConfiguration() {
        CorsConfiguration corsConfiguration = new CorsConfiguration();
        corsConfiguration.setAllowCredentials(true);
        corsConfiguration.setAllowedOrigins(Arrays.asList("http://localhost:4200"));
        corsConfiguration.setAllowedMethods(Arrays.asList("GET", "POST", "PUT", "DELETE"));
        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/**", corsConfiguration);

        return source;
    }
    @Bean
    WebMvcConfigurer corsConfigurer() {
        return new WebMvcConfigurer() {
            @Override
            public void addCorsMappings(CorsRegistry registry) {
                registry.addMapping("/**").allowedOrigins("http://localhost:4200");
            }
        };
    }

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        return http
                .csrf(csrf -> csrf.disable())
                .cors(Customizer.withDefaults())
                .httpBasic(Customizer.withDefaults())
                .sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
                .authorizeHttpRequests(authorize -> {
                    //endpoints publicos
                    authorize.requestMatchers(HttpMethod.POST, "/auth/**").permitAll();
                    //endpoints privados
                    authorize.requestMatchers(HttpMethod.GET, "/inventory").hasAnyRole("ADMIN", "USER");
                    authorize.requestMatchers(HttpMethod.POST, "/inventory/**").hasRole("ADMIN");
                    authorize.requestMatchers(HttpMethod.PUT, "/inventory/**").hasRole("ADMIN");
                    authorize.requestMatchers(HttpMethod.DELETE, "inventory/**").hasRole("ADMIN");
                    authorize.requestMatchers("/users/**").hasRole("ADMIN");

                    //cualquier otro endpoint
                    authorize.anyRequest().denyAll();

                })
                .addFilterBefore(new JwTokenValidator(jwtUtils), BasicAuthenticationFilter.class)
                .build();
    }
    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration authenticationConfiguration) throws Exception {
        return authenticationConfiguration.getAuthenticationManager();
    }
    @Bean
    public AuthenticationProvider authenticationProvider(UserDetailServiceImpl userDetailService) {
        DaoAuthenticationProvider provider = new DaoAuthenticationProvider();
        provider.setPasswordEncoder(passwordEncoder());
        provider.setUserDetailsService(userDetailService);
        return provider;
    }
    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }



}


Estructura: src > main > java > com > invcontrol > config > filter
Archivo: JwTokenValidator.java
--------------------------------------------------
package com.invcontrol.config.filter;

import com.auth0.jwt.exceptions.JWTVerificationException;
import com.auth0.jwt.interfaces.DecodedJWT;
import com.invcontrol.util.JwtUtils;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import jakarta.validation.constraints.NotNull;
import org.springframework.http.HttpHeaders;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.AuthorityUtils;
import org.springframework.security.core.context.SecurityContext;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.web.filter.OncePerRequestFilter;


import java.io.IOException;
import java.util.Collection;

public class JwTokenValidator extends OncePerRequestFilter{

    private JwtUtils jwtUtils;

    public JwTokenValidator(JwtUtils jwtUtils) {
        this.jwtUtils = jwtUtils;
    }

    @Override
    protected void doFilterInternal(@NotNull HttpServletRequest request, @NotNull HttpServletResponse response, @NotNull FilterChain filterChain) throws ServletException, IOException {
        String token = request.getHeader(HttpHeaders.AUTHORIZATION);
        if (token != null && token.startsWith("Bearer ")) {
            token = token.substring(7);
            try {
                DecodedJWT decoded = jwtUtils.validateToken(token);
                String username = jwtUtils.getUsernameFromToken(decoded);
                String stringAuthorities = jwtUtils.getClaimFromToken(decoded, "authorities").asString();
                Collection<GrantedAuthority> authorities = AuthorityUtils.commaSeparatedStringToAuthorityList(stringAuthorities);

                SecurityContext context = SecurityContextHolder.createEmptyContext();
                Authentication authenticationToken = new UsernamePasswordAuthenticationToken(username, null, authorities);
                context.setAuthentication(authenticationToken);
                SecurityContextHolder.setContext(context);
            } catch (JWTVerificationException e) {
                response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
                response.getWriter().write("Invalid or expired token");
                System.out.println("Invalid or expired token");
                return;
            }
        }
        filterChain.doFilter(request, response);
    }

}


Estructura: src > main > java > com > invcontrol > controller
Archivo: AuthenticationController.java
--------------------------------------------------
package com.invcontrol.controller;

import com.invcontrol.dto.AuthCreateUserRequest;
import com.invcontrol.dto.AuthLoginRequest;
import com.invcontrol.dto.AuthResponse;
import com.invcontrol.service.UserDetailServiceImpl;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.validation.Valid;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.web.bind.annotation.*;
import com.invcontrol.util.JwtUtils;

@RestController
@RequestMapping("/auth")
@CrossOrigin
public class AuthenticationController {
    @Autowired
    private UserDetailServiceImpl userDetailService;
    @Autowired
    private JwtUtils jwtUtils;
    @PostMapping("/login")
    public ResponseEntity<AuthResponse> login(@RequestBody @Valid AuthLoginRequest userRequest) {
        return new ResponseEntity<>(this.userDetailService.loginUser(userRequest), HttpStatus.OK);
    }
    @PostMapping("/register")
    public ResponseEntity<AuthResponse> register(@RequestBody @Valid AuthCreateUserRequest authCreateUser) {
        return new ResponseEntity<>(this.userDetailService.createUser(authCreateUser), HttpStatus.CREATED);
    }
    @PostMapping("/renew-token")
    public ResponseEntity<AuthResponse> renewToken(HttpServletRequest request) {
        String token = request.getHeader(HttpHeaders.AUTHORIZATION).substring(7);
        String username = jwtUtils.getUsernameFromToken(jwtUtils.validateToken(token));

        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        String newToken = jwtUtils.createToken(authentication);

        AuthResponse authResponse = new AuthResponse(username, "Token renewed successfully", newToken, true);
        return new ResponseEntity<>(authResponse, HttpStatus.OK);
    }

}


Estructura: src > main > java > com > invcontrol > controller
Archivo: HomeController.java
--------------------------------------------------
package com.invcontrol.controller;

import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/method")
@CrossOrigin
public class HomeController {
    @GetMapping("/home")
    public String home() {
        return "Welcome to the home page!";
    }
    @GetMapping("/admin")
    public String adminHome() {
        return "Welcome to the admin home page!";
    }
    @GetMapping("/user")
    public String userHome() {
        return "Welcome to the user home page!";
    }
    @PostMapping("/admin")
    public String admin() {
        return "Welcome Admin!";
    }
    @PostMapping("/moderator")
    public String moderator() {
        return "Welcome Moderator!";
    }
}


Estructura: src > main > java > com > invcontrol > controller
Archivo: InventoryController.java
--------------------------------------------------
package com.invcontrol.controller;
import com.invcontrol.dto.InventoryItemDTO;
import com.invcontrol.service.InventoryService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/inventory")
@CrossOrigin
public class InventoryController {
    @Autowired
    private InventoryService inventoryService;

    @GetMapping
    public ResponseEntity<List<InventoryItemDTO>> getAllItems() {
        return new ResponseEntity<>(inventoryService.getAllItems(), HttpStatus.OK);
    }

    @PostMapping
    public ResponseEntity<InventoryItemDTO> createItem(@RequestBody InventoryItemDTO itemDTO) {
        return new ResponseEntity<>(inventoryService.createItem(itemDTO), HttpStatus.CREATED);
    }

    @PutMapping("/{id}")
    public ResponseEntity<InventoryItemDTO> updateItem(@PathVariable Long id, @RequestBody InventoryItemDTO itemDTO) {
        return new ResponseEntity<>(inventoryService.updateItem(id, itemDTO), HttpStatus.OK);
    }

    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deleteItem(@PathVariable Long id) {
        inventoryService.deleteItem(id);
        return new ResponseEntity<>(HttpStatus.NO_CONTENT);
    }
}


Estructura: src > main > java > com > invcontrol > controller
Archivo: UserController.java
--------------------------------------------------
package com.invcontrol.controller;

import com.invcontrol.dto.AuthCreateUserRequest;
import com.invcontrol.dto.AuthResponse;
import com.invcontrol.model.UserEntity;
import com.invcontrol.service.UserDetailServiceImpl;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/users")
@CrossOrigin
public class UserController {
    @Autowired
    private UserDetailServiceImpl userDetailService;

    @GetMapping
    public ResponseEntity<List<UserEntity>> getAllUsers() {
        return new ResponseEntity<>(userDetailService.getAllUsers(), HttpStatus.OK);
    }

    @PostMapping
    public ResponseEntity<AuthResponse> createUser(@RequestBody AuthCreateUserRequest authCreateUserRequest) {
        return new ResponseEntity<>(userDetailService.createUser(authCreateUserRequest), HttpStatus.CREATED);
    }

    @PutMapping("/{id}")
    public ResponseEntity<UserEntity> updateUser(@PathVariable Long id, @RequestBody AuthCreateUserRequest authCreateUserRequest) {
        return new ResponseEntity<>(userDetailService.updateUser(id, authCreateUserRequest), HttpStatus.OK);
    }

    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deleteUser(@PathVariable Long id) {
        userDetailService.deleteUser(id);
        return new ResponseEntity<>(HttpStatus.NO_CONTENT);
    }
}


Estructura: src > main > java > com > invcontrol > dto
Archivo: AuthCreateRoleRequest.java
--------------------------------------------------
package com.invcontrol.dto;

import jakarta.validation.constraints.Size;
import org.springframework.validation.annotation.Validated;

import java.util.List;

@Validated
public record AuthCreateRoleRequest(@Size(max = 3, message = "user cannot have more than 3 roles") List<String> rolesListName) {
}


Estructura: src > main > java > com > invcontrol > dto
Archivo: AuthCreateUserRequest.java
--------------------------------------------------
package com.invcontrol.dto;

import jakarta.validation.Valid;
import jakarta.validation.constraints.NotBlank;


public record AuthCreateUserRequest(@NotBlank String username, @NotBlank String password, @Valid AuthCreateRoleRequest roles){
}


Estructura: src > main > java > com > invcontrol > dto
Archivo: AuthLoginRequest.java
--------------------------------------------------
package com.invcontrol.dto;


import jakarta.validation.constraints.NotBlank;

public record AuthLoginRequest (@NotBlank String username, @NotBlank String password){


}


Estructura: src > main > java > com > invcontrol > dto
Archivo: AuthResponse.java
--------------------------------------------------
package com.invcontrol.dto;

import com.fasterxml.jackson.annotation.JsonPropertyOrder;

@JsonPropertyOrder({"username", "message", "jwt", "status"})
public record AuthResponse (String username, String message, String jwt, boolean status){


}


Estructura: src > main > java > com > invcontrol > dto
Archivo: InventoryItemDTO.java
--------------------------------------------------
package com.invcontrol.dto;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import lombok.*;

@Builder
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
public class InventoryItemDTO {
    private long id;
    @NotBlank(message = "Name is mandatory")
    private String name;
    @NotNull(message = "Quantity is mandatory")
    private int quantity;
    @NotNull(message = "Price is mandatory")
    private double price;

}


Estructura: src > main > java > com > invcontrol > model
Archivo: InventoryItem.java
--------------------------------------------------
package com.invcontrol.model;

import jakarta.persistence.Entity;
import jakarta.persistence.*;
import lombok.*;

@Entity
@Getter
@Setter
@Builder
@NoArgsConstructor
@AllArgsConstructor
@Table(name = "inventory_items")
public class InventoryItem {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false)
    private String name;

    @Column(nullable = false)
    private int quantity;

    @Column(nullable = false)
    private double price;
}


Estructura: src > main > java > com > invcontrol > model
Archivo: PermissionEntity.java
--------------------------------------------------
package com.invcontrol.model;

import jakarta.persistence.Entity;
import jakarta.persistence.*;
import jakarta.persistence.Table;
import lombok.*;

@Entity
@Getter
@Setter
@Builder
@NoArgsConstructor
@AllArgsConstructor
@Table(name = "permissions")
public class PermissionEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    @Column(name = "permission_name", unique = true, nullable = false, updatable = false)
    private String permissionName;

}


Estructura: src > main > java > com > invcontrol > model
Archivo: RoleEntity.java
--------------------------------------------------
package com.invcontrol.model;

import jakarta.persistence.*;
import lombok.*;

import java.util.HashSet;
import java.util.Set;

@Entity
@Getter
@Setter
@Builder
@NoArgsConstructor
@AllArgsConstructor
@Table(name = "roles")
public class RoleEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    @Column(name = "role_name")
    @Enumerated(EnumType.STRING)
    private RoleEnum roleEnum;
    @ManyToMany(fetch = FetchType.EAGER, cascade = CascadeType.ALL)
    @JoinTable(
            name = "role_permissions",
            joinColumns = @JoinColumn(name = "role_id"),
            inverseJoinColumns = @JoinColumn(name = "permission_id")
    )
    private Set<PermissionEntity> permissionList = new HashSet<>();

}


Estructura: src > main > java > com > invcontrol > model
Archivo: RoleEnum.java
--------------------------------------------------
package com.invcontrol.model;

public enum RoleEnum {
    ADMIN,
    USER,
    MODERATOR
}


Estructura: src > main > java > com > invcontrol > model
Archivo: UserEntity.java
--------------------------------------------------
package com.invcontrol.model;

import jakarta.persistence.*;
import lombok.*;

import java.util.HashSet;
import java.util.Set;
import java.util.stream.Collectors;


@Entity
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
@Table(name = "users")
public class UserEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    @Column(unique = true)
    private String username;

    private String password;
    @Column(name = "is_enabled")
    private Boolean isEnabled;
    @Column(name = "account_non_expired")
    private Boolean accountNonExpired;
    @Column(name = "account_non_locked")
    private Boolean accountNonLocked;
    @Column(name = "credentials_non_expired")
    private Boolean credentialsNonExpired;

    @ManyToMany(fetch = FetchType.EAGER, cascade = CascadeType.ALL)
    @JoinTable(
            name = "user_roles",
            joinColumns = @JoinColumn(name = "user_id"),
            inverseJoinColumns = @JoinColumn(name = "role_id")
    )
    private Set<RoleEntity> roles = new HashSet<>();
    @Transient
    private Set<String> roleNames;

    public Set<String> getRoleNames() {
        if (this.roleNames == null) {
            this.roleNames = this.roles.stream()
                    .map(role -> role.getRoleEnum().name())
                    .collect(Collectors.toSet());
        }
        return this.roleNames;
    }

    public void setRoleNames(Set<String> roleNames) {
        this.roleNames = roleNames;
    }
}


Estructura: src > main > java > com > invcontrol > repository
Archivo: InventoryRepository.java
--------------------------------------------------
package com.invcontrol.repository;

import com.invcontrol.model.InventoryItem;
import org.springframework.data.repository.CrudRepository;
import org.springframework.stereotype.Repository;

@Repository
public interface InventoryRepository extends CrudRepository<InventoryItem, Long> {
}


Estructura: src > main > java > com > invcontrol > repository
Archivo: RoleRepository.java
--------------------------------------------------
package com.invcontrol.repository;

import com.invcontrol.model.RoleEntity;
import org.springframework.data.repository.CrudRepository;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface RoleRepository extends CrudRepository<RoleEntity, Long> {


    List<RoleEntity> findRoleEntitiesByRoleEnumIn(List<String> roleNames);
}


Estructura: src > main > java > com > invcontrol > repository
Archivo: UserRepository.java
--------------------------------------------------
package com.invcontrol.repository;

import com.invcontrol.model.UserEntity;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.CrudRepository;

import java.util.Optional;

public interface UserRepository extends CrudRepository<UserEntity, Long> {
    Optional<UserEntity> findUserEntityByUsername (String username);
    //este metodo es para buscar un usuario por su nombre de usuario con un query
    @Query("SELECT u FROM UserEntity u WHERE u.username = ?1")
    Optional<UserEntity> findUser(String username);
}


Estructura: src > main > java > com > invcontrol > service
Archivo: InventoryService.java
--------------------------------------------------
package com.invcontrol.service;
import com.invcontrol.dto.InventoryItemDTO;
import com.invcontrol.model.InventoryItem;
import com.invcontrol.repository.InventoryRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.stream.Collectors;

@Service
public class InventoryService {
    @Autowired
    private InventoryRepository inventoryRepository;

    public List<InventoryItemDTO> getAllItems() {
        return ((List<InventoryItem>) inventoryRepository.findAll()).stream()
                .map(this::convertToDTO)
                .collect(Collectors.toList());
    }

    public InventoryItemDTO createItem(InventoryItemDTO itemDTO) {
        InventoryItem item = convertToEntity(itemDTO);
        InventoryItem savedItem = inventoryRepository.save(item);
        return convertToDTO(savedItem);
    }

    public InventoryItemDTO updateItem(Long id, InventoryItemDTO itemDTO) {
        if (!inventoryRepository.existsById(id)) {
            throw new IllegalArgumentException("Item not found");
        }
        InventoryItem item = convertToEntity(itemDTO);
        item.setId(id);
        InventoryItem updatedItem = inventoryRepository.save(item);
        return convertToDTO(updatedItem);
    }

    public void deleteItem(Long id) {
        if (!inventoryRepository.existsById(id)) {
            throw new IllegalArgumentException("Item not found");
        }
        inventoryRepository.deleteById(id);
    }

    private InventoryItemDTO convertToDTO(InventoryItem item) {
        InventoryItemDTO itemDTO = new InventoryItemDTO();
        itemDTO.setId(item.getId());
        itemDTO.setName(item.getName());
        itemDTO.setQuantity(item.getQuantity());
        itemDTO.setPrice(item.getPrice());
        return itemDTO;
    }

    private InventoryItem convertToEntity(InventoryItemDTO itemDTO) {
        InventoryItem item = new InventoryItem();
        item.setName(itemDTO.getName());
        item.setQuantity(itemDTO.getQuantity());
        item.setPrice(itemDTO.getPrice());
        return item;
    }
}


Estructura: src > main > java > com > invcontrol > service
Archivo: UserDetailServiceImpl.java
--------------------------------------------------
package com.invcontrol.service;

import com.invcontrol.dto.AuthCreateUserRequest;
import com.invcontrol.dto.AuthLoginRequest;
import com.invcontrol.dto.AuthResponse;
import com.invcontrol.model.RoleEntity;
import com.invcontrol.model.UserEntity;
import com.invcontrol.repository.RoleRepository;
import com.invcontrol.repository.UserRepository;
import com.invcontrol.util.JwtUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.authentication.BadCredentialsException;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;


import java.util.ArrayList;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

@Service
public class UserDetailServiceImpl implements UserDetailsService {
    @Autowired
    private PasswordEncoder passwordEncoder;
    @Autowired
    private JwtUtils jwtUtils;
    @Autowired
    private UserRepository userRepository;
    @Autowired
    private RoleRepository roleRepository;
    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        UserEntity userEntity = userRepository.findUserEntityByUsername(username)
                .orElseThrow(() -> new UsernameNotFoundException("User "+username+" not found"));
        List<SimpleGrantedAuthority> authorities = new ArrayList<>();
        userEntity.getRoles().forEach(role -> {
            authorities.add(new SimpleGrantedAuthority("ROLE_".concat(
                    role.getRoleEnum().name().toUpperCase()
            )));
        });
        userEntity.getRoles().stream().flatMap(role -> role.getPermissionList().stream())
                .forEach(permission -> {
                    authorities.add(new SimpleGrantedAuthority(permission.getPermissionName()));
                });

        return new User(userEntity.getUsername(), userEntity.getPassword(), userEntity.getIsEnabled(),
                userEntity.getAccountNonExpired(), userEntity.getCredentialsNonExpired(),
                userEntity.getAccountNonLocked(), authorities);
    }
    public AuthResponse loginUser(AuthLoginRequest authLoginRequest) {
        String username = authLoginRequest.username();
        String password = authLoginRequest.password();

        Authentication authentication = this.authenticate(username, password);
        SecurityContextHolder.getContext().setAuthentication(authentication);
        String accessToken = jwtUtils.createToken(authentication);

        AuthResponse authResponse  = new AuthResponse(username, "Login Successful", accessToken, true);
        return authResponse;
    }
    private Authentication authenticate(String username, String password) {
        UserDetails userDetails = this.loadUserByUsername(username);
        if(userDetails == null){
            throw new BadCredentialsException("Invalid username or password");
        }
        if(!passwordEncoder.matches(password, userDetails.getPassword())){
            throw new BadCredentialsException("Invalid username or password");
        }
        return new UsernamePasswordAuthenticationToken(username, userDetails.getPassword(), userDetails.getAuthorities());
    }

    public AuthResponse createUser(AuthCreateUserRequest authCreateUser) {
        String username = authCreateUser.username();
        String password = authCreateUser.password();
        List<String> roleRequest = authCreateUser.roles().rolesListName();
        Set<RoleEntity> roleEntitySet = roleRepository.findRoleEntitiesByRoleEnumIn(roleRequest).stream().collect(Collectors.toSet());

        if (roleEntitySet.isEmpty()) {
            throw new IllegalArgumentException("Roles does not exist");
        }
        UserEntity userEntity = UserEntity.builder()
                .username(username)
                .password(passwordEncoder.encode(password))
                .isEnabled(true)
                .accountNonExpired(true)
                .accountNonLocked(true)
                .credentialsNonExpired(true)
                .roles(roleEntitySet)
                .build();

        UserEntity userCreated= userRepository.save(userEntity);
        ArrayList<SimpleGrantedAuthority> authorityList = new ArrayList<>();
        userCreated.getRoles().forEach(role -> {
            authorityList.add(new SimpleGrantedAuthority("ROLE_".concat(role.getRoleEnum().name().toUpperCase())));
        });
        userCreated.getRoles().stream().flatMap(role -> role.getPermissionList().stream())
                .forEach(permission -> {
                    authorityList.add(new SimpleGrantedAuthority(permission.getPermissionName()));
                });
        Authentication authentication = new UsernamePasswordAuthenticationToken(userCreated.getUsername(), userCreated.getPassword(), authorityList);
        String accessToken = jwtUtils.createToken(authentication);
        AuthResponse authResponse = new AuthResponse(userCreated.getUsername(), "User created successfully", accessToken, true);

        return authResponse;
    }
    public List<UserEntity> getAllUsers() {
        List<UserEntity> users = (List<UserEntity>) userRepository.findAll();
        users.forEach(user -> {
            Set<String> roleNames = user.getRoles().stream()
                    .map(role -> role.getRoleEnum().name())
                    .collect(Collectors.toSet());
            user.setRoleNames(roleNames);
        });
        return users;
    }
    public UserEntity updateUser(Long id, AuthCreateUserRequest authCreateUserRequest) {
        UserEntity userEntity = userRepository.findById(id).orElseThrow(() -> new IllegalArgumentException("User not found"));
        String username = authCreateUserRequest.username();
        String password = authCreateUserRequest.password();
        List<String> roleRequest = authCreateUserRequest.roles().rolesListName();
        Set<RoleEntity> roleEntitySet = roleRepository.findRoleEntitiesByRoleEnumIn(roleRequest).stream().collect(Collectors.toSet());

        if (roleEntitySet.isEmpty()) {
            throw new IllegalArgumentException("Roles does not exist");
        }
        userEntity.setUsername(username);
        userEntity.setPassword(passwordEncoder.encode(password));
        userEntity.setRoles(roleEntitySet);
        return userRepository.save(userEntity);
    }
    public void deleteUser(Long id) {
        if (!userRepository.existsById(id)) {
            throw new IllegalArgumentException("User not found");
        }
        userRepository.deleteById(id);
    }


}


Estructura: src > main > java > com > invcontrol > util
Archivo: JwtUtils.java
--------------------------------------------------
package com.invcontrol.util;

import com.auth0.jwt.JWT;
import com.auth0.jwt.JWTVerifier;
import com.auth0.jwt.algorithms.Algorithm;
import com.auth0.jwt.exceptions.JWTVerificationException;
import com.auth0.jwt.interfaces.Claim;
import com.auth0.jwt.interfaces.DecodedJWT;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.stereotype.Component;

import java.util.Date;
import java.util.Map;
import java.util.UUID;
import java.util.stream.Collectors;

@Component
public class JwtUtils {
    @Value("${security.jwt.secret}")
    private String secret;

    @Value("${security.jwt.user.generetor}")
    private String userGeneretor;

    public String createToken(Authentication authentication) {
        Algorithm  algorithm = Algorithm.HMAC256(secret);
        String Username = authentication.getPrincipal().toString();
        String authorities = authentication.getAuthorities().stream().map(GrantedAuthority::getAuthority).collect(Collectors.joining(","));

        String jwtToken = JWT.create()
                .withIssuer(this.userGeneretor)
                .withSubject(Username)
                .withClaim("authorities", authorities)
                .withIssuedAt(new Date())
                .withExpiresAt(new Date(System.currentTimeMillis() + 86400000))
                .withJWTId(UUID.randomUUID().toString())
                .withNotBefore(new Date(System.currentTimeMillis()))
                .sign(algorithm);



        return jwtToken;
    }
    public DecodedJWT validateToken(String token) {
        try {
            Algorithm algorithm = Algorithm.HMAC256(secret);
            JWTVerifier verifier = JWT.require(algorithm)
                    .withIssuer(this.userGeneretor)
                    .build();
            DecodedJWT decoded = verifier.verify(token);
            return decoded;

        }catch (JWTVerificationException e) {
            throw new JWTVerificationException("invalid token" +
                    "error: " + e.getMessage());
        }
    }
    public String getUsernameFromToken(DecodedJWT decoded) {
        return decoded.getSubject().toString();

    }
    public Claim getClaimFromToken(DecodedJWT decoded, String claimName) {
        return decoded.getClaim(claimName);
    }
    public Map<String, Claim> getAllClaimsFromToken(DecodedJWT decoded) {
        return decoded.getClaims();
    }



}


Estructura: src > main > resources
Archivo: application.properties
--------------------------------------------------
spring.application.name=inventarios
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.PostgreSQLDialect

spring.datasource.url=jdbc:postgresql://localhost:5432/inventariosdb
spring.datasource.username=postgres
spring.datasource.password=7530
spring.jpa.hibernate.ddl-auto=create-drop

spring.jpa.show-sql=true
spring.jpa.properties.hibernate.jdbc.lob.non_contextual_creation=true
spring.datasource.initialization-mode=always


security.jwt.secret=2F123232CDDB287F610CBEA09A4DD67F302ECEDF8F433C1C2CDCB90631928DBB
security.jwt.user.generetor=AUTH-BACKEND

Estructura: src > main > resources
Archivo: import.sql
--------------------------------------------------
[Archivo no incluido en la documentación detallada: import.sql]


Estructura: src > test > java > com > invcontrol
Archivo: InventariosApplicationTests.java
--------------------------------------------------
package com.invcontrol;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class InventariosApplicationTests {

	@Test
	void contextLoads() {
	}

}


Estructura: target > classes
Archivo: application.properties
--------------------------------------------------
spring.application.name=inventarios
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.PostgreSQLDialect

spring.datasource.url=jdbc:postgresql://localhost:5432/inventariosdb
spring.datasource.username=postgres
spring.datasource.password=7530
spring.jpa.hibernate.ddl-auto=create-drop

spring.jpa.show-sql=true
spring.jpa.properties.hibernate.jdbc.lob.non_contextual_creation=true
spring.datasource.initialization-mode=always


security.jwt.secret=2F123232CDDB287F610CBEA09A4DD67F302ECEDF8F433C1C2CDCB90631928DBB
security.jwt.user.generetor=AUTH-BACKEND

Estructura: target > classes
Archivo: import.sql
--------------------------------------------------
[Archivo no incluido en la documentación detallada: import.sql]


Estructura: target > classes > com > invcontrol
Archivo: InventariosApplication.class
--------------------------------------------------
[Archivo no incluido en la documentación detallada: InventariosApplication.class]


Estructura: target > classes > com > invcontrol > config
Archivo: SecurityConfig$1.class
--------------------------------------------------
[Archivo no incluido en la documentación detallada: SecurityConfig$1.class]


Estructura: target > classes > com > invcontrol > config
Archivo: SecurityConfig.class
--------------------------------------------------
[Archivo no incluido en la documentación detallada: SecurityConfig.class]


Estructura: target > classes > com > invcontrol > config > filter
Archivo: JwTokenValidator.class
--------------------------------------------------
[Archivo no incluido en la documentación detallada: JwTokenValidator.class]


Estructura: target > classes > com > invcontrol > controller
Archivo: AuthenticationController.class
--------------------------------------------------
[Archivo no incluido en la documentación detallada: AuthenticationController.class]


Estructura: target > classes > com > invcontrol > controller
Archivo: HomeController.class
--------------------------------------------------
[Archivo no incluido en la documentación detallada: HomeController.class]


Estructura: target > classes > com > invcontrol > controller
Archivo: InventoryController.class
--------------------------------------------------
[Archivo no incluido en la documentación detallada: InventoryController.class]


Estructura: target > classes > com > invcontrol > controller
Archivo: UserController.class
--------------------------------------------------
[Archivo no incluido en la documentación detallada: UserController.class]


Estructura: target > classes > com > invcontrol > dto
Archivo: AuthCreateRoleRequest.class
--------------------------------------------------
[Archivo no incluido en la documentación detallada: AuthCreateRoleRequest.class]


Estructura: target > classes > com > invcontrol > dto
Archivo: AuthCreateUserRequest.class
--------------------------------------------------
[Archivo no incluido en la documentación detallada: AuthCreateUserRequest.class]


Estructura: target > classes > com > invcontrol > dto
Archivo: AuthLoginRequest.class
--------------------------------------------------
[Archivo no incluido en la documentación detallada: AuthLoginRequest.class]


Estructura: target > classes > com > invcontrol > dto
Archivo: AuthResponse.class
--------------------------------------------------
[Archivo no incluido en la documentación detallada: AuthResponse.class]


Estructura: target > classes > com > invcontrol > dto
Archivo: InventoryItemDTO$InventoryItemDTOBuilder.class
--------------------------------------------------
[Archivo no incluido en la documentación detallada: InventoryItemDTO$InventoryItemDTOBuilder.class]


Estructura: target > classes > com > invcontrol > dto
Archivo: InventoryItemDTO.class
--------------------------------------------------
[Archivo no incluido en la documentación detallada: InventoryItemDTO.class]


Estructura: target > classes > com > invcontrol > model
Archivo: InventoryItem$InventoryItemBuilder.class
--------------------------------------------------
[Archivo no incluido en la documentación detallada: InventoryItem$InventoryItemBuilder.class]


Estructura: target > classes > com > invcontrol > model
Archivo: InventoryItem.class
--------------------------------------------------
[Archivo no incluido en la documentación detallada: InventoryItem.class]


Estructura: target > classes > com > invcontrol > model
Archivo: PermissionEntity$PermissionEntityBuilder.class
--------------------------------------------------
[Archivo no incluido en la documentación detallada: PermissionEntity$PermissionEntityBuilder.class]


Estructura: target > classes > com > invcontrol > model
Archivo: PermissionEntity.class
--------------------------------------------------
[Archivo no incluido en la documentación detallada: PermissionEntity.class]


Estructura: target > classes > com > invcontrol > model
Archivo: RoleEntity$RoleEntityBuilder.class
--------------------------------------------------
[Archivo no incluido en la documentación detallada: RoleEntity$RoleEntityBuilder.class]


Estructura: target > classes > com > invcontrol > model
Archivo: RoleEntity.class
--------------------------------------------------
[Archivo no incluido en la documentación detallada: RoleEntity.class]


Estructura: target > classes > com > invcontrol > model
Archivo: RoleEnum.class
--------------------------------------------------
[Archivo no incluido en la documentación detallada: RoleEnum.class]


Estructura: target > classes > com > invcontrol > model
Archivo: UserEntity$UserEntityBuilder.class
--------------------------------------------------
[Archivo no incluido en la documentación detallada: UserEntity$UserEntityBuilder.class]


Estructura: target > classes > com > invcontrol > model
Archivo: UserEntity.class
--------------------------------------------------
[Archivo no incluido en la documentación detallada: UserEntity.class]


Estructura: target > classes > com > invcontrol > repository
Archivo: InventoryRepository.class
--------------------------------------------------
[Archivo no incluido en la documentación detallada: InventoryRepository.class]


Estructura: target > classes > com > invcontrol > repository
Archivo: RoleRepository.class
--------------------------------------------------
[Archivo no incluido en la documentación detallada: RoleRepository.class]


Estructura: target > classes > com > invcontrol > repository
Archivo: UserRepository.class
--------------------------------------------------
[Archivo no incluido en la documentación detallada: UserRepository.class]


Estructura: target > classes > com > invcontrol > service
Archivo: InventoryService.class
--------------------------------------------------
[Archivo no incluido en la documentación detallada: InventoryService.class]


Estructura: target > classes > com > invcontrol > service
Archivo: UserDetailServiceImpl.class
--------------------------------------------------
[Archivo no incluido en la documentación detallada: UserDetailServiceImpl.class]


Estructura: target > classes > com > invcontrol > util
Archivo: JwtUtils.class
--------------------------------------------------
[Archivo no incluido en la documentación detallada: JwtUtils.class]


