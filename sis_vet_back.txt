Estructura: .
Archivo: DemoApplication.java
--------------------------------------------------
package com.example.demo;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class DemoApplication {

	public static void main(String[] args) {
		SpringApplication.run(DemoApplication.class, args);	
	}
}

Estructura: config
Archivo: CustomPermissionEvaluator.java
--------------------------------------------------
package com.example.demo.config;

import com.google.cloud.firestore.DocumentSnapshot;
import com.google.cloud.firestore.Firestore;
import com.google.cloud.firestore.QueryDocumentSnapshot;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.access.PermissionEvaluator;
import org.springframework.security.core.Authentication;
import org.springframework.stereotype.Component;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.Serializable;
import java.util.List;


@Component
public class CustomPermissionEvaluator implements PermissionEvaluator {
    private static final Logger logger = LoggerFactory.getLogger(CustomPermissionEvaluator.class);

    @Autowired
    private Firestore firestore;

    @Override
    public boolean hasPermission(Authentication authentication, Object targetDomainObject, Object permission) {
        //logger.info("ENTRA A LA FUNCION erronea");
        return hasPermission(authentication, null, null, permission);
    }

    @Override
    public boolean hasPermission(Authentication auth, Serializable targetId, String targetType, Object permission) {
        logger.info("ENTRA A LA FUNCION");
        if (auth == null || !(permission instanceof String)) {
            return false;
        }
        String username = auth.getName();
        String permissionStr = (String) permission;

        try {
            // Obtener el documento del usuario
            DocumentSnapshot userDoc = firestore.collection("users").document(username).get().get();
            if (!userDoc.exists()) {
                logger.debug("User document not found for username: {}", username);
                return false;
            }

            // Obtener roles del usuario
            List<String> userRoles = (List<String>) userDoc.get("roles");
            logger.debug("Roles for user {}: {}", username, userRoles);
            if (userRoles == null || userRoles.isEmpty()) {
                logger.debug("No roles found for user: {}", username);
                return false;
            }

            // Iterar sobre los roles del usuario
            for (String roleName : userRoles) {
                logger.debug("Checking role by name: {}", roleName);

                // Buscar el rol basado en el campo "name" en lugar del ID del documento
                List<QueryDocumentSnapshot> roleDocs = firestore.collection("roles")
                        .whereEqualTo("name", roleName)
                        .get().get().getDocuments();

                if (!roleDocs.isEmpty()) {
                    DocumentSnapshot roleDoc = roleDocs.get(0);  // Tomar el primer documento si existe
                    List<String> permissions = (List<String>) roleDoc.get("permissions");
                    logger.debug("Permissions for role '{}': {}", roleName, permissions);
                    if (permissions != null && permissions.contains(permissionStr)) {
                        logger.info("Permission '{}' granted for user '{}' with role '{}'", permissionStr, username, roleName);
                        return true;
                    }
                } else {
                    logger.warn("Role not found for role name: {}", roleName);
                }
            }

            logger.info("Permission '{}' denied for user '{}'", permissionStr, username);
            return false;
        } catch (Exception e) {
            logger.error("Error checking permission: '{}' for user: '{}'", permissionStr, username, e);
            return false;
        }
    }

}

Estructura: config
Archivo: FirebaseConfig.java
--------------------------------------------------
package com.example.demo.config;

import com.google.auth.oauth2.GoogleCredentials;
import com.google.firebase.FirebaseApp;
import com.google.firebase.FirebaseOptions;
import com.google.cloud.firestore.Firestore;
import com.google.firebase.auth.FirebaseAuth;
import com.google.firebase.cloud.FirestoreClient;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.io.ClassPathResource;

import java.io.IOException;
import java.io.InputStream;

@Configuration
public class FirebaseConfig {

    @Value("${firebase.database.url}")
    private String databaseUrl;

    @Value("${firebase.config.path}")
    private String configPath;

    @Bean
    public FirebaseApp firebaseApp() throws IOException {
        if (FirebaseApp.getApps().isEmpty()) {
            InputStream serviceAccount = new ClassPathResource(configPath).getInputStream();

            FirebaseOptions options = FirebaseOptions.builder()
                    .setCredentials(GoogleCredentials.fromStream(serviceAccount))
                    .setDatabaseUrl(databaseUrl)
                    .build();

            return FirebaseApp.initializeApp(options);
        } else {
            return FirebaseApp.getInstance();  // Return the existing FirebaseApp instance
        }
    }

    @Bean
    public Firestore firestore() throws IOException {
        return FirestoreClient.getFirestore(firebaseApp());
    }

    @Bean
    public FirebaseAuth firebaseAuth() throws IOException {
        return FirebaseAuth.getInstance(firebaseApp());
    }
}


Estructura: config
Archivo: MailConfig.java
--------------------------------------------------
package com.example.demo.config;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.mail.javamail.JavaMailSender;
import org.springframework.mail.javamail.JavaMailSenderImpl;

import java.util.Properties;

@Configuration
public class MailConfig {

    @Bean
    public JavaMailSender javaMailSender(
            @Value("${spring.mail.host}") String host,
            @Value("${spring.mail.port}") int port,
            @Value("${spring.mail.username}") String username,
            @Value("${spring.mail.password}") String password) {

        JavaMailSenderImpl mailSender = new JavaMailSenderImpl();
        mailSender.setHost(host);
        mailSender.setPort(port);
        mailSender.setUsername(username);
        mailSender.setPassword(password);

        Properties props = mailSender.getJavaMailProperties();
        props.put("mail.transport.protocol", "smtp");
        props.put("mail.smtp.auth", "true");
        props.put("mail.smtp.starttls.enable", "true");
        props.put("mail.debug", "true"); // Habilita logs detallados

        return mailSender;
    }
}

Estructura: config
Archivo: SecurityConfig.java
--------------------------------------------------
package com.example.demo.config;

import com.example.demo.security.FirebaseAuthenticationFilter;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.access.PermissionEvaluator;
import org.springframework.security.access.expression.method.DefaultMethodSecurityExpressionHandler;
import org.springframework.security.access.expression.method.MethodSecurityExpressionHandler;
import org.springframework.security.config.Customizer;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.CorsConfigurationSource;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;
import org.springframework.web.servlet.config.annotation.CorsRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

import java.util.Arrays;
import java.util.Collections;

@Configuration
@EnableWebSecurity
@EnableMethodSecurity(prePostEnabled = true)  // Asegura que los permisos en métodos sean procesados
public class SecurityConfig {
    private static final String[] WHITE_LIST_URL = {
            "/api/auth/login",
            "/api/auth/register",
            "/v2/api-docs",
            "/v3/api-docs",
            "/v3/api-docs/**",
            "/swagger-resources",
            "/swagger-resources/**",
            "/configuration/ui",
            "/configuration/security",
            "/swagger-ui/**",
            "/swagger-ui.html",
            "/webjars/**",
            "/swagger-ui/index.html",
            "/favicon.ico"
    };
    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
    @Bean
    public MethodSecurityExpressionHandler expressionHandler(PermissionEvaluator permissionEvaluator) {
        DefaultMethodSecurityExpressionHandler expressionHandler = new DefaultMethodSecurityExpressionHandler();
        expressionHandler.setPermissionEvaluator(permissionEvaluator);  // Vincula el evaluador personalizado
        return expressionHandler;
    }
    @Bean
    public PermissionEvaluator permissionEvaluator() {
        return new CustomPermissionEvaluator();
    }

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        return http
                .csrf(csrf -> csrf.disable())
                .cors(Customizer.withDefaults())
                .sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
                .authorizeHttpRequests(authorize -> {
                    //authorize.requestMatchers("/api/auth/login", "/api/auth/register").permitAll();
                    authorize.requestMatchers(WHITE_LIST_URL).permitAll();
//                    authorize.requestMatchers(HttpMethod.POST, "/api/users/create-with-roles").hasAuthority("ROLE_VETERINARIO");
//                    authorize.requestMatchers(HttpMethod.GET, "/api/users").hasAuthority("ROLE_VETERINARIO");
//                    authorize.requestMatchers(HttpMethod.POST, "/api/users").hasAuthority("ROLE_VETERINARIO");
//                    authorize.requestMatchers(HttpMethod.DELETE, "/api/users/**").hasAuthority("ROLE_VETERINARIO");
//                    authorize.requestMatchers("/api/roles").hasAuthority("ROLE_VETERINARIO");
//                    authorize.requestMatchers("/api/users/*/toggle-status").hasAuthority("ROLE_VETERINARIO");
//                    //authorize.requestMatchers(HttpMethod.GET, "/api/users/*").hasAnyAuthority("ROLE_VETERINARIO", "ROLE_RECEPCIONISTA");
//                    authorize.requestMatchers("/api/users/*/notes").hasAnyAuthority("ROLE_VETERINARIO", "ROLE_RECEPCIONISTA");
//                    authorize.requestMatchers(HttpMethod.PUT, "/api/users/me").authenticated();
//                    authorize.requestMatchers("/api/users/me/change-password").authenticated();
//                    authorize.requestMatchers("/api/pets").authenticated();
                    authorize.anyRequest().authenticated();
                })
                .addFilterBefore(new FirebaseAuthenticationFilter(), UsernamePasswordAuthenticationFilter.class)
                .build();
    }
    @Bean
    public CorsConfigurationSource corsConfigurationSource() {
        CorsConfiguration corsConfiguration = new CorsConfiguration();
        corsConfiguration.setAllowCredentials(true);
        corsConfiguration.setAllowedOrigins(Collections.singletonList("http://localhost:3000"));
        corsConfiguration.setAllowedMethods(Arrays.asList("GET", "POST", "PUT", "DELETE"));
        corsConfiguration.setAllowedHeaders(Arrays.asList("Authorization", "Cache-Control", "Content-Type"));

        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/**", corsConfiguration);
        return source;
    }
    @Bean
    WebMvcConfigurer webMvcConfigurer() {
        return new WebMvcConfigurer() {
            @Override
            public void addCorsMappings(CorsRegistry registry) {
                registry.addMapping("/**").allowedOrigins("http://localhost:3000");
            }
        };
    }

}







Estructura: config
Archivo: SwaggerConfig.java
--------------------------------------------------
package com.example.demo.config;

import io.swagger.v3.oas.annotations.OpenAPIDefinition;
import io.swagger.v3.oas.annotations.enums.SecuritySchemeIn;
import io.swagger.v3.oas.annotations.enums.SecuritySchemeType;
import io.swagger.v3.oas.annotations.info.Contact;
import io.swagger.v3.oas.annotations.info.Info;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.security.SecurityScheme;
import io.swagger.v3.oas.annotations.servers.Server;
import org.springframework.context.annotation.Configuration;

@Configuration
@OpenAPIDefinition(
        info = @Info(
                title = "API Sistema Veterinario",
                version = "1.0",
                description = "API para la gestión de sistema veterinario",
                contact = @Contact(
                        name = "Soporte",
                        email = "soporte@veterinaria.com"
                )
        ),
        security = {
                @SecurityRequirement(name = "Bearer Auth")
        },
        servers = {
                @Server(
                        description = "Local ENV",
                        url = "http://localhost:8080"
                )
        }
)
@SecurityScheme(
        name = "Bearer Auth",
        description = "JWT auth description",
        scheme = "bearer",
        type = SecuritySchemeType.HTTP,
        bearerFormat = "JWT",
        in = SecuritySchemeIn.HEADER
)
public class SwaggerConfig {


}

Estructura: controller
Archivo: AppointmentController.java
--------------------------------------------------
package com.example.demo.controller;

import com.example.demo.dto.ApiResponse;
import com.example.demo.dto.AppointmentDTOs;
import com.example.demo.dto.AppointmentDTOs.*;
import com.example.demo.dto.PaginatedResponse;
import com.example.demo.dto.PaginationRequest;
import com.example.demo.service.AppointmentService;
import jakarta.validation.Valid;

import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.format.annotation.DateTimeFormat;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;
import java.util.Date;

@Slf4j
@RestController
@RequestMapping("/api/appointments")
public class AppointmentController {

    @Autowired
    private AppointmentService appointmentService;

    @GetMapping("/daily")
    @PreAuthorize("hasPermission(null, 'VER_CITAS_DIARIAS')")
    public ResponseEntity<ApiResponse<PaginatedResponse<AppointmentResponse>>> getDailyAppointments(
            @ModelAttribute PaginationRequest paginationRequest,
            @RequestParam(required = false) @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) Date date,
            @RequestParam String veterinarianId) {
        try {
            log.info("Fetching daily appointments for date: {}, veterinarianId: {}", date, veterinarianId);
            if (date == null) {
                date = new Date();
            }
            return ResponseEntity.ok(ApiResponse.success(
                    appointmentService.getVeterinarianDailyAppointments(veterinarianId, date, paginationRequest)));
        } catch (Exception e) {
            log.error("Error fetching daily appointments: ", e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                    .body(ApiResponse.error("INTERNAL_SERVER_ERROR", "Error fetching daily appointments."));
        }
    }

    @GetMapping("/my-pets")
    @PreAuthorize("hasPermission('', 'VER_CITAS_MASCOTAS')")
    public ResponseEntity<ApiResponse<PaginatedResponse<AppointmentSummaryByPet>>> getClientPetsAppointments(
            @ModelAttribute PaginationRequest paginationRequest) {
        return ResponseEntity.ok(ApiResponse.success(
                appointmentService.getClientPetsAppointments(paginationRequest)));
    }
    @PostMapping("/schedule")
    @PreAuthorize("hasPermission(null, 'PROGRAMAR_CITA')")
    public ResponseEntity<ApiResponse<AppointmentResponse>> scheduleAppointment(
            @Valid @RequestBody CreateAppointmentRequest request) {
        return ResponseEntity.ok(ApiResponse.success(
                appointmentService.createAppointment(request)
        ));
    }

    @PostMapping("/{appointmentId}/reschedule")
    @PreAuthorize("hasPermission(null, 'REPROGRAMAR_CITA') and @appointmentService.isOwner(#appointmentId)")
    public ResponseEntity<ApiResponse<AppointmentDTOs.AppointmentResponse>> rescheduleAppointment(
            @PathVariable String appointmentId,
            @Valid @RequestBody AppointmentDTOs.RescheduleRequest request
    ) {
        return ResponseEntity.ok(ApiResponse.success(
                appointmentService.rescheduleAppointment(appointmentId, request)
        ));
    }

    @PostMapping("/{appointmentId}/cancel")
    @PreAuthorize("hasPermission(null, 'PROGRAMAR_CITA') or @appointmentService.isOwner(#appointmentId)")
    public ResponseEntity<ApiResponse<AppointmentDTOs.AppointmentResponse>> cancelAppointment(
            @PathVariable String appointmentId
    ) {
        return ResponseEntity.ok(ApiResponse.success(
                appointmentService.cancelAppointment(appointmentId)
        ));
    }
}

Estructura: controller
Archivo: AppointmentReminderController.java
--------------------------------------------------
package com.example.demo.controller;

import com.example.demo.dto.ApiResponse;
import com.example.demo.dto.ReminderDTO;
import com.example.demo.service.ReminderService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/reminders")
public class AppointmentReminderController {

    @Autowired
    private ReminderService reminderService;

    @PutMapping("/config")
    @PreAuthorize("hasPermission('', 'GESTIONAR_RECORDATORIOS')")
    public ResponseEntity<ApiResponse<Void>> updateReminderConfig(@RequestBody ReminderDTO config) {
        reminderService.updateReminderConfig(config);
        return ResponseEntity.ok(ApiResponse.success(null));
    }

    @GetMapping("/confirm")
    public ResponseEntity<ApiResponse<Void>> confirmAppointment(
            @RequestParam String id,
            @RequestParam String token) {
        reminderService.confirmAppointment(id, token);
        return ResponseEntity.ok(ApiResponse.success(null));
    }
}

Estructura: controller
Archivo: AuthController.java
--------------------------------------------------
package com.example.demo.controller;

import com.example.demo.dto.ApiResponse;
import com.example.demo.dto.UserDTOs;
import com.example.demo.service.AuthService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import com.example.demo.dto.AuthDTOs.*;

@RestController
@RequestMapping("/api/auth")
public class AuthController {

    @Autowired
    private AuthService authService;

    @PostMapping("/register")
    public ResponseEntity<ApiResponse<AuthResponse>> registerUser(@RequestBody RegisterRequest request) {
        AuthResponse response = authService.registerUser(request);
        return ResponseEntity.ok(ApiResponse.success(response));
    }

    @PostMapping("/login")
    public ResponseEntity<ApiResponse<AuthResponse>> loginUser(@RequestBody LoginRequest request) {
        AuthResponse response = authService.loginUser(request);
        return ResponseEntity.ok(ApiResponse.success(response));
    }

    @PostMapping("/logout")
    public ResponseEntity<ApiResponse<Void>> logoutUser() {
        authService.logout();
        return ResponseEntity.ok(ApiResponse.success(null));
    }

    @PostMapping("/refresh-token")
    public ResponseEntity<ApiResponse<AuthResponse>> refreshToken(@RequestParam String uid) {
        AuthResponse response = authService.refreshToken(uid);
        return ResponseEntity.ok(ApiResponse.success(response));
    }

    @PostMapping("/reset-password")
    public ResponseEntity<ApiResponse<Void>> resetPassword(@RequestParam String email) {
        authService.resetPassword(email);
        return ResponseEntity.ok(ApiResponse.success(null));
    }
}

Estructura: controller
Archivo: ClientAppointmentController.java
--------------------------------------------------
package com.example.demo.controller;

import com.example.demo.dto.ApiResponse;
import com.example.demo.dto.AppointmentDTOs;
import com.example.demo.dto.PaginatedResponse;
import com.example.demo.dto.PaginationRequest;
import com.example.demo.service.ClientAppointmentService;
import jakarta.validation.Valid;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

// controller/ClientAppointmentController.java
@RestController
@RequestMapping("/api/client/appointments")
public class ClientAppointmentController {

    @Autowired
    private ClientAppointmentService clientAppointmentService;

    // Obtener todas las citas del cliente actual
    @GetMapping
    @PreAuthorize("hasPermission(null, 'VER_CITAS_DE_MASCOTAS_MIAS')")
    public ResponseEntity<ApiResponse<PaginatedResponse<AppointmentDTOs.ClientPetAppointmentDTO>>> getMyAppointments(
            @ModelAttribute PaginationRequest request) {
        return ResponseEntity.ok(ApiResponse.success(
                clientAppointmentService.getClientAppointments(request)));
    }

    // Cancelar una cita
    @PostMapping("/{appointmentId}/cancel")
    @PreAuthorize("hasPermission(null, 'CANCELAR_MI_CITA')")
    public ResponseEntity<ApiResponse<AppointmentDTOs.ClientPetAppointmentDTO>> cancelAppointment(
            @PathVariable String appointmentId) {
        return ResponseEntity.ok(ApiResponse.success(
                clientAppointmentService.cancelAppointment(appointmentId)));
    }

    // Reprogramar una cita
    @PostMapping("/{appointmentId}/reschedule")
    @PreAuthorize("hasPermission(null, 'REPROGRAMAR_MI_CITA')")
    public ResponseEntity<ApiResponse<AppointmentDTOs.ClientPetAppointmentDTO>> rescheduleAppointment(
            @PathVariable String appointmentId,
            @Valid @RequestBody AppointmentDTOs.RescheduleRequest request) {
        return ResponseEntity.ok(ApiResponse.success(
                clientAppointmentService.rescheduleAppointment(appointmentId, request)));
    }
}

Estructura: controller
Archivo: FavoriteController.java
--------------------------------------------------
package com.example.demo.controller;

import com.example.demo.dto.ApiResponse;
import com.example.demo.dto.FavoriteDTOs.*;
import com.example.demo.model.ItemType;
import com.example.demo.service.FavoriteService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;
import java.util.List;

@RestController
@RequestMapping("/api/favorites")
public class FavoriteController {

    @Autowired
    private FavoriteService favoriteService;

    /**
     * Obtiene todos los favoritos del veterinario actual
     */
    @GetMapping
    @PreAuthorize("hasPermission('', 'GESTIONAR_FAVORITOS')")
    public ResponseEntity<ApiResponse<List<FavoriteResponse>>> getFavorites() {
        return ResponseEntity.ok(ApiResponse.success(
                favoriteService.getCurrentUserFavorites()));
    }

    /**
     * Alterna el estado de favorito de un item
     */
    @PostMapping("/toggle")
    @PreAuthorize("hasPermission('', 'GESTIONAR_FAVORITOS')")
    public ResponseEntity<ApiResponse<FavoriteResponse>> toggleFavorite(
            @RequestBody ToggleFavoriteRequest request) {
        return ResponseEntity.ok(ApiResponse.success(
                favoriteService.toggleFavorite(request.getItemId(), ItemType.valueOf(request.getItemType()))));
    }

    /**
     * Verifica si un item está marcado como favorito
     */
    @GetMapping("/check")
    @PreAuthorize("hasPermission('', 'GESTIONAR_FAVORITOS')")
    public ResponseEntity<ApiResponse<Boolean>> checkFavorite(
            @RequestParam String itemId,
            @RequestParam String itemType) {
        return ResponseEntity.ok(ApiResponse.success(
                favoriteService.isFavorite(itemId, itemType)));
    }
}

Estructura: controller
Archivo: HistorialClinicoController.java
--------------------------------------------------
package com.example.demo.controller;

import com.example.demo.dto.ApiResponse;
import com.example.demo.dto.HistorialClinicoDTOs.*;
import com.example.demo.service.HistorialClinicoService;
import jakarta.validation.Valid;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/historial-clinico")
public class HistorialClinicoController {

    @Autowired
    private HistorialClinicoService historialClinicoService;

    @PostMapping("/mascota/{petId}")
    @PreAuthorize("hasPermission('', 'CREAR_HISTORIAL_CLINICO')")
    public ResponseEntity<ApiResponse<HistorialClinicoResponse>> createHistorial(
            @PathVariable String petId,
            @Valid @RequestBody CreateHistorialRequest request) {
        return ResponseEntity.ok(ApiResponse.success(
                historialClinicoService.createHistorial(petId, request)));
    }

    @PutMapping("/{historialId}")
    @PreAuthorize("hasPermission('', 'ACTUALIZAR_HISTORIAL_CLINICO')")
    public ResponseEntity<ApiResponse<HistorialClinicoResponse>> updateHistorial(
            @PathVariable String historialId,
            @Valid @RequestBody UpdateHistorialRequest request) {
        return ResponseEntity.ok(ApiResponse.success(
                historialClinicoService.updateHistorial(historialId, request)));
    }

    @GetMapping("/mascota/{petId}")
    @PreAuthorize("hasPermission('', 'VER_HISTORIAL_CLINICO')")
    public ResponseEntity<ApiResponse<List<HistorialClinicoResponse>>> getHistorialByPetId(
            @PathVariable String petId) {
        return ResponseEntity.ok(ApiResponse.success(
                historialClinicoService.getHistorialByPetId(petId)));
    }

    @GetMapping("/{historialId}")
    @PreAuthorize("hasPermission('', 'VER_HISTORIAL_CLINICO')")
    public ResponseEntity<ApiResponse<HistorialClinicoResponse>> getHistorialById(
            @PathVariable String historialId) {
        return ResponseEntity.ok(ApiResponse.success(
                historialClinicoService.getHistorialById(historialId)));
    }
}

Estructura: controller
Archivo: InventoryController.java
--------------------------------------------------
package com.example.demo.controller;

import com.example.demo.dto.ApiResponse;
import com.example.demo.dto.InventoryDTOs.*;
import com.example.demo.dto.PaginatedResponse;
import com.example.demo.dto.PaginationRequest;
import com.example.demo.model.InventoryItem;
import com.example.demo.service.InventoryService;
import jakarta.validation.Valid;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/inventory")
public class InventoryController {

    @Autowired
    private InventoryService inventoryService;

    @GetMapping
    @PreAuthorize("hasPermission('', 'GESTIONAR_INVENTARIO')")
    public ResponseEntity<ApiResponse<PaginatedResponse<InventoryItemResponse>>> getAllItems(
            @ModelAttribute PaginationRequest paginationRequest) {
        return ResponseEntity.ok(ApiResponse.success(
                inventoryService.getAllItems(paginationRequest)));
    }
    @GetMapping("/search")
    @PreAuthorize("hasPermission('', 'GESTIONAR_INVENTARIO')")
    public ResponseEntity<ApiResponse<PaginatedResponse<InventoryItemResponse>>> searchInventory(
            @RequestParam String searchTerm,
            @ModelAttribute PaginationRequest paginationRequest) {
        try {
            return ResponseEntity.ok(ApiResponse.success(
                    inventoryService.searchByName(searchTerm, paginationRequest)));
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                    .body(ApiResponse.error("PROCESSING_ERROR", e.getMessage()));
        }
    }

    @GetMapping("/low-stock")
    @PreAuthorize("hasPermission('', 'GESTIONAR_INVENTARIO')")
    public ResponseEntity<ApiResponse<PaginatedResponse<LowStockAlertDTO>>> getLowStockItems(
            @ModelAttribute PaginationRequest paginationRequest) {
        return ResponseEntity.ok(ApiResponse.success(
                inventoryService.getLowStockItems(paginationRequest)));
    }

    @PostMapping("/{productId}/threshold")
    @PreAuthorize("hasPermission('', 'AGESTIONAR_INVENTARIO')")
    public ResponseEntity<ApiResponse<InventoryItemResponse>> updateThreshold(
            @PathVariable String productId,
            @Valid @RequestBody UpdateThresholdRequest request) {
        return ResponseEntity.ok(ApiResponse.success(
                inventoryService.updateThreshold(productId, request.getMinThreshold())));
    }

    @PostMapping("/restock-orders")
    @PreAuthorize("hasPermission('', 'GESTIONAR_INVENTARIO')")
    public ResponseEntity<ApiResponse<RestockOrderDTO>> createRestockOrder(
            @Valid @RequestBody CreateRestockOrderRequest request) {
        return ResponseEntity.ok(ApiResponse.success(
                inventoryService.createRestockOrder(request)));
    }

    @PostMapping("/items")
    @PreAuthorize("hasPermission('', 'GESTIONAR_INVENTARIO')")
    public ResponseEntity<ApiResponse<InventoryItemResponse>> addInventoryItem(
            @RequestBody AddInventoryItemRequest request) {
        try {
            // Convertimos el DTO a entidad
            InventoryItem newItem = new InventoryItem();
            newItem.setName(request.getName());
            newItem.setQuantity(request.getQuantity());
            newItem.setMinThreshold(request.getMinThreshold());
            newItem.setPrice(request.getPrice());

            // Llamamos al servicio para crear el item
            InventoryItem createdItem = inventoryService.addInventoryItem(newItem);

            // Convertimos la respuesta a DTO
            InventoryItemResponse response = convertToResponse(createdItem);

            return ResponseEntity.ok(ApiResponse.success(response));

        } catch (Exception e) {
            return ResponseEntity.badRequest()
                    .body(ApiResponse.error("ERROR_ADDING_ITEM", e.getMessage()));
        }
    }

    /**
     * Endpoint para actualizar un item existente
     */
    @PutMapping("/items/{itemId}")
    @PreAuthorize("hasPermission('', 'GESTIONAR_INVENTARIO')")
    public ResponseEntity<ApiResponse<InventoryItemResponse>> updateInventoryItem(
            @PathVariable String itemId,
            @RequestBody UpdateInventoryItemRequest request) {
        try {
            // Convertimos el DTO a entidad
            InventoryItem itemToUpdate = new InventoryItem();
            itemToUpdate.setQuantity(request.getQuantity());
            itemToUpdate.setMinThreshold(request.getMinThreshold());
            itemToUpdate.setPrice(request.getPrice());

            // Llamamos al servicio para actualizar
            InventoryItem updatedItem = inventoryService.updateInventoryItem(itemId, itemToUpdate);

            // Convertimos la respuesta a DTO
            InventoryItemResponse response = convertToResponse(updatedItem);

            return ResponseEntity.ok(ApiResponse.success(response));

        } catch (Exception e) {
            return ResponseEntity.badRequest()
                    .body(ApiResponse.error("ERROR_UPDATING_ITEM", e.getMessage()));
        }
    }

    /**
     * Convierte un InventoryItem a InventoryItemResponse
     */
    private InventoryItemResponse convertToResponse(InventoryItem item) {
        return InventoryItemResponse.builder()
                .id(item.getId())
                .name(item.getName())
                .quantity(item.getQuantity())
                .minThreshold(item.getMinThreshold())
                .price(item.getPrice())
                .recommendedOrderQuantity(item.getRecommendedOrderQuantity())
                .dateAdded(item.getDateAdded())
                .lastUpdated(item.getLastUpdated())
                .build();
    }


}

Estructura: controller
Archivo: PaymentHistoryController.java
--------------------------------------------------
package com.example.demo.controller;


import com.example.demo.dto.ApiResponse;
import com.example.demo.dto.PaginatedResponse;
import com.example.demo.dto.PaymentHistoryDTOs.*;
import com.example.demo.dto.PaginationRequest;
import com.example.demo.service.PaymentHistoryService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.format.annotation.DateTimeFormat;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.util.Date;

@Slf4j
@RestController
@RequestMapping("/api/payment-history")
public class PaymentHistoryController {

    @Autowired
    private PaymentHistoryService paymentHistoryService;

    /**
     * Obtiene el historial de pagos paginado para el cliente actual
     */
    @GetMapping
    @PreAuthorize("hasPermission('', 'VER_HISTORIAL_PAGOS')")
    public ResponseEntity<ApiResponse<PaginatedResponse<PaymentHistoryResponse>>> getPaymentHistory(
            @ModelAttribute PaginationRequest paginationRequest,
            @RequestParam(required = false) @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) Date fechaInicio,
            @RequestParam(required = false) @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) Date fechaFin,
            @RequestParam(required = false) String petId,
            @RequestParam(required = false) Double montoMinimo,
            @RequestParam(required = false) Double montoMaximo) {

        // Establecer valores por defecto para la paginación
        if (paginationRequest.getSize() <= 0) {
            paginationRequest.setSize(10);  // Tamaño de página por defecto
        }
        if (paginationRequest.getSortBy() == null) {
            paginationRequest.setSortBy("fechaVisita");  // Campo de ordenamiento por defecto
        }
        if (paginationRequest.getSortDirection() == null) {
            paginationRequest.setSortDirection("DESC");  // Dirección de ordenamiento por defecto
        }

        PaymentHistoryFilterRequest filterRequest = PaymentHistoryFilterRequest.builder()
                .fechaInicio(fechaInicio)
                .fechaFin(fechaFin)
                .petId(petId)
                .montoMinimo(montoMinimo)
                .montoMaximo(montoMaximo)
                .build();

        return ResponseEntity.ok(ApiResponse.success(
                paymentHistoryService.getPaymentHistory(filterRequest, paginationRequest)
        ));
    }

    /**
     * Obtiene el detalle completo de un pago específico
     */
    @GetMapping("/{paymentId}")
    @PreAuthorize("hasPermission('', 'VER_DETALLE_PAGO')")
    public ResponseEntity<ApiResponse<PaymentHistoryResponse>> getPaymentDetail(
            @PathVariable String paymentId) {
        return ResponseEntity.ok(ApiResponse.success(
                paymentHistoryService.getPaymentDetail(paymentId)
        ));
    }

    /**
     * Obtiene el resumen de gastos por período
     */
    @GetMapping("/summary")
    @PreAuthorize("hasPermission('', 'VER_RESUMEN_PAGOS')")
    public ResponseEntity<ApiResponse<Object>> getPaymentSummary(
            @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) Date fechaInicio,
            @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) Date fechaFin) {
        return ResponseEntity.ok(ApiResponse.success(
                paymentHistoryService.getPaymentSummary(fechaInicio, fechaFin)
        ));
    }
}


Estructura: controller
Archivo: PetController.java
--------------------------------------------------
package com.example.demo.controller;

import com.example.demo.dto.ApiResponse;
import com.example.demo.dto.PaginatedResponse;
import com.example.demo.dto.PaginationRequest;
import com.example.demo.dto.PetDTOs.*;
import com.example.demo.exception.CustomExceptions;
import com.example.demo.service.PetService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/pets")
public class PetController {

    @Autowired
    private PetService petService;
    @GetMapping("/me")
    @PreAuthorize("hasPermission('', 'VER_MIS_MASCOTAS')")
    public ResponseEntity<ApiResponse<List<PetResponse>>> getCurrentUserPets() {
        return ResponseEntity.ok(ApiResponse.success(petService.getCurrentUserPets()));
    }

    @PostMapping
    @PreAuthorize("hasPermission('', 'AGREGAR_MASCOTA')")
    public ResponseEntity<ApiResponse<PetResponse>> createPet(@RequestBody CreatePetRequest request) {
        return ResponseEntity.ok(ApiResponse.success(petService.createPet(request)));
    }

    @PutMapping("/{id}")
    @PreAuthorize("hasPermission('', 'EDITAR_MASCOTA') or @petService.isOwner(#id)")
    public ResponseEntity<ApiResponse<PetResponse>> updatePet(@PathVariable String id, @RequestBody UpdatePetRequest request) {
        return ResponseEntity.ok(ApiResponse.success(petService.updatePet(id, request)));
    }

    @GetMapping("/{id}")
    @PreAuthorize("hasPermission('', 'VER_MASCOTA_XID') or @petService.isOwner(#id)")
    public ResponseEntity<ApiResponse<PetResponse>> getPetById(@PathVariable String id) {
        return ResponseEntity.ok(ApiResponse.success(petService.getPetById(id)));
    }

    @GetMapping("/{id}/medical-history")
    @PreAuthorize("hasPermission('', 'VER_HISTORIAL_MEDICO') or @petService.isOwner(#id)")
    public ResponseEntity<ApiResponse<PaginatedResponse<MedicalRecordResponse>>> getPetMedicalHistory(
            @PathVariable String id,
            @ModelAttribute PaginationRequest paginationRequest) {
        return ResponseEntity.ok(ApiResponse.success(petService.getPetMedicalHistory(id, paginationRequest)));
    }

    @PostMapping("/{id}/medical-record")
    @PreAuthorize("hasPermission('', 'AGREGAR_HISTORIAL_MEDICO')")
    public ResponseEntity<ApiResponse<MedicalRecordResponse>> addMedicalRecord(@PathVariable String id, @RequestBody AddMedicalRecordRequest request) {
        return ResponseEntity.ok(ApiResponse.success(petService.addMedicalRecord(id, request)));
    }
    @DeleteMapping("/{id}")
    @PreAuthorize("hasPermission('', 'ELIMINAR_MASCOTA') or @petService.isOwner(#id)")
    public ResponseEntity<ApiResponse<Void>> deletePet(@PathVariable String id) {
        try {
            petService.deletePet(id);
            return ResponseEntity.ok(ApiResponse.success(null));
        } catch (CustomExceptions.NotFoundException e) {
            return ResponseEntity.status(HttpStatus.NOT_FOUND)
                    .body(ApiResponse.error("PET_NOT_FOUND", e.getMessage()));
        } catch (CustomExceptions.UnauthorizedException e) {
            return ResponseEntity.status(HttpStatus.FORBIDDEN)
                    .body(ApiResponse.error("UNAUTHORIZED", e.getMessage()));
        } catch (CustomExceptions.ProcessingException e) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                    .body(ApiResponse.error("PROCESSING_ERROR", e.getMessage()));
        }
    }
    @GetMapping
    @PreAuthorize("hasPermission('', 'VER_TODAS_LAS_MASCOTAS')")
    public ResponseEntity<ApiResponse<PaginatedResponse<PetResponse>>> getAllPets(
            @ModelAttribute PaginationRequest paginationRequest) {
        return ResponseEntity.ok(ApiResponse.success(petService.getAllPets(paginationRequest)));
    }
    @GetMapping("/user/{userId}/pets")
    @PreAuthorize("hasPermission('', 'VER_MASCOTAS_USUARIO')")
    public ResponseEntity<ApiResponse<PaginatedResponse<PetResponse>>> getPetsByUserId(
            @PathVariable String userId,
            @ModelAttribute PaginationRequest paginationRequest) {
        return ResponseEntity.ok(ApiResponse.success(petService.getPetsByUserId(userId, paginationRequest)));
    }
}

Estructura: controller
Archivo: RoleController.java
--------------------------------------------------
package com.example.demo.controller;

import com.example.demo.dto.ApiResponse;
import com.example.demo.dto.UserDTOs;
import com.example.demo.model.Role;
import com.example.demo.service.RolePermissionService;
import com.example.demo.service.UserService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/api/roles")
public class RoleController {

    @Autowired
    private RolePermissionService rolePermissionService;
    @Autowired
    private UserService userService;

    @GetMapping
    public ResponseEntity<ApiResponse<List<UserDTOs.RolePermissionDTO>>> getAllRolePermissions() {
        return ResponseEntity.ok(ApiResponse.success(rolePermissionService.getAllRolePermissions()));
    }
    @PutMapping("/{roleName}/permissions")
    @PreAuthorize("hasPermission('', 'GESTIONAR_ROLES')")
    public ResponseEntity<ApiResponse<UserDTOs.RolePermissionDTO>> updateRolePermissions(
            @PathVariable String roleName,
            @RequestBody List<String> permissions
    ) {
        UserDTOs.RolePermissionDTO updatedRole = rolePermissionService.updateRolePermissions(roleName, permissions);
        return ResponseEntity.ok(ApiResponse.success(updatedRole));
    }

    // Obtener los permisos de un rol específico
    @GetMapping("/{roleName}/permissions")
    @PreAuthorize("hasPermission('', 'VER_ROLES')")
    public ResponseEntity<ApiResponse<List<String>>> getRolePermissions(@PathVariable String roleName) {
        List<String> permissions = rolePermissionService.getRolePermissionsByName(roleName);
        return ResponseEntity.ok(ApiResponse.success(permissions));
    }
    @PutMapping("/{userId}/roles")
    @PreAuthorize("hasPermission('', 'GESTIONAR_USUARIOS')")
    public ResponseEntity<ApiResponse<UserDTOs.UserResponse>> updateUserRoles(@PathVariable String userId, @RequestBody List<Role> roles) {
        UserDTOs.UserResponse updatedUser = userService.updateUserRoles(userId, roles);
        return ResponseEntity.ok(ApiResponse.success(updatedUser));
    }
}

Estructura: controller
Archivo: ServiceController.java
--------------------------------------------------
package com.example.demo.controller;

import com.example.demo.dto.*;
import com.example.demo.model.ServiceCategory;
import com.example.demo.service.VetServiceListService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/services")
public class ServiceController {

    @Autowired
    private VetServiceListService serviceListService;

    /**
     * Obtiene la lista de servicios, opcionalmente filtrada y paginada
     */
    @GetMapping("/list")
    @PreAuthorize("hasPermission('', 'VER_SERVICIOS')")
    public ResponseEntity<ApiResponse<PaginatedResponse<ServiceDTO>>> getServiceList(
            @ModelAttribute PaginationRequest paginationRequest,
            @RequestParam(required = false) String searchTerm,
            @RequestParam(required = false) ServiceCategory category) {

        ServiceSearchRequest searchRequest = ServiceSearchRequest.builder()
                .searchTerm(searchTerm)
                .category(category != null ? category.name() : null)
                .onlyActive(true) // Por defecto solo mostramos servicios activos
                .build();

        return ResponseEntity.ok(ApiResponse.success(
                serviceListService.getServiceList(searchRequest, paginationRequest)));
    }

    /**
     * Obtiene la lista de servicios agrupados por categoría
     */
    @GetMapping("/by-category")
    @PreAuthorize("hasPermission('', 'VER_SERVICIOS')")
    public ResponseEntity<ApiResponse<ServiceListResponse>> getServicesByCategory(
            @RequestParam(required = false) String searchTerm) {

        ServiceSearchRequest searchRequest = ServiceSearchRequest.builder()
                .searchTerm(searchTerm)
                .onlyActive(true)
                .build();

        return ResponseEntity.ok(ApiResponse.success(
                serviceListService.getServicesByCategory(searchRequest)));
    }

    /**
     * Obtiene todas las categorías de servicios disponibles
     */
    @GetMapping("/categories")
    @PreAuthorize("hasPermission('', 'VER_SERVICIOS')")
    public ResponseEntity<ApiResponse<ServiceCategory[]>> getServiceCategories() {
        return ResponseEntity.ok(ApiResponse.success(ServiceCategory.values()));
    }
}


Estructura: controller
Archivo: ServiceReportController.java
--------------------------------------------------
package com.example.demo.controller;

import com.example.demo.dto.ApiResponse;
import com.example.demo.dto.ServiceReportDTOs.*;
import com.example.demo.service.ServiceReportService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.format.annotation.DateTimeFormat;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.util.Date;

@RestController
@RequestMapping("/api/reports")
@Tag(name = "Service Reports", description = "Endpoints para la gestión de reportes de servicios")
public class ServiceReportController {

    @Autowired
    private ServiceReportService serviceReportService;

    /**
     * Obtiene el reporte de servicios para un período específico usando parámetros de consulta
     */
    @GetMapping("/services")
    @PreAuthorize("hasPermission(null, 'GENERAR_REPORTE_SERVICIOS')")
    @Operation(summary = "Obtener reporte de servicios por período",
            description = "Genera un reporte de servicios usando parámetros de consulta")
    public ResponseEntity<ApiResponse<ServiceReportResponse>> getServiceReport(
            @Parameter(description = "Fecha de inicio", required = true)
            @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) Date startDate,

            @Parameter(description = "Fecha de fin", required = true)
            @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) Date endDate,

            @Parameter(description = "Período (WEEKLY, MONTHLY, YEARLY)")
            @RequestParam(required = false) String period,

            @Parameter(description = "Categoría de servicio")
            @RequestParam(required = false) String category,

            @Parameter(description = "ID del servicio específico")
            @RequestParam(required = false) String serviceId) {

        ReportFilterRequest filter = ReportFilterRequest.builder()
                .startDate(startDate)
                .endDate(endDate)
                .period(period)
                .category(category)
                .serviceId(serviceId)
                .build();

        return ResponseEntity.ok(ApiResponse.success(
                serviceReportService.generateReport(filter)));
    }
}

Estructura: controller
Archivo: ServiceVeterinaryController.java
--------------------------------------------------
package com.example.demo.controller;

import com.example.demo.dto.ApiResponse;
import com.example.demo.dto.PaginatedResponse;
import com.example.demo.dto.PaginationRequest;
import com.example.demo.dto.ServiceVeterinaryDTOs.*;
import com.example.demo.model.ServiceCategory;
import com.example.demo.service.ServiceVeterinaryService;
import jakarta.validation.Valid;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/services")
public class ServiceVeterinaryController {

    @Autowired
    private ServiceVeterinaryService serviceVeterinaryService;

    @GetMapping
    @PreAuthorize("hasPermission('', 'VER_SERVICIOS')")
    public ResponseEntity<ApiResponse<PaginatedResponse<ServiceResponse>>> getAllServices(
            @ModelAttribute PaginationRequest paginationRequest,
            @RequestParam(required = false) ServiceCategory category) {

        // Si se proporciona una categoría, configurar el filtro
        if (category != null) {
            paginationRequest.setFilterBy("category");
            paginationRequest.setFilterValue(category.name());
        }

        return ResponseEntity.ok(ApiResponse.success(
                serviceVeterinaryService.getAllServices(paginationRequest)));
    }

    @PostMapping
    @PreAuthorize("hasPermission('', 'GESTIONAR_SERVICIOS')")
    public ResponseEntity<ApiResponse<ServiceResponse>> createService(
            @Valid @RequestBody CreateServiceRequest request) {
        return ResponseEntity.ok(ApiResponse.success(
                serviceVeterinaryService.createService(request)));
    }

    @PutMapping("/{id}")
    @PreAuthorize("hasPermission('', 'GESTIONAR_SERVICIOS')")
    public ResponseEntity<ApiResponse<ServiceResponse>> updateService(
            @PathVariable String id,
            @Valid @RequestBody UpdateServiceRequest request) {
        return ResponseEntity.ok(ApiResponse.success(
                serviceVeterinaryService.updateService(id, request)));
    }

    @DeleteMapping("/{id}")
    @PreAuthorize("hasPermission('', 'GESTIONAR_SERVICIOS')")
    public ResponseEntity<ApiResponse<Void>> deleteService(@PathVariable String id) {
        serviceVeterinaryService.deleteService(id);
        return ResponseEntity.ok(ApiResponse.success(null));
    }

    @PostMapping("/{id}/toggle")
    @PreAuthorize("hasPermission('', 'GESTIONAR_SERVICIOS')")
    public ResponseEntity<ApiResponse<ServiceResponse>> toggleServiceStatus(
            @PathVariable String id) {
        return ResponseEntity.ok(ApiResponse.success(
                serviceVeterinaryService.toggleServiceStatus(id)));
    }

    @GetMapping("/{id}/details")
    @PreAuthorize("hasPermission('', 'VER_SERVICIOS')")
    public ResponseEntity<ApiResponse<ServiceDetailResponse>> getServiceDetails(
            @PathVariable String id) {
        return ResponseEntity.ok(ApiResponse.success(
                serviceVeterinaryService.getServiceDetails(id)));
    }

    @GetMapping("/active")
    @PreAuthorize("hasPermission('', 'VER_SERVICIOS')")
    public ResponseEntity<ApiResponse<List<ServiceDetailResponse>>> getActiveServices() {
        return ResponseEntity.ok(ApiResponse.success(
                serviceVeterinaryService.getActiveServices()));
    }
}


Estructura: controller
Archivo: UserController.java
--------------------------------------------------
package com.example.demo.controller;

import com.example.demo.dto.*;
import com.example.demo.dto.UserDTOs.*;
import com.example.demo.exception.CustomExceptions;
import com.example.demo.service.UserService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.Map;

@Slf4j
@RestController
@RequestMapping("/api/users")
public class UserController {

    @Autowired
    private UserService userService;

    // En UserController.java
    // En UserController.java
    @PreAuthorize("hasPermission(null, 'VER_USUARIOS')")
    @GetMapping
    public ResponseEntity<ApiResponse<PaginatedResponse<UserResponse>>> getAllUsers(
            @ModelAttribute PaginationRequest paginationRequest,
            @RequestParam(required = false) Boolean isActive,
            @RequestParam(required = false) String role) {
        try {
            return ResponseEntity.ok(ApiResponse.success(
                    userService.getAllUsers(paginationRequest, isActive, role)));
        } catch (CustomExceptions.ProcessingException e) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                    .body(ApiResponse.error("PROCESSING_ERROR", e.getMessage()));
        }
    }
    @GetMapping("/veterinarians")
    @PreAuthorize("hasPermission('', 'VER_VETERINARIOS')")
    public ResponseEntity<ApiResponse<PaginatedResponse<UserResponse>>> getVeterinarians(
            @ModelAttribute PaginationRequest paginationRequest) {
        try {
            // Configurar valores por defecto si no se proporcionan
            if (paginationRequest.getSortBy() == null) {
                paginationRequest.setSortBy("nombre");
            }
            if (paginationRequest.getSortDirection() == null) {
                paginationRequest.setSortDirection("ASC");
            }
            if (paginationRequest.getSize() == 0) {
                paginationRequest.setSize(10);
            }

            // Obtener veterinarios paginados
            PaginatedResponse<UserResponse> veterinarians = userService.getVeterinarians(paginationRequest);
            return ResponseEntity.ok(ApiResponse.success(veterinarians));
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                    .body(ApiResponse.error("PROCESSING_ERROR", e.getMessage()));
        }
    }

    @GetMapping("/search")
    @PreAuthorize("hasPermission(null, 'VER_USUARIOS')")
    public ResponseEntity<ApiResponse<PaginatedResponse<UserResponse>>> searchUsers(
            @RequestParam String searchTerm,
            @ModelAttribute PaginationRequest paginationRequest) {
        try {
            return ResponseEntity.ok(ApiResponse.success(
                    userService.searchUsers(searchTerm, paginationRequest)));
        } catch (Exception e) {
            log.error("Error searching users:", e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                    .body(ApiResponse.error("PROCESSING_ERROR", e.getMessage()));
        }
    }



 /*
    @PreAuthorize("hasPermission(null, 'VER_USUARIOS')")
    @GetMapping
    public ResponseEntity<ApiResponse<List<UserResponse>>> getAllUsers(
            @RequestParam(required = false) Boolean isActive,
            @RequestParam(required = false) String role) {
        List<UserResponse> users = userService.getAllUsers(isActive, role);
        return ResponseEntity.ok(ApiResponse.success(users));
    }


  */

    @GetMapping("/{id}")
    @PreAuthorize("hasPermission('', 'VER_USUARIOS')")
    public ResponseEntity<ApiResponse<UserResponse>> getUserById(@PathVariable String id) {
        return ResponseEntity.ok(ApiResponse.success(userService.getUserById(id)));
    }

    @PostMapping
    //@PreAuthorize("hasPermission('', 'CREAR_USUARIO')")
    public ResponseEntity<ApiResponse<UserResponse>> createUser(@RequestBody AuthDTOs.RegisterRequest request) {
        return ResponseEntity.ok(ApiResponse.success(userService.createUser(request)));
    }

    @PostMapping("/create-with-roles")
    @PreAuthorize("hasPermission('', 'CREAR_USUARIO')")
    public ResponseEntity<ApiResponse<UserResponse>> createUserWithRoles(@RequestBody AuthDTOs.RegisterRequest request) {
        try {
            // Delegate user creation to UserService
            UserResponse newUser = userService.createUserWithRoles(request);
            return ResponseEntity.ok(ApiResponse.success(newUser));
        } catch (CustomExceptions.ProcessingException e) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                    .body(ApiResponse.error("PROCESSING_ERROR", e.getMessage()));
        }
    }

    @PutMapping("/{id}")
    @PreAuthorize("hasPermission('', 'EDITAR_USUARIO')")
    public ResponseEntity<ApiResponse<UserResponse>> updateUser(@PathVariable String id, @RequestBody UpdateUserRequest request) {
        return ResponseEntity.ok(ApiResponse.success(userService.updateUser(id, request)));
    }

    @DeleteMapping("/{id}")
    @PreAuthorize("hasPermission('', 'ELIMINAR_USUARIO')")
    public ResponseEntity<ApiResponse<Void>> deleteUser(@PathVariable String id) {
        userService.deleteUser(id);
        return ResponseEntity.ok(ApiResponse.success(null));
    }

    @PostMapping("/me/change-password")
    @PreAuthorize("hasPermission('', 'VER_PERFIL_PROPIO')")
    public ResponseEntity<ApiResponse<Void>> changePassword(@RequestBody ChangePasswordRequest request) {
        String userId = SecurityContextHolder.getContext().getAuthentication().getName();
        try {
            userService.changePassword(userId, request);
            return ResponseEntity.ok(ApiResponse.success(null));
        } catch (CustomExceptions.UnauthorizedException e) {
            return ResponseEntity.status(HttpStatus.UNAUTHORIZED)
                    .body(ApiResponse.error("UNAUTHORIZED", e.getMessage()));
        } catch (CustomExceptions.InvalidPasswordException e) {
            return ResponseEntity.badRequest()
                    .body(ApiResponse.error("INVALID_PASSWORD", e.getMessage()));
        } catch (CustomExceptions.ProcessingException e) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                    .body(ApiResponse.error("PROCESSING_ERROR", e.getMessage()));
        }
    }

    @PostMapping("/{id}/toggle-status")
    @PreAuthorize("hasPermission('', 'EDITAR_USUARIO')")
    public ResponseEntity<ApiResponse<UserResponse>> toggleUserStatus(@PathVariable String id, @RequestBody ToggleUserStatusRequest request) {
        return ResponseEntity.ok(ApiResponse.success(userService.toggleUserStatus(id, request)));
    }

    @PostMapping("/{id}/notes")
    @PreAuthorize("hasPermission('', 'EDITAR_USUARIO')")
    public ResponseEntity<ApiResponse<Void>> addNote(@PathVariable String id, @RequestBody AddNoteRequest request) {
        userService.addNote(id, request);
        return ResponseEntity.ok(ApiResponse.success(null));
    }

    @GetMapping("/{id}/notes")
    @PreAuthorize("hasPermission('', 'VER_USUARIOS')")
    public ResponseEntity<ApiResponse<List<Map<String, Object>>>> getUserNotes(@PathVariable String id) {
        return ResponseEntity.ok(ApiResponse.success(userService.getUserNotes(id)));
    }
    @GetMapping("/me")
    @PreAuthorize("hasPermission('', 'VER_PERFIL_PROPIO')")
    public ResponseEntity<ApiResponse<UserResponse>> getCurrentUserProfile() {
        return ResponseEntity.ok(ApiResponse.success(userService.getCurrentUserProfile()));
    }

    @PutMapping("/me")
    @PreAuthorize("hasPermission('', 'EDITAR_PERFIL_PROPIO')")
    public ResponseEntity<ApiResponse<UserResponse>> updateCurrentUserProfile(@RequestBody UpdateProfileRequest request) {
        return ResponseEntity.ok(ApiResponse.success(userService.updateCurrentUserProfile(request)));
    }
    @GetMapping("/me/pets")
    @PreAuthorize("hasPermission('', 'VER_PERFIL_PROPIO')")
    public ResponseEntity<ApiResponse<List<PetDTOs.PetResponse>>> getCurrentUserPets() {
        return ResponseEntity.ok(ApiResponse.success(userService.getCurrentUserPets()));
    }
    @GetMapping("/{id}/pets")
    @PreAuthorize("hasRole('VETERINARIO') or hasRole('RECEPCIONISTA') or @userService.isCurrentUser(#id)")
    public ResponseEntity<ApiResponse<List<PetDTOs.PetResponse>>> getUserPets(@PathVariable String id) {
        return ResponseEntity.ok(ApiResponse.success(userService.getUserPets(id)));
    }
}

Estructura: controller
Archivo: VeterinaryController.java
--------------------------------------------------
package com.example.demo.controller;

import com.example.demo.dto.*;
import com.example.demo.service.VeterinaryService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.format.annotation.DateTimeFormat;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.time.LocalDate;
import java.util.List;

@RestController
@RequestMapping("/api/veterinary")
public class VeterinaryController {

    @Autowired
    private VeterinaryService veterinaryService;

    @GetMapping("/search")
    @PreAuthorize("hasPermission('', 'BUSCAR_CLIENTE')")
    public ResponseEntity<ApiResponse<PaginatedResponse<UserDTOs.ClientWithPetsDTO>>> searchClients(
            @ModelAttribute PaginationRequest paginationRequest,
            @RequestParam(required = false) String clientName,
            @RequestParam(required = false) String petName,
            @RequestParam(required = false) @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate consultationDate) {

        UserDTOs.ClientSearchCriteria criteria = new UserDTOs.ClientSearchCriteria(clientName, petName, consultationDate);
        return ResponseEntity.ok(ApiResponse.success(
                veterinaryService.searchClients(criteria, paginationRequest)));
    }

    @GetMapping("/clients/{clientId}/pets")
    @PreAuthorize("hasPermission(null, 'BUSCAR_CLIENTE_MASCOTA')")
    public ResponseEntity<ApiResponse<UserDTOs.ClientWithPetsDTO>> getClientWithPets(@PathVariable String clientId) {
        return ResponseEntity.ok(ApiResponse.success(veterinaryService.getClientWithPets(clientId)));
    }

    @PostMapping("/pets/{petId}/medical-records")
    @PreAuthorize("hasPermission(null, 'AGREGAR_MEDICAL_RECORD')")
    public ResponseEntity<ApiResponse<PetDTOs.MedicalRecordResponse>> addMedicalRecord(
            @PathVariable String petId,
            @RequestBody PetDTOs.AddMedicalRecordRequest request) {
        return ResponseEntity.ok(ApiResponse.success(veterinaryService.addMedicalRecord(petId, request)));
    }

    @GetMapping("/pets/{petId}/medical-records")
    @PreAuthorize("hasPermission(null, 'OBTENER_MEDICAL_HISTORY')")
    public ResponseEntity<ApiResponse<PaginatedResponse<PetDTOs.MedicalRecordResponse>>> getMedicalHistory(
            @PathVariable String petId,
            @ModelAttribute PaginationRequest paginationRequest) {
        return ResponseEntity.ok(ApiResponse.success(
                veterinaryService.getMedicalHistory(petId, paginationRequest)));
    }
}

Estructura: dto
Archivo: ApiResponse.java
--------------------------------------------------
package com.example.demo.dto;

import lombok.Data;

@Data
public class ApiResponse<T> {
    private boolean success;
    private T data;
    private ErrorDetails error;

    @Data
    public static class ErrorDetails {
        private String code;
        private String message;
    }

    public static <T> ApiResponse<T> success(T data) {
        ApiResponse<T> response = new ApiResponse<>();
        response.setSuccess(true);
        response.setData(data);
        return response;
    }

    public static <T> ApiResponse<T> error(String code, String message) {
        ApiResponse<T> response = new ApiResponse<>();
        response.setSuccess(false);
        ErrorDetails errorDetails = new ErrorDetails();
        errorDetails.setCode(code);
        errorDetails.setMessage(message);
        response.setError(errorDetails);
        return response;
    }
}


Estructura: dto
Archivo: AppointmentDTOs.java
--------------------------------------------------
package com.example.demo.dto;

import jakarta.validation.constraints.NotNull;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import java.util.Date;
import java.util.List;

public class AppointmentDTOs {

    @Data
    @AllArgsConstructor
    @NoArgsConstructor
    public static class AppointmentResponse {
        private String id;
        private PetDTOs.PetResponse pet;
        private UserDTOs.UserResponse client;
        private UserDTOs.UserResponse veterinarian;
        private Date appointmentDate;
        private String reason;
        private String status;
        private String notes;
        private List<PetDTOs.MedicalRecordResponse> petHistory;
    }

    @Data
    public static class CreateAppointmentRequest {
        private String petId;
        private String clientId;
        private String veterinarianId;
        private Date appointmentDate;
        private String reason;
        private String notes;
    }

    @Data
    public static class UpdateAppointmentRequest {
        private Date appointmentDate;
        private String reason;
        private String status;
        private String notes;
    }

    @Data
    @AllArgsConstructor
    public static class AppointmentSummary {
        private List<AppointmentResponse> appointments;
        private int totalAppointments;
        private Date date;
    }
    @Data
    @AllArgsConstructor
    @NoArgsConstructor
    public static class AppointmentSummaryByPet {
        private PetDTOs.PetResponse pet;
        private List<AppointmentResponse> appointments;
        private int totalAppointments;
    }

    @Data
    public static class RescheduleRequest {
        @NotNull(message = "La nueva fecha es obligatoria")
        private Date newDate;
        private String reason;
    }
    @Data
    @Builder
    @AllArgsConstructor
    @NoArgsConstructor
    public static class ClientPetAppointmentDTO {
        private String id;
        private Date appointmentDate;
        private String reason;
        private String status;
        private String veterinarianName;
        private PetDTOs.PetResponse pet;
        private boolean canCancel;    // Para indicar si la cita puede ser cancelada
        private boolean canReschedule; // Para indicar si la cita puede ser reprogramada
    }

}

Estructura: dto
Archivo: AuthDTOs.java
--------------------------------------------------
package com.example.demo.dto;

import com.example.demo.model.Role;
import lombok.AllArgsConstructor;
import lombok.Data;
import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import lombok.NoArgsConstructor;

import java.util.List;

public class AuthDTOs {

    @Data
    public static class RegisterRequest {
        private String uid;
        @NotBlank(message = "El email es obligatorio")
        @Email(message = "El email debe ser válido")
        private String email;

        @NotBlank(message = "La contraseña es obligatoria")
        @Size(min = 6, message = "La contraseña debe tener al menos 6 caracteres")
        private String password;

        @NotBlank(message = "El nombre es obligatorio")
        private String nombre;

        @NotBlank(message = "El apellido es obligatorio")
        private String apellido;

        @NotBlank(message = "telefono es obligatorio")
        private String telefono;
        @NotBlank(message = "direccion es obligatoria")
        private String direccion;
        private List<Role> roles;
    }

    @Data
    public static class LoginRequest {
        @NotBlank(message = "El email es obligatorio")
        @Email(message = "El email debe ser válido")
        private String email;

        @NotBlank(message = "La contraseña es obligatoria")
        private String password;
    }

    @Data
    @AllArgsConstructor
    @NoArgsConstructor
    public static class AuthResponse {
        private String token;
        private UserDTOs.UserResponse user;
    }
}

Estructura: dto
Archivo: FavoriteDTOs.java
--------------------------------------------------
package com.example.demo.dto;

import lombok.*;
import java.util.Date;

public class FavoriteDTOs {
    @Data
    @Builder
    @NoArgsConstructor
    @AllArgsConstructor
    public static class FavoriteResponse {
        private String id;
        private String itemId;
        private String itemType;
        private String itemName;  // Nombre del servicio o producto
        private double price;
        private Date createdAt;
        private Integer quantity;    // null para servicios
        private Integer minThreshold; // null para servicios
        private String status;
    }

    @Data
    @Builder
    @NoArgsConstructor
    @AllArgsConstructor
    public static class ToggleFavoriteRequest {
        private String itemId;
        private String itemType;
    }
}


Estructura: dto
Archivo: HistorialClinicoDTOs.java
--------------------------------------------------
package com.example.demo.dto;

import jakarta.validation.constraints.NotBlank;
import lombok.*;
import java.util.Date;
import java.util.List;

public class HistorialClinicoDTOs {

    @Data
    @Builder
    public static class CreateHistorialRequest {
        @NotBlank(message = "El motivo de consulta es obligatorio")
        private String motivoConsulta;

        @NotBlank(message = "El diagnóstico es obligatorio")
        private String diagnostico;

        @NotBlank(message = "El tratamiento es obligatorio")
        private String tratamiento;

        private String observaciones;

        private List<ServicioRealizadoRequest> serviciosRealizados;
        private List<ServicioAdicionalRequest> serviciosAdicionales;
    }
    @Data
    @Builder
    public static class ServicioRealizadoRequest {
        private String serviceId;
        private Double precioPersonalizado;
        private String notas;
    }

    @Data
    @Builder
    public static class ServicioAdicionalRequest {
        private String descripcion;
        private double precio;
        private String notas;
    }


    @Data
    @Builder
    public static class UpdateHistorialRequest {
        @NotBlank(message = "El motivo de consulta es obligatorio")
        private String motivoConsulta;

        @NotBlank(message = "El diagnóstico es obligatorio")
        private String diagnostico;

        @NotBlank(message = "El tratamiento es obligatorio")
        private String tratamiento;

        private String observaciones;
        // Nuevos campos
        private List<ServicioRealizadoRequest> serviciosRealizados;
        private List<ServicioAdicionalRequest> serviciosAdicionales;
    }

    @Data
    @Builder
    @NoArgsConstructor
    @AllArgsConstructor
    public static class HistorialClinicoResponse {
        private String id;
        private String petId;
        private String veterinarianId;
        private String veterinarianName;  // Nombre completo del veterinario
        private String petName;           // Nombre de la mascota
        private String ownerName;         // Nombre del dueño
        private Date fechaVisita;
        private String motivoConsulta;
        private String diagnostico;
        private String tratamiento;
        private String observaciones;
        private Date fechaCreacion;
        private Date fechaActualizacion;
        private String estado;

        // Nuevos campos
        private List<ServicioRealizadoResponse> serviciosRealizados;
        private List<ServicioAdicionalResponse> serviciosAdicionales;
        private double precioTotal;
    }
    @Data
    @Builder
    public static class ServicioRealizadoResponse {
        private String serviceId;
        private String serviceName;
        private double precioBase;
        private Double precioPersonalizado;
        private String notas;
    }

    @Data
    @Builder
    public static class ServicioAdicionalResponse {
        private String descripcion;
        private double precio;
        private String notas;
    }
}


Estructura: dto
Archivo: InventoryDTOs.java
--------------------------------------------------
package com.example.demo.dto;

import com.example.demo.model.AlertStatus;
import jakarta.validation.constraints.Min;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.Date;
import java.util.List;

public class InventoryDTOs {

    @Data
    public static class AddInventoryItemRequest {
        private String name;
        private int quantity;
        private int minThreshold;
        @Min(value = 0, message = "El precio no puede ser negativo")
        private double price; // Nuevo campo
    }

    @Data
    public static class UpdateInventoryItemRequest {
        private int quantity;
        private int minThreshold;
        @Min(value = 0, message = "El precio no puede ser negativo")
        private double price; // Nuevo campo
    }

    @Data
    @Builder
    @AllArgsConstructor
    @NoArgsConstructor
    public static class InventoryItemResponse {
        private String id;
        private String name;
        private int quantity;
        private int minThreshold;
        private double price; // Nuevo campo
        private int recommendedOrderQuantity;
        private Date dateAdded;
        private Date lastUpdated;
        private String status;
        private boolean needsReorder;
        private boolean isFavorite;
    }
    @Data
    @Builder
    public static class LowStockAlertDTO {
        private String id;
        private String productId;
        private String productName;
        private int currentStock;
        private int minThreshold;
        private boolean isAcknowledged;
        private Date createdAt;
        private AlertStatus status; // CRITICAL, WARNING
    }

    @Data
    @Builder
    public static class RestockOrderDTO {
        private String id;
        private String productId;
        private String productName;
        private int currentStock;
        private int quantityToOrder;
        private OrderStatus status;
        private Date orderDate;
        private String requestedBy;
        private String notes;
    }

    @Data
    public static class UpdateThresholdRequest {
        @Min(value = 0, message = "El umbral mínimo no puede ser negativo")
        private int minThreshold;
        @Min(value = 0, message = "La cantidad recomendada de pedido no puede ser negativa")
        private Integer recommendedOrderQuantity;
    }
    public static enum OrderStatus {
        PENDING, APPROVED, COMPLETED, CANCELLED
    }
    @Data
    public static class CreateRestockOrderRequest {

        private String productId;
        @Min(1)
        private int quantity;
        private String notes;
    }



}

Estructura: dto
Archivo: PaginatedResponse.java
--------------------------------------------------
package com.example.demo.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.List;

@Data
@AllArgsConstructor
@NoArgsConstructor
public class PaginatedResponse<T> {
    private List<T> content;
    private int pageNumber;
    private int pageSize;
    private long totalElements;
    private int totalPages;
    private boolean last;

    public PaginatedResponse(List<T> content, int pageNumber, int pageSize, long totalElements, int totalPages) {
        this.content = content;
        this.pageNumber = pageNumber;
        this.pageSize = pageSize;
        this.totalElements = totalElements;
        this.totalPages = totalPages;
        this.last = pageNumber >= totalPages - 1;
    }
    public static <T> PaginatedResponse<T> of(List<T> content, PaginationRequest request, long totalElements) {
        int totalPages = request.getSize() > 0 ?
                (int) Math.ceil((double) totalElements / request.getSize()) : 0;

        return new PaginatedResponse<>(
                content,
                request.getPage(),
                request.getSize(),
                totalElements,
                totalPages
        );
    }

    // Getters y setters
    public List<T> getContent() {
        return content;
    }

    public void setContent(List<T> content) {
        this.content = content;
    }

    public int getPageNumber() {
        return pageNumber;
    }

    public void setPageNumber(int pageNumber) {
        this.pageNumber = pageNumber;
    }

    public int getPageSize() {
        return pageSize;
    }

    public void setPageSize(int pageSize) {
        this.pageSize = pageSize;
    }

    public long getTotalElements() {
        return totalElements;
    }

    public void setTotalElements(long totalElements) {
        this.totalElements = totalElements;
    }

    public int getTotalPages() {
        return totalPages;
    }

    public void setTotalPages(int totalPages) {
        this.totalPages = totalPages;
    }

    public boolean isLast() {
        return last;
    }

    public void setLast(boolean last) {
        this.last = last;
    }
}

Estructura: dto
Archivo: PaginationRequest.java
--------------------------------------------------
package com.example.demo.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data

public class PaginationRequest {
    private int page;
    private int size;
    private String sortBy;
    private String sortDirection;
    private String filterBy;
    private String filterValue;

    public PaginationRequest() {
        // Constructor por defecto
    }

    // Constructor completo
    public PaginationRequest(int page, int size, String sortBy, String sortDirection) {
        this.page = page;
        this.size = size;
        this.sortBy = sortBy;
        this.sortDirection = sortDirection;
    }

    // Getters y Setters
    public int getPage() {
        return page;
    }

    public void setPage(int page) {
        this.page = page;
    }

    public int getSize() {
        return size;
    }

    public void setSize(int size) {
        this.size = size;
    }

    public String getSortBy() {
        return sortBy;
    }

    public void setSortBy(String sortBy) {
        this.sortBy = sortBy;
    }

    public String getSortDirection() {
        return sortDirection;
    }

    public void setSortDirection(String sortDirection) {
        this.sortDirection = sortDirection;
    }

    public String getFilterBy() {
        return filterBy;
    }

    public void setFilterBy(String filterBy) {
        this.filterBy = filterBy;
    }

    public String getFilterValue() {
        return filterValue;
    }

    public void setFilterValue(String filterValue) {
        this.filterValue = filterValue;
    }
}


Estructura: dto
Archivo: PaymentHistoryDTOs.java
--------------------------------------------------
package com.example.demo.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import java.util.Date;
import java.util.List;

public class PaymentHistoryDTOs {

    /**
     * DTO para la respuesta del historial de pagos
     */
    @Data
    @Builder
    @NoArgsConstructor
    @AllArgsConstructor
    public static class PaymentHistoryResponse {
        private String id;
        private Date fecha;
        private String petId;
        private String petName;
        private double montoTotal;
        private List<ServicioDetalleDTO> serviciosRealizados;
        private List<ServicioAdicionalDTO> serviciosAdicionales;
        private String veterinarioNombre;
        private String razon;  // motivo de consulta
    }

    /**
     * DTO para mostrar detalles de servicios regulares
     */
    @Data
    @Builder
    @NoArgsConstructor
    @AllArgsConstructor
    public static class ServicioDetalleDTO {
        private String servicioId;
        private String nombre;
        private double precioBase;
        private Double precioPersonalizado;  // Puede ser null si se usa el precio base
        private String notas;
    }

    /**
     * DTO para mostrar detalles de servicios adicionales
     */
    @Data
    @Builder
    @NoArgsConstructor
    @AllArgsConstructor
    public static class ServicioAdicionalDTO {
        private String descripcion;
        private double precio;
        private String notas;
    }

    /**
     * DTO para filtrar el historial de pagos
     */
    @Data
    @Builder
    @NoArgsConstructor
    @AllArgsConstructor
    public static class PaymentHistoryFilterRequest {
        private Date fechaInicio;
        private Date fechaFin;
        private String petId;  // opcional, para filtrar por mascota
        private Double montoMinimo;
        private Double montoMaximo;
    }
}

Estructura: dto
Archivo: PetDTOs.java
--------------------------------------------------
package com.example.demo.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.Date;
import java.util.List;

public class PetDTOs {

    @Data
    public static class CreatePetRequest {
        private String name;
        private String species;
        private String breed;
        private int age;
    }

    @Data
    public static class UpdatePetRequest {
        private String name;
        private String species;
        private String breed;
        private int age;
    }

    @Data
    @AllArgsConstructor
    @NoArgsConstructor
    public static class PetResponse {
        private String id;
        private String name;
        private String species;
        private String breed;
        private int age;
        private String ownerId;
    }

    @Data
    public static class AddMedicalRecordRequest {
        private String diagnosis;
        private String treatment;
        private String notes;
    }

    @Data
    public static class MedicalRecordResponse {
        private String id;
        private Date date;
        private String diagnosis;
        private String treatment;
        private String notes;
        private String veterinarianId;
        private String veterinarianName;
    }
    @Data
    @AllArgsConstructor
    @NoArgsConstructor
    public static class PetWithHistoryDTO {
        private String id;
        private String name;
        private String species;
        private String breed;
        private int age;
        private List<MedicalRecordResponse> medicalHistory;
    }
}

Estructura: dto
Archivo: ReminderDTO.java
--------------------------------------------------
package com.example.demo.dto;

import lombok.*;

@Data
@Builder
public class ReminderDTO {
    private int reminderHoursBefore;
    private String emailTemplate;
    private boolean isEnabled;
}

Estructura: dto
Archivo: RoleDTOs.java
--------------------------------------------------
package com.example.demo.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.List;


public class RoleDTOs {
    @Data
    @AllArgsConstructor
    @NoArgsConstructor
    public static class RoleDTO {
        private String id;
        private String name;
        private List<String> permissions;

        // Constructor, getters, and setters
    }

    @Data
    public static class CreateRoleRequest {
        private String name;
        private List<String> permissions;
    }

    @Data
    public static class UpdateRoleRequest {
        private String name;
        private List<String> permissions;
    }

    @Data
    public static class RoleResponse {
        private String id;
        private String name;
        private List<String> permissions;

        public RoleResponse(RoleDTO roleDTO) {
            this.id = roleDTO.getId();
            this.name = roleDTO.getName();
            this.permissions = roleDTO.getPermissions();
        }
    }

}


Estructura: dto
Archivo: ServiceDTO.java
--------------------------------------------------
package com.example.demo.dto;

import com.example.demo.model.ServiceCategory;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import lombok.*;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class ServiceDTO {
    private String id;
    @NotBlank(message = "El nombre del servicio es obligatorio")
    private String name;
    @NotNull(message = "La categoría del servicio es obligatoria")
    private ServiceCategory category;
    private String description;
    private double price;
    private boolean isActive;

}

Estructura: dto
Archivo: ServiceListResponse.java
--------------------------------------------------
package com.example.demo.dto;

import lombok.*;
import java.util.List;
import java.util.Map;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class ServiceListResponse {
    private Map<String, List<ServiceDTO>> servicesByCategory;
    private long totalServices;
}


Estructura: dto
Archivo: ServiceReportDTOs.java
--------------------------------------------------
package com.example.demo.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import java.util.Date;
import java.util.Map;
import java.util.List;

public class ServiceReportDTOs {

    /**
     * DTO para las métricas de uso de un servicio específico
     */
    @Data
    @Builder
    @NoArgsConstructor
    @AllArgsConstructor
    public static class ServiceMetricsDTO {
        private String serviceId;
        private String serviceName;
        private long totalUsage;               // Número total de veces utilizado
        private double totalRevenue;           // Ingresos totales generados
        private double averageRevenue;         // Ingreso promedio por uso
        private List<MonthlyMetric> monthlyMetrics;  // Métricas mensuales
        private List<String> topPets;          // Mascotas que más utilizan el servicio
    }

    /**
     * DTO para las métricas mensuales
     */
    @Data
    @Builder
    @NoArgsConstructor
    @AllArgsConstructor
    public static class MonthlyMetric {
        private int year;
        private int month;
        private long usage;           // Uso en ese mes
        private double revenue;       // Ingresos en ese mes
    }

    /**
     * DTO para el reporte general de servicios
     */
    @Data
    @Builder
    @NoArgsConstructor
    @AllArgsConstructor
    public static class ServiceReportResponse {
        private Date startDate;
        private Date endDate;
        private double totalRevenue;
        private long totalServicesUsed;
        private List<ServiceMetricsDTO> servicesMetrics;
        private Map<String, Double> revenueByCategory;    // Ingresos por categoría
        private Map<String, Long> usageByCategory;        // Uso por categoría
    }

    /**
     * DTO para los filtros del reporte
     */
    @Data
    @Builder
    @NoArgsConstructor
    @AllArgsConstructor
    public static class ReportFilterRequest {
        private Date startDate;
        private Date endDate;
        private String period;        // "WEEKLY", "MONTHLY", "YEARLY"
        private String category;      // Opcional: filtrar por categoría
        private String serviceId;     // Opcional: filtrar por servicio específico
    }
}

Estructura: dto
Archivo: ServiceSearchRequest.java
--------------------------------------------------
package com.example.demo.dto;

import lombok.*;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class ServiceSearchRequest {
    private String searchTerm;
    private String category;
    private Boolean onlyActive;
}

Estructura: dto
Archivo: ServiceVeterinaryDTOs.java
--------------------------------------------------
package com.example.demo.dto;

import com.example.demo.model.ServiceCategory;
import jakarta.validation.constraints.*;
import lombok.*;

import java.util.Date;
import java.util.List;

public class ServiceVeterinaryDTOs {

    @Data
    @Builder
    public static class CreateServiceRequest {
        @NotBlank(message = "El nombre del servicio es obligatorio")
        private String name;

        @NotBlank(message = "La descripción del servicio es obligatoria")
        @Size(min = 10, message = "La descripción debe tener al menos 10 caracteres")
        private String description;

        @NotNull(message = "El precio es obligatorio")
        @Min(value = 0, message = "El precio no puede ser negativo")
        private Double price;

        @NotNull(message = "La duración es obligatoria")
        @Min(value = 1, message = "La duración debe ser de al menos 1 minuto")
        private Integer durationMinutes;

        private List<String> requirements;
        private List<String> recommendations;
        private List<String> warnings;
        private ServiceCategory category;
    }

    @Data
    @Builder
    public static class UpdateServiceRequest {
        @NotBlank(message = "El nombre del servicio es obligatorio")
        private String name;

        @NotBlank(message = "La descripción del servicio es obligatoria")
        @Size(min = 10, message = "La descripción debe tener al menos 10 caracteres")
        private String description;

        @NotNull(message = "El precio es obligatorio")
        @Min(value = 0, message = "El precio no puede ser negativo")
        private Double price;

        @NotNull(message = "La duración es obligatoria")
        @Min(value = 1, message = "La duración debe ser de al menos 1 minuto")
        private Integer durationMinutes;

        private List<String> requirements;
        private List<String> recommendations;
        private List<String> warnings;
        private ServiceCategory category;

    }

    @Data
    @Builder
    @NoArgsConstructor
    @AllArgsConstructor
    public static class ServiceResponse {
        private String id;
        private String name;
        private String description;
        private double price;
        private int durationMinutes;
        private boolean isActive;
        private Date createdAt;
        private Date updatedAt;
        private ServiceCategory category;
    }
    @Data
    @Builder
    @NoArgsConstructor
    @AllArgsConstructor
    public static class ServiceDetailResponse {
        private String id;
        private String name;
        private String description;
        private double price;
        private int durationMinutes;
        private List<String> requirements;  // Lista de requisitos (ej: "ayuno previo")
        private List<String> recommendations; // Recomendaciones para el servicio
        private List<String> warnings;
        private ServiceCategory category;
        private boolean isActive;
        private Date createdAt;
        private Date updatedAt;
    }
    @Data
    @Builder
    public static class ServiceDetailRequest {
        @NotBlank(message = "El nombre del servicio es obligatorio")
        private String name;

        @NotBlank(message = "La descripción del servicio es obligatoria")
        @Size(min = 10, message = "La descripción debe tener al menos 10 caracteres")
        private String description;

        @NotNull(message = "El precio es obligatorio")
        @Min(value = 0, message = "El precio no puede ser negativo")
        private Double price;

        @NotNull(message = "La duración es obligatoria")
        @Min(value = 1, message = "La duración debe ser de al menos 1 minuto")
        private Integer durationMinutes;

        private List<String> requirements;
        private List<String> recommendations;
        private List<String> warnings;
        private ServiceCategory category;
    }
}

Estructura: dto
Archivo: UserDTOs.java
--------------------------------------------------
package com.example.demo.dto;

import com.example.demo.model.Role;
import lombok.AllArgsConstructor;
import lombok.Data;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import lombok.NoArgsConstructor;

import java.time.LocalDate;
import java.util.List;

public class UserDTOs {

    @Data
    public static class UserResponse {
        private String uid;
        private String email;
        private String nombre;
        private String apellido;
        private String telefono;
        private String direccion;
        private List<Role> roles;
        private boolean isEnabled;
        private boolean active;
    }

    @Data
    public static class UpdateUserRequest {

        private String email;
        private String nombre;
        private String apellido;
        private String telefono;
        private String direccion;
        private List<Role> roles;
        private boolean isEnabled;
        private boolean active;
    }

    @Data
    public static class ChangePasswordRequest {
        @NotBlank(message = "La contraseña actual es obligatoria")
        private String currentPassword;

        @NotBlank(message = "La nueva contraseña es obligatoria")
        @Size(min = 6, message = "La nueva contraseña debe tener al menos 6 caracteres")
        private String newPassword;
    }

    @Data
    public static class ToggleUserStatusRequest {
        private boolean isActive;
    }

    @Data
    public static class AddNoteRequest {
        @NotBlank(message = "El contenido de la nota es obligatorio")
        private String content;
    }

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    public static class RolePermissionDTO {
        private String role;
        private List<String> permissions;
    }

    @Data
    public static class UpdateProfileRequest {
        private String nombre;
        private String apellido;
        private String telefono;
        private String direccion;
    }
    @Data
    @AllArgsConstructor
    public static class ClientSearchCriteria {
        private String clientName;
        private String petName;
        private LocalDate consultationDate;
    }
    @Data
    public static class ClientWithPetsDTO {
        private String uid;
        private String nombre;
        private String apellido;
        private String email;
        private String telefono;
        private String direccion;
        private List<PetDTOs.PetWithHistoryDTO> mascotas;
    }



}

Estructura: exception
Archivo: CustomExceptions.java
--------------------------------------------------
package com.example.demo.exception;

public class CustomExceptions {
    public static class UserNotFoundException extends RuntimeException {
        public UserNotFoundException(String message) {
            super(message);
        }
    }

    // Nueva excepción para manejar problemas en Firebase
    public static class ProcessingException extends RuntimeException {
        public ProcessingException(String message) {
            super(message);
        }
    }


    public static class EmailAlreadyExistsException extends RuntimeException {
        public EmailAlreadyExistsException(String message) {
            super(message);
        }
    }

    public static class UnauthorizedException extends RuntimeException {
        public UnauthorizedException(String message) {
            super(message);
        }
    }

    public static class InvalidCredentialsException extends RuntimeException {
        public InvalidCredentialsException(String message) {
            super(message);
        }
    }
    public static class AuthenticationException extends RuntimeException {
        public AuthenticationException(String message) {
            super(message);
        }
    }
    public static class NotFoundException extends RuntimeException {
        public NotFoundException(String message) {
            super(message);
        }
    }
    public static class InvalidPasswordException extends InvalidCredentialsException{
        public InvalidPasswordException(String message){
            super(message);
        }
    }


}

Estructura: exception
Archivo: GlobalExceptionHandler.java
--------------------------------------------------
package com.example.demo.exception;

import com.example.demo.dto.ApiResponse;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;

@ControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(CustomExceptions.AuthenticationException.class)
    public ResponseEntity<ApiResponse<Void>> handleAuthenticationException(CustomExceptions.AuthenticationException ex) {
        return ResponseEntity
                .status(HttpStatus.UNAUTHORIZED)
                .body(ApiResponse.error("AUTH_ERROR", ex.getMessage()));
    }

    @ExceptionHandler(CustomExceptions.ProcessingException.class)
    public ResponseEntity<ApiResponse<Void>> handleProcessingException(CustomExceptions.ProcessingException ex) {
        return ResponseEntity
                .status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body(ApiResponse.error("PROCESSING_ERROR", ex.getMessage()));
    }

    @ExceptionHandler(CustomExceptions.UserNotFoundException.class)
    public ResponseEntity<ApiResponse<Void>> handleUserNotFoundException(CustomExceptions.UserNotFoundException ex) {
        return ResponseEntity
                .status(HttpStatus.NOT_FOUND)
                .body(ApiResponse.error("USER_NOT_FOUND", ex.getMessage()));
    }

    @ExceptionHandler(Exception.class)
    public ResponseEntity<ApiResponse<Void>> handleGeneralException(Exception ex) {
        return ResponseEntity
                .status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body(ApiResponse.error("INTERNAL_SERVER_ERROR", "An unexpected error occurred: " + ex.getMessage()));
    }
    @ExceptionHandler(CustomExceptions.EmailAlreadyExistsException.class)
    public ResponseEntity<ApiResponse<Void>> handleEmailAlreadyExistsException(CustomExceptions.EmailAlreadyExistsException ex) {
        return ResponseEntity
                .status(HttpStatus.CONFLICT)
                .body(ApiResponse.error("EMAIL_EXISTS", ex.getMessage()));
    }
}

Estructura: model
Archivo: AlertStatus.java
--------------------------------------------------
package com.example.demo.model;

public enum AlertStatus {
    CRITICAL,
    WARNING,
    OK
}


Estructura: model
Archivo: Appointment.java
--------------------------------------------------
package com.example.demo.model;

import lombok.*;
import java.util.Date;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class Appointment {
    private String id;
    private String petId;
    private String clientId;
    private String veterinarianId;
    private Date appointmentDate;
    private String reason;
    private String status; // SCHEDULED, COMPLETED, CANCELLED
    private String notes;
    private Date createdAt;
    private Date updatedAt;
}

Estructura: model
Archivo: AppointmentReminderConfig.java
--------------------------------------------------
package com.example.demo.model;

import lombok.Data;
import lombok.Builder;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class AppointmentReminderConfig {
    private String id;
    private int reminderHoursBefore;  // Horas antes de la cita para enviar recordatorio
    private boolean isEnabled;
    private String emailTemplate;
    private String confirmationLink;
}

Estructura: model
Archivo: AppointmentStatus.java
--------------------------------------------------
package com.example.demo.model;

public enum AppointmentStatus {
    SCHEDULED,
    CONFIRMED,
    CANCELLED,
    COMPLETED,
    NO_SHOW
}

Estructura: model
Archivo: Favorite.java
--------------------------------------------------
package com.example.demo.model;


import lombok.*;
import java.util.Date;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class Favorite {
    private String id;
    private String userId;      // ID del veterinario
    private String itemId;      // ID del servicio o producto
    private String itemType;    // "SERVICE" o "PRODUCT"
    private Date createdAt;
    private Date updatedAt;
}

Estructura: model
Archivo: HistorialClinico.java
--------------------------------------------------
package com.example.demo.model;

import lombok.*;

import java.util.ArrayList;
import java.util.Date;
import java.util.List;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class HistorialClinico {
    private String id;
    private String petId;
    private String veterinarianId;
    private Date fechaVisita;
    private String motivoConsulta;
    private String diagnostico;
    private String tratamiento;
    private String observaciones;
    private Date fechaCreacion;
    private Date fechaActualizacion;
    private String estado;

    // Nuevos campos
    @Builder.Default
    private List<ServicioRealizado> serviciosRealizados = new ArrayList<>();
    @Builder.Default
    private List<ServicioAdicional> serviciosAdicionales = new ArrayList<>();
    private double precioTotal;
}



Estructura: model
Archivo: InventoryItem.java
--------------------------------------------------
package com.example.demo.model;

import lombok.Data;

import java.util.Date;

@Data
public class InventoryItem {
    private String id;
    private String name;
    private int quantity;
    private int minThreshold;
    private int recommendedOrderQuantity;
    private Date dateAdded;
    private Date lastUpdated;
    private double price;
}

Estructura: model
Archivo: ItemType.java
--------------------------------------------------
package com.example.demo.model;

public enum ItemType {
    INVENTORY,           // Para items de la colección "inventory"
    VETERINARY_SERVICE   // Para items de la colección "veterinary_services"
}


Estructura: model
Archivo: LowStockAlert.java
--------------------------------------------------
package com.example.demo.model;

import lombok.*;

import java.util.Date;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class LowStockAlert {
    private String id;
    private String productId;
    private String productName;
    private int currentStock;
    private int minThreshold;
    private AlertStatus status;
    private boolean isAcknowledged;
    private Date createdAt;
    private String acknowledgedBy;
    private Date acknowledgedAt;
}

Estructura: model
Archivo: MedicalRecord.java
--------------------------------------------------
package com.example.demo.model;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.ArrayList;
import java.util.Date;
import java.util.List;

@Builder
@Data
@NoArgsConstructor
@AllArgsConstructor
public class MedicalRecord {
    private String id;
    private Date date;
    private String diagnosis;
    private String treatment;
    private String notes;
    private String veterinarianId;

    @Builder.Default
    private List<String> attachments = new ArrayList<>();
}

Estructura: model
Archivo: Pet.java
--------------------------------------------------
package com.example.demo.model;

import lombok.*;

@Data
@NoArgsConstructor
@AllArgsConstructor

public class Pet {
    private String id;
    private String name;
    private String species;
    private String breed;
    private int age;
    private String ownerId;
}

Estructura: model
Archivo: ReorderRequest.java
--------------------------------------------------
package com.example.demo.model;

import lombok.*;

import java.util.Date;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class ReorderRequest {
    private String id;
    private String productId;
    private int quantity;
    private RequestStatus status;
    private Date requestDate;
    private String requestedBy;
    private String notes;
    private Date completedDate;
    private String completedBy;
}

Estructura: model
Archivo: RequestStatus.java
--------------------------------------------------
package com.example.demo.model;

public enum RequestStatus {
    PENDING,
    APPROVED,
    COMPLETED,
    CANCELLED
}


Estructura: model
Archivo: RestockOrder.java
--------------------------------------------------
package com.example.demo.model;

import com.example.demo.dto.InventoryDTOs;
import lombok.*;

import java.util.Date;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class RestockOrder {
    private String id;
    private String productId;
    private String productName;
    private int currentStock;
    private int quantityToOrder;
    private InventoryDTOs.OrderStatus status;
    private Date orderDate;
    private String requestedBy;
    private String notes;
    private Date completedDate;
    private String completedBy;
}

Estructura: model
Archivo: Role.java
--------------------------------------------------
package com.example.demo.model;


import lombok.Getter;

@Getter
public enum Role {
    VETERINARIO,
    CLIENTE,
    RECEPCIONISTA,
    ADMINISTRADOR
}


Estructura: model
Archivo: ServiceCategory.java
--------------------------------------------------
package com.example.demo.model;

public enum ServiceCategory {
    CONSULTA_GENERAL,
    VACUNACION,
    CIRUGIA,
    EMERGENCIA,
    ESTETICA,
    LABORATORIO,
    OTROS
}


Estructura: model
Archivo: ServiceVeterinary.java
--------------------------------------------------
package com.example.demo.model;

import lombok.*;
import java.util.Date;
import java.util.List;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class ServiceVeterinary {
    private String id;
    private String name;
    private String description;
    private double price;
    private int durationMinutes;
    private List<String> requirements;
    private List<String> recommendations;
    private List<String> warnings;
    private boolean isActive;
    private Date createdAt;
    private Date updatedAt;
    private ServiceCategory category;
}

Estructura: model
Archivo: ServicioAdicional.java
--------------------------------------------------
package com.example.demo.model;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class ServicioAdicional {
    private String descripcion;
    private double precio;
    private String notas;
}


Estructura: model
Archivo: ServicioRealizado.java
--------------------------------------------------
package com.example.demo.model;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class ServicioRealizado {
    private String serviceId;
    private String serviceName;
    private double precioBase;
    private Double precioPersonalizado; // null si se usa el precio base
    private String notas;
}


Estructura: model
Archivo: StockAlert.java
--------------------------------------------------
package com.example.demo.model;

import lombok.*;

import java.util.Date;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class StockAlert {
    private String id;
    private String productId;
    private String productName;
    private int currentStock;
    private int minThreshold;
    private AlertStatus status;
    private Date createdAt;
    private Date acknowledgedAt;
    private String acknowledgedBy;
    private boolean isActive;
}

Estructura: model
Archivo: User.java
--------------------------------------------------
package com.example.demo.model;

import lombok.*;

import java.util.List;
import java.util.Map;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
@Getter
public class User {
    private String uid; // Firebase UID
    private String email;
    private String nombre;
    private String apellido;
    private String telefono;
    private String direccion;
    private List<Role> roles;
    private boolean isEnabled;
    private boolean active;

    // Constructor para crear un User a partir de un Map (útil cuando se recupera datos de Firebase)
    public User(Map<String, Object> data) {
        this.uid = (String) data.get("uid");
        this.email = (String) data.get("email");
        this.nombre = (String) data.get("nombre");
        this.apellido = (String) data.get("apellido");
        this.telefono = (String) data.get("telefono");
        this.direccion = (String) data.get("direccion");
        this.roles = (List<Role>) data.get("roles");
        this.isEnabled = (Boolean) data.get("isEnabled");
    }

    // Método para convertir el User a un Map (útil cuando se guarda en Firebase)
    public Map<String, Object> toMap() {
        return Map.of(
                "uid", uid,
                "email", email,
                "nombre", nombre,
                "apellido", apellido,
                "telefono", telefono,
                "direccion", direccion,
                "roles", roles,
                "isEnabled", isEnabled
        );
    }
}

Estructura: repository
Archivo: PetRepository.java
--------------------------------------------------
package com.example.demo.repository;

import com.example.demo.model.Pet;
import com.example.demo.exception.CustomExceptions;
import com.google.api.core.ApiFuture;
import com.google.cloud.firestore.Firestore;
import com.google.cloud.firestore.QueryDocumentSnapshot;
import com.google.cloud.firestore.QuerySnapshot;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.concurrent.ExecutionException;
import java.util.stream.Collectors;

@Repository
public class PetRepository {

    private final Firestore firestore;

    @Autowired
    public PetRepository(Firestore firestore) {
        this.firestore = firestore;
    }

    // Método para obtener todas las mascotas
    public List<Pet> findAll() {
        try {
            ApiFuture<QuerySnapshot> future = firestore.collection("pets").get(); // Obtener todas las mascotas
            List<QueryDocumentSnapshot> documents = future.get().getDocuments();

            return documents.stream()
                    .map(doc -> doc.toObject(Pet.class)) // Convertir documentos Firestore a objetos Pet
                    .collect(Collectors.toList());

        } catch (InterruptedException | ExecutionException e) {
            throw new CustomExceptions.ProcessingException("Error al obtener las mascotas desde Firebase: " + e.getMessage());
        }
    }
}


Estructura: repository
Archivo: UserRepository.java
--------------------------------------------------
package com.example.demo.repository;

import com.example.demo.exception.CustomExceptions;
import com.google.api.core.ApiFuture;
import com.google.cloud.firestore.Firestore;
import com.google.cloud.firestore.QueryDocumentSnapshot;
import com.google.cloud.firestore.QuerySnapshot;
import com.example.demo.model.User;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;
import java.util.concurrent.ExecutionException;
import java.util.stream.Collectors;

@Repository
public class UserRepository {

    private final Firestore firestore;

    @Autowired
    public UserRepository(Firestore firestore) {
        this.firestore = firestore;
    }

    public Optional<User> findByEmail(String email) {
        try {
            ApiFuture<QuerySnapshot> future = firestore.collection("users").whereEqualTo("email", email).get();
            List<QueryDocumentSnapshot> documents = future.get().getDocuments();
            if (!documents.isEmpty()) {
                return Optional.of(new User(documents.get(0).getData()));
            }
        } catch (InterruptedException | ExecutionException e) {
            throw new CustomExceptions.ProcessingException("Error fetching user by email from Firebase: " + e.getMessage());
        }
        return Optional.empty();
    }


    public boolean existsByEmail(String email) {
        return findByEmail(email).isPresent();
    }

    public User save(User user) {
        firestore.collection("users").document(user.getUid()).set(user.toMap());
        return user;
    }

    public List<User> findAll() {
        try {
            ApiFuture<QuerySnapshot> future = firestore.collection("users").get();
            List<QueryDocumentSnapshot> documents = future.get().getDocuments();
            return documents.stream()
                    .map(doc -> new User(doc.getData()))
                    .collect(Collectors.toList());
        } catch (InterruptedException | ExecutionException e) {
            throw new CustomExceptions.ProcessingException("Error fetching all users from Firebase: " + e.getMessage());
        }
    }


    public Optional<User> findById(String id) {
        try {
            ApiFuture<QuerySnapshot> future = firestore.collection("users").whereEqualTo("uid", id).get();
            List<QueryDocumentSnapshot> documents = future.get().getDocuments();
            if (!documents.isEmpty()) {
                return Optional.of(new User(documents.get(0).getData()));
            }
        } catch (InterruptedException | ExecutionException e) {
            throw new CustomExceptions.ProcessingException("Error fetching user by id from Firebase: " + e.getMessage());
        }
        return Optional.empty();
    }

    public void deleteById(String id) {
        firestore.collection("users").document(id).delete();
    }
}

Estructura: security
Archivo: CustomUserDetails.java
--------------------------------------------------
package com.example.demo.security;


import com.example.demo.model.Role;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;

import java.util.Collection;
import java.util.List;

public class CustomUserDetails implements UserDetails {

    private String email;
    private List<Role> roles;
    private boolean enabled;

    // Constructor, Getters y Setters

    public CustomUserDetails(String email, List<Role> roles, boolean enabled) {
        this.email = email;
        this.roles = roles;
        this.enabled = enabled;
    }

    public List<Role> getRoles() {
        return roles;
    }

    @Override
    public Collection<? extends GrantedAuthority> getAuthorities() {
        // Si necesitas implementar roles en granted authorities
        return null;
    }

    @Override
    public String getPassword() {
        return null; // No usas contraseña, Firebase maneja esto
    }

    @Override
    public String getUsername() {
        return email;
    }

    @Override
    public boolean isAccountNonExpired() {
        return true;
    }

    @Override
    public boolean isAccountNonLocked() {
        return true;
    }

    @Override
    public boolean isCredentialsNonExpired() {
        return true;
    }

    @Override
    public boolean isEnabled() {
        return enabled;
    }
}


Estructura: security
Archivo: FirebaseAuthenticationFilter.java
--------------------------------------------------
package com.example.demo.security;

import com.google.firebase.auth.FirebaseAuth;
import com.google.firebase.auth.FirebaseAuthException;
import com.google.firebase.auth.FirebaseToken;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.web.filter.OncePerRequestFilter;

import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

public class FirebaseAuthenticationFilter extends OncePerRequestFilter {

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)
            throws ServletException, IOException {
        try {
            if (isPublicEndpoint(request)) {
                filterChain.doFilter(request, response);
                return;
            }

            String idToken = extractToken(request);
            if (idToken == null) {
                handleAuthenticationFailure(response, "No token provided");
                return;
            }

            FirebaseToken decodedToken = verifyToken(idToken);
            if (decodedToken == null) {
                handleAuthenticationFailure(response, "Invalid token");
                return;
            }

            List<SimpleGrantedAuthority> authorities = extractAuthorities(decodedToken);
            setAuthenticationInContext(decodedToken, authorities);

            filterChain.doFilter(request, response);
        } catch (Exception e) {
            logger.error("Authentication error", e);
            handleAuthenticationFailure(response, "Authentication failed");
        }
    }

    private boolean isPublicEndpoint(HttpServletRequest request) {
        String path = request.getRequestURI();
        return path.contains("/api/auth/login") ||
                path.contains("/api/auth/register") ||
                path.contains("/v3/api-docs") ||
                path.contains("/swagger-ui/") ||
                path.contains("/swagger-resources") ||
                path.contains("/configuration/") ||
                path.contains("/webjars/") ||
                path.contains("/swagger-ui.html") ||
                path.contains("favicon.ico");
    }

    private String extractToken(HttpServletRequest request) {
        String authorizationHeader = request.getHeader("Authorization");
        if (authorizationHeader != null && authorizationHeader.startsWith("Bearer ")) {
            return authorizationHeader.substring(7);
        }
        return null;
    }

    private FirebaseToken verifyToken(String idToken) {
        try {
            return FirebaseAuth.getInstance().verifyIdToken(idToken);
        } catch (FirebaseAuthException e) {
            logger.error("Error verifying Firebase token", e);
            return null;
        }
    }

    private List<SimpleGrantedAuthority> extractAuthorities(FirebaseToken decodedToken) {
        List<SimpleGrantedAuthority> authorities = new ArrayList<>();
        Object rolesObject = decodedToken.getClaims().get("roles");
        if (rolesObject instanceof List) {
            List<?> roles = (List<?>) rolesObject;
            for (Object role : roles) {
                if (role instanceof String) {
                    authorities.add(new SimpleGrantedAuthority("ROLE_" + ((String) role).toUpperCase()));
                }
            }
        }
        if (authorities.isEmpty()) {
            authorities.add(new SimpleGrantedAuthority("ROLE_CLIENTE"));
        }
        return authorities;
    }

    private void setAuthenticationInContext(FirebaseToken decodedToken, List<SimpleGrantedAuthority> authorities) {
        UsernamePasswordAuthenticationToken authentication = new UsernamePasswordAuthenticationToken(
                decodedToken.getUid(), null, authorities);
       // logger.info((Object) "Roles assigned to SecurityContext: {}. User ID: {}", (Throwable) authorities);
        SecurityContextHolder.getContext().setAuthentication(authentication);

    }

    private void handleAuthenticationFailure(HttpServletResponse response, String message) throws IOException {
        SecurityContextHolder.clearContext();
        response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
        response.setContentType("application/json");
        response.getWriter().write("{\"error\":\"" + message + "\"}");
    }

}

Estructura: service
Archivo: AppointmentService.java
--------------------------------------------------
package com.example.demo.service;

import com.example.demo.dto.*;
import com.example.demo.dto.AppointmentDTOs.*;
import com.example.demo.exception.CustomExceptions;
import com.example.demo.model.Appointment;
import com.google.cloud.firestore.*;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Service;
import java.util.*;
import java.util.concurrent.ExecutionException;
import java.time.LocalDate;
import java.time.ZoneId;
import java.util.stream.Collectors;

@Service
public class AppointmentService {

    @Autowired
    private Firestore firestore;

    @Autowired
    private UserService userService;

    @Autowired
    private PetService petService;

    @Autowired
    private NotificationService notificationService;

    private static final long MINIMUM_CANCELLATION_HOURS = 24;
    private static final long MINIMUM_RESCHEDULE_HOURS = 24;
    private static final Logger logger = LoggerFactory.getLogger(AppointmentService.class);

    /**
     * Obtiene las citas del día para un veterinario específico
     */
    public PaginatedResponse<AppointmentResponse> getVeterinarianDailyAppointments(
            String veterinarianId, Date date, PaginationRequest request) {
        try {
            CollectionReference appointmentsRef = firestore.collection("appointments");

            // Convertir la fecha a LocalDate para comparar solo la fecha sin hora
            LocalDate appointmentDate = date.toInstant()
                    .atZone(ZoneId.systemDefault())
                    .toLocalDate();

            // Obtener el inicio y fin del día
            Date startOfDay = Date.from(appointmentDate.atStartOfDay(ZoneId.systemDefault()).toInstant());
            Date endOfDay = Date.from(appointmentDate.plusDays(1).atStartOfDay(ZoneId.systemDefault()).toInstant());

            // Construir query base con filtros de fecha y veterinario
            Query query = appointmentsRef
                    .whereEqualTo("veterinarianId", veterinarianId)
                    .whereGreaterThanOrEqualTo("appointmentDate", startOfDay)
                    .whereLessThan("appointmentDate", endOfDay);

            // Aplicar filtros adicionales si existen
            if (request.getFilterBy() != null && request.getFilterValue() != null) {
                query = query.whereEqualTo(request.getFilterBy(), request.getFilterValue());
            }

            // Aplicar ordenamiento
            Query.Direction direction = request.getSortDirection().equalsIgnoreCase("DESC")
                    ? Query.Direction.DESCENDING
                    : Query.Direction.ASCENDING;
            query = query.orderBy(request.getSortBy(), direction);

            // Aplicar paginación
            query = query.offset(request.getPage() * request.getSize())
                    .limit(request.getSize());

            // Ejecutar query
            QuerySnapshot querySnapshot = query.get().get();

            // Convertir y enriquecer resultados
            List<AppointmentResponse> appointments = new ArrayList<>();
            for (DocumentSnapshot doc : querySnapshot.getDocuments()) {
                Appointment appointment = doc.toObject(Appointment.class);
                if (appointment != null) {
                    appointments.add(enrichAppointmentResponse(appointment));
                }
            }

            // Contar total de elementos para este día y veterinario
            long totalElements = appointmentsRef
                    .whereEqualTo("veterinarianId", veterinarianId)
                    .whereGreaterThanOrEqualTo("appointmentDate", startOfDay)
                    .whereLessThan("appointmentDate", endOfDay)
                    .get().get().size();

            return PaginatedResponse.of(appointments, request, totalElements);

        } catch (Exception e) {
            throw new CustomExceptions.ProcessingException(
                    "Error getting daily appointments: " + e.getMessage());
        }
    }
    public PaginatedResponse<AppointmentResponse> getDailyAppointments(
            String veterinarianId, Date date, PaginationRequest request) {
        try {
            CollectionReference appointmentsRef = firestore.collection("appointments");

            // Obtener inicio y fin del día
            LocalDate appointmentDate = date.toInstant()
                    .atZone(ZoneId.systemDefault())
                    .toLocalDate();
            Date startOfDay = Date.from(appointmentDate.atStartOfDay(ZoneId.systemDefault()).toInstant());
            Date endOfDay = Date.from(appointmentDate.plusDays(1).atStartOfDay(ZoneId.systemDefault()).toInstant());

            // Query base con filtros de fecha y veterinario
            Query query = appointmentsRef
                    .whereEqualTo("veterinarianId", veterinarianId)
                    .whereGreaterThanOrEqualTo("appointmentDate", startOfDay)
                    .whereLessThan("appointmentDate", endOfDay);

            // Aplicar filtros adicionales
            if (request.getFilterBy() != null && request.getFilterValue() != null) {
                query = query.whereEqualTo(request.getFilterBy(), request.getFilterValue());
            }

            // Ordenamiento
            Query.Direction direction = request.getSortDirection().equalsIgnoreCase("DESC")
                    ? Query.Direction.DESCENDING
                    : Query.Direction.ASCENDING;
            query = query.orderBy(request.getSortBy(), direction);

            // Paginación
            query = query.offset(request.getPage() * request.getSize())
                    .limit(request.getSize());

            QuerySnapshot querySnapshot = query.get().get();

            List<AppointmentResponse> appointments = querySnapshot.getDocuments().stream()
                    .map(doc -> {
                        Appointment appointment = doc.toObject(Appointment.class);
                        try {
                            return enrichAppointmentResponse(appointment);
                        } catch (ExecutionException | InterruptedException e) {
                            throw new RuntimeException(e);
                        }
                    })
                    .collect(Collectors.toList());

            // Contar total de citas para este día y veterinario
            long totalElements = appointmentsRef
                    .whereEqualTo("veterinarianId", veterinarianId)
                    .whereGreaterThanOrEqualTo("appointmentDate", startOfDay)
                    .whereLessThan("appointmentDate", endOfDay)
                    .get().get().size();

            return PaginatedResponse.of(appointments, request, totalElements);
        } catch (Exception e) {
            throw new CustomExceptions.ProcessingException(
                    "Error fetching daily appointments: " + e.getMessage());
        }
    }

    /**
     * Enriquece la respuesta de la cita con información detallada
     */
    private AppointmentResponse enrichAppointmentResponse(Appointment appointment) throws ExecutionException, InterruptedException {
        AppointmentResponse response = new AppointmentResponse();
        response.setId(appointment.getId());
        response.setAppointmentDate(appointment.getAppointmentDate());
        response.setReason(appointment.getReason());
        response.setStatus(appointment.getStatus());
        response.setNotes(appointment.getNotes());

        // Obtener información del cliente
        response.setClient(userService.getUserById(appointment.getClientId()));

        // Obtener información del veterinario
        response.setVeterinarian(userService.getUserById(appointment.getVeterinarianId()));

        // Obtener información de la mascota
        response.setPet(petService.getPetById(appointment.getPetId()));

        // Obtener historial médico de la mascota - Agregamos el objeto de paginación
        PaginationRequest defaultPagination = new PaginationRequest();
        defaultPagination.setPage(0);
        defaultPagination.setSize(5); // Limitamos a los últimos 5 registros
        defaultPagination.setSortBy("date");
        defaultPagination.setSortDirection("DESC");

        PaginatedResponse<PetDTOs.MedicalRecordResponse> historyResponse =
                petService.getPetMedicalHistory(appointment.getPetId(), defaultPagination);
        response.setPetHistory(historyResponse.getContent());

        return response;
    }
    /**
     * Obtiene todas las citas de las mascotas del cliente actual
     */
    public PaginatedResponse<AppointmentSummaryByPet> getClientPetsAppointments(
            PaginationRequest paginationRequest) {
        try {
            String clientId = SecurityContextHolder.getContext().getAuthentication().getName();

            // Obtener las mascotas del cliente
            List<PetDTOs.PetResponse> clientPets = petService.getPetsByUserId(clientId);

            List<AppointmentSummaryByPet> summaries = new ArrayList<>();

            for (PetDTOs.PetResponse pet : clientPets) {
                // Consultar citas para cada mascota
                CollectionReference appointmentsRef = firestore.collection("appointments");
                Query query = appointmentsRef
                        .whereEqualTo("petId", pet.getId())
                        .whereGreaterThanOrEqualTo("appointmentDate", new Date());

                // Aplicar filtros si existen
                if (paginationRequest.getFilterBy() != null &&
                        paginationRequest.getFilterValue() != null) {
                    query = query.whereEqualTo(
                            paginationRequest.getFilterBy(),
                            paginationRequest.getFilterValue()
                    );
                }

                // Aplicar ordenamiento
                String sortBy = paginationRequest.getSortBy().equals("id") ?
                        "appointmentDate" : paginationRequest.getSortBy();
                Query.Direction direction = paginationRequest.getSortDirection()
                        .equalsIgnoreCase("DESC") ?
                        Query.Direction.DESCENDING :
                        Query.Direction.ASCENDING;

                query = query.orderBy(sortBy, direction);

                // Aplicar paginación
                query = query
                        .offset(paginationRequest.getPage() * paginationRequest.getSize())
                        .limit(paginationRequest.getSize());

                // Ejecutar query
                QuerySnapshot querySnapshot = query.get().get();

                // Convertir resultados
                List<AppointmentResponse> appointments = querySnapshot.getDocuments()
                        .stream()
                        .map(doc -> {
                            try {
                                Appointment appointment = doc.toObject(Appointment.class);
                                return enrichAppointmentResponse(appointment);
                            } catch (Exception e) {
                                logger.error("Error enriching appointment", e);
                                return null;
                            }
                        })
                        .filter(Objects::nonNull)
                        .collect(Collectors.toList());

                if (!appointments.isEmpty()) {
                    summaries.add(new AppointmentSummaryByPet(
                            pet,
                            appointments,
                            appointments.size()
                    ));
                }
            }

            // Calcular el total de elementos para la paginación
            long totalElements = summaries.size();

            return PaginatedResponse.of(
                    summaries,
                    paginationRequest,
                    totalElements
            );

        } catch (Exception e) {
            throw new CustomExceptions.ProcessingException(
                    "Error fetching client pets appointments: " + e.getMessage()
            );
        }
    }

    /**
     * Reprograma una cita existente
     */
    public AppointmentDTOs.AppointmentResponse rescheduleAppointment(
            String appointmentId,
            AppointmentDTOs.RescheduleRequest request
    ) {
        try {
            DocumentReference appointmentRef = firestore.collection("appointments").document(appointmentId);
            DocumentSnapshot appointmentDoc = appointmentRef.get().get();

            if (!appointmentDoc.exists()) {
                throw new CustomExceptions.NotFoundException("Appointment not found");
            }

            Appointment appointment = appointmentDoc.toObject(Appointment.class);

            // Verificar tiempo mínimo para reprogramar
            if (!canReschedule(appointment.getAppointmentDate())) {
                throw new CustomExceptions.UnauthorizedException(
                        "Las citas solo pueden reprogramarse con " + MINIMUM_RESCHEDULE_HOURS + " horas de anticipación"
                );
            }

            // Guardar la fecha anterior para la notificación
            Date oldDate = appointment.getAppointmentDate();

            // Actualizar la cita
            appointment.setAppointmentDate(request.getNewDate());
            appointment.setNotes(appointment.getNotes() + "\nReprogramada: " + request.getReason());
            appointment.setUpdatedAt(new Date());

            appointmentRef.set(appointment).get();

            // Enviar notificaciones
            sendRescheduleNotifications(appointment, oldDate, request.getNewDate());

            return enrichAppointmentResponse(appointment);
        } catch (Exception e) {
            throw new CustomExceptions.ProcessingException("Error rescheduling appointment: " + e.getMessage());
        }
    }

    /**
     * Cancela una cita existente
     */
    public AppointmentDTOs.AppointmentResponse cancelAppointment(String appointmentId) {
        try {
            DocumentReference appointmentRef = firestore.collection("appointments").document(appointmentId);
            DocumentSnapshot appointmentDoc = appointmentRef.get().get();

            if (!appointmentDoc.exists()) {
                throw new CustomExceptions.NotFoundException("Appointment not found");
            }

            Appointment appointment = appointmentDoc.toObject(Appointment.class);

            // Verificar tiempo mínimo para cancelar
            if (!canCancel(appointment.getAppointmentDate())) {
                throw new CustomExceptions.UnauthorizedException(
                        "Las citas solo pueden cancelarse con " + MINIMUM_CANCELLATION_HOURS + " horas de anticipación"
                );
            }

            // Actualizar el estado de la cita
            appointment.setStatus("CANCELLED");
            appointment.setUpdatedAt(new Date());

            appointmentRef.set(appointment).get();

            // Enviar notificaciones
            sendCancellationNotifications(appointment);

            return enrichAppointmentResponse(appointment);
        } catch (Exception e) {
            throw new CustomExceptions.ProcessingException("Error canceling appointment: " + e.getMessage());
        }
    }

    /**
     * Verifica si el usuario autenticado es dueño de la cita
     */
    public boolean isOwner(String appointmentId) {
        try {
            String currentUserId = SecurityContextHolder.getContext().getAuthentication().getName();
            DocumentSnapshot appointmentDoc = firestore.collection("appointments")
                    .document(appointmentId)
                    .get()
                    .get();

            if (!appointmentDoc.exists()) {
                return false;
            }

            Appointment appointment = appointmentDoc.toObject(Appointment.class);
            return appointment != null && appointment.getClientId().equals(currentUserId);
        } catch (Exception e) {
            //logger.error("Error checking appointment ownership: {}", e.getMessage());
            return false;
        }
    }

    private boolean canReschedule(Date appointmentDate) {
        return getHoursDifference(appointmentDate) >= MINIMUM_RESCHEDULE_HOURS;
    }

    private boolean canCancel(Date appointmentDate) {
        return getHoursDifference(appointmentDate) >= MINIMUM_CANCELLATION_HOURS;
    }

    private long getHoursDifference(Date appointmentDate) {
        long diffInMillies = appointmentDate.getTime() - new Date().getTime();
        return diffInMillies / (60 * 60 * 1000);
    }

    private void sendRescheduleNotifications(Appointment appointment, Date oldDate, Date newDate) {
        // Notificar al cliente
        notificationService.sendAppointmentRescheduledNotification(
                appointment.getClientId(),
                appointment.getPetId(),
                oldDate,
                newDate
        );

        // Notificar al veterinario
        notificationService.sendVeterinarianAppointmentRescheduledNotification(
                appointment.getVeterinarianId(),
                appointment.getPetId(),
                oldDate,
                newDate
        );
    }

    private void sendCancellationNotifications(Appointment appointment) {
        // Notificar al cliente
        notificationService.sendAppointmentCancelledNotification(
                appointment.getClientId(),
                appointment.getPetId(),
                appointment.getAppointmentDate()
        );

        // Notificar al veterinario
        notificationService.sendVeterinarianAppointmentCancelledNotification(
                appointment.getVeterinarianId(),
                appointment.getPetId(),
                appointment.getAppointmentDate()
        );
    }
    public AppointmentResponse createAppointment(CreateAppointmentRequest request) {
        //String clientId = SecurityContextHolder.getContext().getAuthentication().getName();

        try {
            // Validar que la mascota pertenece al cliente
            /*
            PetDTOs.PetResponse pet = petService.getPetById(request.getPetId());
            if (!pet.getOwnerId().equals(clientId)) {
                throw new CustomExceptions.UnauthorizedException("No tienes permiso para agendar citas para esta mascota");
            }
            */


            // Validar que la fecha es futura
            if (request.getAppointmentDate().before(new Date())) {
                throw new IllegalArgumentException("La fecha de la cita debe ser futura");
            }

            // Crear la cita
            Appointment appointment = Appointment.builder()
                    .id(UUID.randomUUID().toString())
                    .petId(request.getPetId())
                    .clientId(request.getClientId())
                    .veterinarianId(request.getVeterinarianId())
                    .appointmentDate(request.getAppointmentDate())
                    .reason(request.getReason())
                    .status("SCHEDULED")
                    .notes(request.getNotes())
                    .createdAt(new Date())
                    .updatedAt(new Date())
                    .build();

            // Guardar en Firestore
            firestore.collection("appointments")
                    .document(appointment.getId())
                    .set(appointment)
                    .get();

            // Enviar notificaciones
            sendNewAppointmentNotifications(appointment);

            return enrichAppointmentResponse(appointment);
        } catch (Exception e) {
            throw new CustomExceptions.ProcessingException("Error creating appointment: " + e.getMessage());
        }
    }

    private void sendNewAppointmentNotifications(Appointment appointment) {
        try {
            // Notificar al cliente
            UserDTOs.UserResponse client = userService.getUserById(appointment.getClientId());
            PetDTOs.PetResponse pet = petService.getPetById(appointment.getPetId());
            UserDTOs.UserResponse vet = userService.getUserById(appointment.getVeterinarianId());

            String clientSubject = "Nueva cita programada para " + pet.getName();
            String clientContent = notificationService.generateNewAppointmentEmail(pet.getName(),
                    appointment.getAppointmentDate(),
                    vet.getNombre() + " " + vet.getApellido());

            notificationService.sendEmail(client.getEmail(), clientSubject, clientContent);

            // Notificar al veterinario
            String vetSubject = "Nueva cita programada";
            String vetContent = notificationService.generateNewAppointmentVetEmail(pet.getName(),
                    appointment.getAppointmentDate(),
                    client.getNombre() + " " + client.getApellido());

            notificationService.sendEmail(vet.getEmail(), vetSubject, vetContent);
        } catch (Exception e) {
            //log.error("Error sending new appointment notifications: {}", e.getMessage());
        }
    }
}

Estructura: service
Archivo: AuthService.java
--------------------------------------------------
package com.example.demo.service;

import com.example.demo.dto.AuthDTOs.*;
import com.example.demo.dto.UserDTOs.UserResponse;
import com.example.demo.exception.CustomExceptions;

import com.google.firebase.auth.FirebaseAuth;
import com.google.firebase.auth.FirebaseAuthException;

import com.google.firebase.auth.FirebaseToken;
import com.google.firebase.auth.UserRecord;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Service;
import org.springframework.web.reactive.function.client.WebClient;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

import java.util.stream.Collectors;

@Service
public class AuthService {

    @Autowired
    private UserService userService;
    @Autowired
    private FirebaseAuth firebaseAuth;

    @Value("${firebase.api.key}")
    private String firebaseApiKey;

    private final WebClient webClient;

    public AuthService(WebClient.Builder webClientBuilder) {
        this.webClient = webClientBuilder.baseUrl("https://identitytoolkit.googleapis.com/v1").build();
    }

//    public AuthResponse registerUser(RegisterRequest request) {
//        try {
//            UserRecord userRecord;
//            UserRecord.CreateRequest createRequest = new UserRecord.CreateRequest()
//                    .setEmail(request.getEmail())
//                    .setPassword(request.getPassword())
//                    .setDisplayName(request.getNombre() + " " + request.getApellido());
//
//            try {
//                // Intentar crear el usuario
//                userRecord = FirebaseAuth.getInstance().createUser(createRequest);
//            } catch (FirebaseAuthException e) {
//                if ("auth/email-already-exists".equals(e.getErrorCode())) {
//                    // Si el email existe, intentamos obtener el usuario
//                    userRecord = FirebaseAuth.getInstance().getUserByEmail(request.getEmail());
//                    // Si el usuario existe en Auth pero no en Firestore, lo eliminamos y creamos uno nuevo
//                    if (!userService.existsByEmail(request.getEmail())) {
//                        FirebaseAuth.getInstance().deleteUser(userRecord.getUid());
//                        userRecord = FirebaseAuth.getInstance().createUser(createRequest);
//                    } else {
//                        throw new CustomExceptions.EmailAlreadyExistsException("Email already in use");
//                    }
//                } else {
//                    throw e;
//                }
//            }
//
//            UserResponse user = userService.createUser(request);
//
//            List<String> rolesWithPrefix = user.getRoles().stream()
//                    .map(role -> "ROLE_" + role.name())
//                    .collect(Collectors.toList());
//
//            Map<String, Object> claims = new HashMap<>();
//            claims.put("roles", rolesWithPrefix);
//            FirebaseAuth.getInstance().setCustomUserClaims(userRecord.getUid(), claims);
//
//            String customToken = FirebaseAuth.getInstance().createCustomToken(userRecord.getUid());
//            String idToken = exchangeCustomTokenForIdToken(customToken);
//
//            return new AuthResponse(idToken, user);
//        } catch (FirebaseAuthException e) {
//            throw new CustomExceptions.AuthenticationException("Error during user registration: " + e.getMessage());
//        }
//    }
    public AuthResponse registerUser(RegisterRequest request) {
        try {
            System.out.println("Attempting to create user with email: " + request.getEmail());
            UserRecord.CreateRequest createRequest = new UserRecord.CreateRequest()
                    .setEmail(request.getEmail())
                    .setPassword(request.getPassword())
                    .setDisplayName(request.getNombre() + " " + request.getApellido());

            System.out.println("Sending create user request to Firebase");
            UserRecord userRecord = FirebaseAuth.getInstance().createUser(createRequest);
            System.out.println("User created successfully in Firebase with UID: " + userRecord.getUid());

            // Usa el UID generado por Firebase
            request.setUid(userRecord.getUid());
            UserResponse user = userService.createUser(request);

            List<String> rolesWithPrefix = user.getRoles().stream()
                    .map(role -> "ROLE_" + role.name())
                    .collect(Collectors.toList());

            Map<String, Object> claims = new HashMap<>();
            claims.put("roles", rolesWithPrefix);
            FirebaseAuth.getInstance().setCustomUserClaims(userRecord.getUid(), claims);

            String customToken = FirebaseAuth.getInstance().createCustomToken(userRecord.getUid());
            String idToken = exchangeCustomTokenForIdToken(customToken);

            return new AuthResponse(idToken, user);
        } catch (FirebaseAuthException e) {
            if (e.getErrorCode().equals("auth/email-already-exists")) {
                System.err.println("FirebaseAuthException occurred: " + e.getErrorCode() + " - " + e.getMessage());

                throw new CustomExceptions.EmailAlreadyExistsException("The user with the provided email already exists");
            }
            throw new CustomExceptions.AuthenticationException("Error during user registration: " + e.getMessage());
        }
    }
    public AuthResponse loginUser(LoginRequest request) {
        try {
            // Obtener el usuario por correo electrónico
            UserRecord userRecord = FirebaseAuth.getInstance().getUserByEmail(request.getEmail());
            UserResponse user = userService.getUserById(userRecord.getUid());

            // Validar la contraseña
            WebClient webClient = WebClient.builder().baseUrl("https://identitytoolkit.googleapis.com/v1").build();
            Map<String, Object> loginData = Map.of(
                    "email", request.getEmail(),
                    "password", request.getPassword(),
                    "returnSecureToken", true
            );

            Map<String, Object> response = webClient.post()
                    .uri("/accounts:signInWithPassword?key=" + firebaseApiKey)
                    .bodyValue(loginData)
                    .retrieve()
                    .bodyToMono(Map.class)
                    .block();

            if (response == null || response.containsKey("error")) {
                throw new CustomExceptions.InvalidCredentialsException("Invalid email or password.");
            }

            // Si la contraseña es válida, generar el token personalizado
            String customToken = FirebaseAuth.getInstance().createCustomToken(userRecord.getUid());
            String idToken = exchangeCustomTokenForIdToken(customToken);

            return new AuthResponse(idToken, user);
        } catch (FirebaseAuthException e) {
            throw new CustomExceptions.AuthenticationException("Invalid email or password.");
        } catch (CustomExceptions.InvalidCredentialsException e) {
            throw new CustomExceptions.InvalidCredentialsException(e.getMessage());
        } catch (Exception e) {
            // Captura cualquier excepción inesperada para evitar el error 500 sin contexto
            //aqui esta el error cuando no se cumple correo y contraseña correctos
            throw new CustomExceptions.AuthenticationException("Invalid email or password." );
        }
    }



    private String exchangeCustomTokenForIdToken(String customToken) {
        return webClient.post()
                .uri("/accounts:signInWithCustomToken?key=" + firebaseApiKey)
                .bodyValue(Map.of("token", customToken, "returnSecureToken", true))
                .retrieve()
                .bodyToMono(Map.class)
                .map(response -> (String) response.get("idToken"))
                .block();
    }



    public void logout() {
        // Obtener el token actual del contexto de seguridad
        String token =  SecurityContextHolder.getContext().getAuthentication().getCredentials().toString();

        try {
            // Verificar y obtener el UID del token
            FirebaseToken decodedToken = firebaseAuth.verifyIdToken(token);
            String uid = decodedToken.getUid();

            // Revocar todos los tokens del usuario
            firebaseAuth.revokeRefreshTokens(uid);

            // Limpiar el contexto de seguridad
            SecurityContextHolder.clearContext();

        } catch (FirebaseAuthException e) {
            // Manejar cualquier error de autenticación
            throw new RuntimeException("Error al cerrar sesión", e);
        }
    }

    public AuthResponse refreshToken(String uid) {
        try {
            UserRecord userRecord = FirebaseAuth.getInstance().getUser(uid);
            UserResponse user = userService.getUserById(uid);

            // Generar nuevo token personalizado
            String customToken = FirebaseAuth.getInstance().createCustomToken(uid);

            return new AuthResponse(customToken, user);
        } catch (FirebaseAuthException e) {
            throw new CustomExceptions.AuthenticationException("Error refreshing token: " + e.getMessage());
        }
    }

    public void resetPassword(String email) {
        try {
            FirebaseAuth.getInstance().generatePasswordResetLink(email);
        } catch (FirebaseAuthException e) {
            throw new CustomExceptions.AuthenticationException("Error generating password reset link: " + e.getMessage());
        }
    }
}

Estructura: service
Archivo: ClientAppointmentService.java
--------------------------------------------------
package com.example.demo.service;

import com.example.demo.dto.AppointmentDTOs;
import com.example.demo.dto.PaginatedResponse;
import com.example.demo.dto.PaginationRequest;
import com.example.demo.dto.UserDTOs;
import com.example.demo.dto.PetDTOs;
import com.example.demo.exception.CustomExceptions;
import com.example.demo.model.Appointment;
import com.google.cloud.firestore.*;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Service;

import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.concurrent.ExecutionException;

@Service
@Slf4j
public class ClientAppointmentService {

    private static final int MINIMUM_HOURS_BEFORE_CANCEL = 24;
    private static final int MINIMUM_HOURS_BEFORE_RESCHEDULE = 24;

    @Autowired
    private Firestore firestore;

    @Autowired
    private NotificationService notificationService;

    @Autowired
    private UserService userService;

    @Autowired
    private PetService petService;

    /**
     * Obtiene todas las citas del cliente actual
     */
    public PaginatedResponse<AppointmentDTOs.ClientPetAppointmentDTO> getClientAppointments(PaginationRequest request) {
        String clientId = SecurityContextHolder.getContext().getAuthentication().getName();

        try {
            // Crear referencia a la colección de citas
            CollectionReference appointmentsRef = firestore.collection("appointments");

            // Construir query base
            Query query = appointmentsRef
                    .whereEqualTo("clientId", clientId)
                    .whereGreaterThanOrEqualTo("appointmentDate", new Date());

            // Aplicar ordenamiento
            Query.Direction direction = request.getSortDirection().equalsIgnoreCase("DESC")
                    ? Query.Direction.DESCENDING
                    : Query.Direction.ASCENDING;

            query = query.orderBy("appointmentDate", direction);

            // Aplicar paginación
            query = query.offset(request.getPage() * request.getSize())
                    .limit(request.getSize());

            // Ejecutar query
            QuerySnapshot querySnapshot = query.get().get();

            // Convertir resultados
            List<AppointmentDTOs.ClientPetAppointmentDTO> appointments = new ArrayList<>();
            for (DocumentSnapshot doc : querySnapshot.getDocuments()) {
                Appointment appointment = doc.toObject(Appointment.class);
                if (appointment != null) {
                    appointments.add(convertToDTO(appointment));
                }
            }

            // Obtener total de elementos
            long totalElements = appointmentsRef
                    .whereEqualTo("clientId", clientId)
                    .whereGreaterThanOrEqualTo("appointmentDate", new Date())
                    .get().get().size();

            return PaginatedResponse.of(appointments, request, totalElements);

        } catch (Exception e) {
            log.error("Error fetching client appointments: {}", e.getMessage());
            throw new CustomExceptions.ProcessingException("Error fetching appointments");
        }
    }

    /**
     * Cancela una cita verificando las políticas establecidas
     */
    public AppointmentDTOs.ClientPetAppointmentDTO cancelAppointment(String appointmentId) {
        String clientId = SecurityContextHolder.getContext().getAuthentication().getName();

        try {
            // Obtener la cita
            DocumentSnapshot appointmentDoc = firestore.collection("appointments")
                    .document(appointmentId)
                    .get().get();

            if (!appointmentDoc.exists()) {
                throw new CustomExceptions.NotFoundException("Appointment not found");
            }

            Appointment appointment = appointmentDoc.toObject(Appointment.class);

            // Verificar que la cita pertenece al cliente
            if (!appointment.getClientId().equals(clientId)) {
                throw new CustomExceptions.UnauthorizedException("Unauthorized to cancel this appointment");
            }

            // Verificar tiempo mínimo para cancelación
            if (!canCancel(appointment.getAppointmentDate())) {
                throw new CustomExceptions.ProcessingException(
                        "Appointments can only be cancelled " + MINIMUM_HOURS_BEFORE_CANCEL + " hours in advance");
            }

            // Actualizar estado
            appointment.setStatus("CANCELLED");
            appointmentDoc.getReference().set(appointment).get();

            // Enviar notificaciones
            sendCancellationNotifications(appointment);

            return convertToDTO(appointment);

        } catch (Exception e) {
            log.error("Error cancelling appointment: {}", e.getMessage());
            throw new CustomExceptions.ProcessingException("Error cancelling appointment");
        }
    }

    /**
     * Reprograma una cita verificando las políticas establecidas
     */
    public AppointmentDTOs.ClientPetAppointmentDTO rescheduleAppointment(String appointmentId,
                                                                         AppointmentDTOs.RescheduleRequest request) {
        String clientId = SecurityContextHolder.getContext().getAuthentication().getName();

        try {
            // Verificar que la nueva fecha es futura
            if (request.getNewDate().before(new Date())) {
                throw new CustomExceptions.ProcessingException("New date must be in the future");
            }

            // Obtener la cita
            DocumentSnapshot appointmentDoc = firestore.collection("appointments")
                    .document(appointmentId)
                    .get().get();

            if (!appointmentDoc.exists()) {
                throw new CustomExceptions.NotFoundException("Appointment not found");
            }

            Appointment appointment = appointmentDoc.toObject(Appointment.class);

            // Verificar que la cita pertenece al cliente
            if (!appointment.getClientId().equals(clientId)) {
                throw new CustomExceptions.UnauthorizedException(
                        "Unauthorized to reschedule this appointment");
            }

            // Verificar tiempo mínimo para reprogramación
            if (!canReschedule(appointment.getAppointmentDate())) {
                throw new CustomExceptions.ProcessingException(
                        "Appointments can only be rescheduled " +
                                MINIMUM_HOURS_BEFORE_RESCHEDULE + " hours in advance");
            }

            // Guardar fecha anterior para notificación
            Date oldDate = appointment.getAppointmentDate();

            // Actualizar fecha
            appointment.setAppointmentDate(request.getNewDate());
            appointmentDoc.getReference().set(appointment).get();

            // Enviar notificaciones
            sendRescheduleNotifications(appointment, oldDate);

            return convertToDTO(appointment);

        } catch (Exception e) {
            log.error("Error rescheduling appointment: {}", e.getMessage());
            throw new CustomExceptions.ProcessingException("Error rescheduling appointment");
        }
    }

    private AppointmentDTOs.ClientPetAppointmentDTO convertToDTO(Appointment appointment)
            throws ExecutionException, InterruptedException {
        // Obtener información del veterinario
        UserDTOs.UserResponse vet = userService.getUserById(appointment.getVeterinarianId());

        return AppointmentDTOs.ClientPetAppointmentDTO.builder()
                .id(appointment.getId())
                .appointmentDate(appointment.getAppointmentDate())
                .reason(appointment.getReason())
                .status(appointment.getStatus())
                .veterinarianName(vet.getNombre() + " " + vet.getApellido())
                .pet(petService.getPetById(appointment.getPetId()))
                .canCancel(canCancel(appointment.getAppointmentDate()))
                .canReschedule(canReschedule(appointment.getAppointmentDate()))
                .build();
    }

    private boolean canCancel(Date appointmentDate) {
        long hoursDifference = getHoursDifference(appointmentDate);
        return hoursDifference >= MINIMUM_HOURS_BEFORE_CANCEL;
    }

    private boolean canReschedule(Date appointmentDate) {
        long hoursDifference = getHoursDifference(appointmentDate);
        return hoursDifference >= MINIMUM_HOURS_BEFORE_RESCHEDULE;
    }

    private long getHoursDifference(Date appointmentDate) {
        long diffInMillies = appointmentDate.getTime() - new Date().getTime();
        return diffInMillies / (60 * 60 * 1000);
    }

    private void sendCancellationNotifications(Appointment appointment)
            throws ExecutionException, InterruptedException {
        // Obtener datos necesarios
        UserDTOs.UserResponse client = userService.getUserById(appointment.getClientId());
        UserDTOs.UserResponse vet = userService.getUserById(appointment.getVeterinarianId());
        PetDTOs.PetResponse pet = petService.getPetById(appointment.getPetId());

        // Notificar al cliente
        String clientSubject = "Cita Cancelada - " + pet.getName();
        String clientContent = generateCancellationEmailContent(
                pet.getName(),
                appointment.getAppointmentDate(),
                vet.getNombre() + " " + vet.getApellido()
        );
        notificationService.sendEmail(client.getEmail(), clientSubject, clientContent);

        // Notificar al veterinario
        String vetSubject = "Cita Cancelada por Cliente";
        String vetContent = generateVetCancellationEmailContent(
                pet.getName(),
                client.getNombre() + " " + client.getApellido(),
                appointment.getAppointmentDate()
        );
        notificationService.sendEmail(vet.getEmail(), vetSubject, vetContent);
    }

    private void sendRescheduleNotifications(Appointment appointment, Date oldDate)
            throws ExecutionException, InterruptedException {
        // Obtener datos necesarios
        UserDTOs.UserResponse client = userService.getUserById(appointment.getClientId());
        UserDTOs.UserResponse vet = userService.getUserById(appointment.getVeterinarianId());
        PetDTOs.PetResponse pet = petService.getPetById(appointment.getPetId());

        // Notificar al cliente
        String clientSubject = "Cita Reprogramada - " + pet.getName();
        String clientContent = generateRescheduleEmailContent(
                pet.getName(),
                oldDate,
                appointment.getAppointmentDate(),
                vet.getNombre() + " " + vet.getApellido()
        );
        notificationService.sendEmail(client.getEmail(), clientSubject, clientContent);

        // Notificar al veterinario
        String vetSubject = "Cita Reprogramada por Cliente";
        String vetContent = generateVetRescheduleEmailContent(
                pet.getName(),
                client.getNombre() + " " + client.getApellido(),
                oldDate,
                appointment.getAppointmentDate()
        );
        notificationService.sendEmail(vet.getEmail(), vetSubject, vetContent);
    }

    // Templates para los correos
    private String generateVetCancellationEmailContent(String petName, String clientName, Date date) {
        return String.format("""
        <html>
        <body>
            <h2>Notificación de Cancelación de Cita</h2>
            <p>Una cita ha sido cancelada por el cliente.</p>
            <p>Detalles de la cita cancelada:</p>
            <ul>
                <li><strong>Mascota:</strong> %s</li>
                <li><strong>Cliente:</strong> %s</li>
                <li><strong>Fecha cancelada:</strong> %s</li>
            </ul>
            <p>El espacio en su agenda ha sido liberado y está disponible para otras citas.</p>
            <hr>
            <p style="color: #666; font-size: 0.9em;">
                Este es un mensaje automático del sistema de gestión de citas veterinarias.
            </p>
        </body>
        </html>
        """,
                petName,
                clientName,
                formatDate(date)
        );
    }

    private String generateVetRescheduleEmailContent(String petName, String clientName,
                                                     Date oldDate, Date newDate) {
        return String.format("""
        <html>
        <body>
            <h2>Notificación de Reprogramación de Cita</h2>
            <p>Una cita ha sido reprogramada por el cliente.</p>
            <p>Detalles de la reprogramación:</p>
            <ul>
                <li><strong>Mascota:</strong> %s</li>
                <li><strong>Cliente:</strong> %s</li>
                <li><strong>Fecha anterior:</strong> %s</li>
                <li><strong>Nueva fecha:</strong> %s</li>
            </ul>
            <p>Por favor, verifique que la nueva fecha se ajuste a su disponibilidad.</p>
            <p style="color: #E74C3C;">
                Si existe algún inconveniente con la nueva fecha, 
                por favor contacte al cliente lo antes posible.
            </p>
            <hr>
            <p style="color: #666; font-size: 0.9em;">
                Este es un mensaje automático del sistema de gestión de citas veterinarias.
            </p>
        </body>
        </html>
        """,
                petName,
                clientName,
                formatDate(oldDate),
                formatDate(newDate)
        );
    }
    // Templates para los correos
    private String generateCancellationEmailContent(String petName, Date date, String vetName) {
        return String.format("""
            <html>
            <body>
                <h2>Cita Cancelada</h2>
                <p>Tu cita para %s ha sido cancelada.</p>
                <p>Detalles de la cita:</p>
                <ul>
                    <li><strong>Fecha:</strong> %s</li>
                    <li><strong>Veterinario:</strong> Dr. %s</li>
                </ul>
                <p>Si deseas programar una nueva cita, por favor contáctanos.</p>
            </body>
            </html>
            """,
                petName,
                formatDate(date),
                vetName
        );
    }

    private String generateRescheduleEmailContent(String petName, Date oldDate,
                                                  Date newDate, String vetName) {
        return String.format("""
            <html>
            <body>
                <h2>Cita Reprogramada</h2>
                <p>Tu cita para %s ha sido reprogramada.</p>
                <p>Detalles de la cita:</p>
                <ul>
                    <li><strong>Fecha anterior:</strong> %s</li>
                    <li><strong>Nueva fecha:</strong> %s</li>
                    <li><strong>Veterinario:</strong> Dr. %s</li>
                </ul>
                <p>Si necesitas hacer algún cambio adicional, por favor contáctanos.</p>
            </body>
            </html>
            """,
                petName,
                formatDate(oldDate),
                formatDate(newDate),
                vetName
        );
    }

    private String formatDate(Date date) {
        SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yyyy HH:mm");
        return sdf.format(date);
    }
}

Estructura: service
Archivo: FavoriteService.java
--------------------------------------------------
package com.example.demo.service;

import com.example.demo.dto.FavoriteDTOs.*;
import com.example.demo.dto.ServiceVeterinaryDTOs;
import com.example.demo.dto.InventoryDTOs;
import com.example.demo.exception.CustomExceptions;
import com.example.demo.model.Favorite;
import com.example.demo.model.InventoryItem;
import com.example.demo.model.ItemType;
import com.example.demo.model.ServiceVeterinary;
import com.google.cloud.firestore.*;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Service;
import java.util.*;

@Service
public class FavoriteService {
    @Autowired
    private Firestore firestore;

    @Autowired
    private ServiceVeterinaryService serviceService;

    @Autowired
    private InventoryService inventoryService;

    /**
     * Obtiene todos los favoritos del veterinario actual
     */
    public List<FavoriteResponse> getCurrentUserFavorites() {
        String userId = getCurrentUserUid();
        try {
            // Obtener todos los favoritos del usuario
            QuerySnapshot snapshot = firestore.collection("favorites")
                    .whereEqualTo("userId", userId)
                    .orderBy("createdAt", Query.Direction.DESCENDING)
                    .get()
                    .get();

            List<FavoriteResponse> favorites = new ArrayList<>();

            for (DocumentSnapshot doc : snapshot.getDocuments()) {
                Favorite favorite = doc.toObject(Favorite.class);
                if (favorite != null) {
                    // Obtener información adicional según el tipo de item
                    FavoriteResponse response = enrichFavoriteResponse(favorite);
                    if (response != null) {
                        favorites.add(response);
                    }
                }
            }

            return favorites;
        } catch (Exception e) {
            throw new CustomExceptions.ProcessingException(
                    "Error fetching favorites: " + e.getMessage());
        }
    }

    /**
     * Alterna el estado de favorito de un item
     */
    public FavoriteResponse toggleFavorite(String itemId, ItemType itemType) {
        String userId = SecurityContextHolder.getContext().getAuthentication().getName();

        try {
            // Primero verificar que el item existe en la colección correspondiente
            boolean itemExists = checkItemExists(itemId, itemType);
            if (!itemExists) {
                throw new CustomExceptions.NotFoundException("Item not found");
            }

            // Buscar si ya existe el favorito
            QuerySnapshot existingFavorite = firestore.collection("favorites")
                    .whereEqualTo("userId", userId)
                    .whereEqualTo("itemId", itemId)
                    .whereEqualTo("itemType", itemType.name())
                    .get()
                    .get();

            // Si existe, eliminarlo
            if (!existingFavorite.isEmpty()) {
                existingFavorite.getDocuments().get(0).getReference().delete().get();
                return null; // Indicar que se eliminó el favorito
            }

            // Si no existe, crearlo
            Favorite favorite = Favorite.builder()
                    .id(UUID.randomUUID().toString())
                    .userId(userId)
                    .itemId(itemId)
                    .itemType(itemType.name())
                    .createdAt(new Date())
                    .build();

            // Guardar en Firestore
            firestore.collection("favorites")
                    .document(favorite.getId())
                    .set(favorite)
                    .get();

            // Retornar respuesta enriquecida
            return enrichFavoriteResponse(favorite);
        } catch (Exception e) {
            throw new CustomExceptions.ProcessingException(
                    "Error toggling favorite: " + e.getMessage());
        }
    }

    /**
     * Verifica si un item está marcado como favorito
     */
    public boolean isFavorite(String itemId, String itemType) {
        String userId = getCurrentUserUid();
        try {
            QuerySnapshot snapshot = firestore.collection("favorites")
                    .whereEqualTo("userId", userId)
                    .whereEqualTo("itemId", itemId)
                    .whereEqualTo("itemType", itemType)
                    .get()
                    .get();

            return !snapshot.isEmpty();
        } catch (Exception e) {
            throw new CustomExceptions.ProcessingException(
                    "Error checking favorite status: " + e.getMessage());
        }
    }

    /**
     * Enriquece la respuesta del favorito con información del item
     */
    private FavoriteResponse enrichFavoriteResponse(Favorite favorite) {
        try {
            // Usamos el enum ItemType para mayor seguridad
            if (ItemType.VETERINARY_SERVICE.name().equals(favorite.getItemType())) {
                // Obtener de la colección veterinary_services
                DocumentSnapshot serviceDoc = firestore.collection("veterinary_services")
                        .document(favorite.getItemId())
                        .get()
                        .get();

                if (serviceDoc.exists()) {
                    ServiceVeterinary service = serviceDoc.toObject(ServiceVeterinary.class);
                    return FavoriteResponse.builder()
                            .id(favorite.getId())
                            .itemId(favorite.getItemId())
                            .itemType(favorite.getItemType())
                            .itemName(service.getName())
                            .price(service.getPrice())
                            .createdAt(favorite.getCreatedAt())
                            .build();
                }

            } else if (ItemType.INVENTORY.name().equals(favorite.getItemType())) {
                // Obtener de la colección inventory
                DocumentSnapshot inventoryDoc = firestore.collection("inventory")
                        .document(favorite.getItemId())
                        .get()
                        .get();

                if (inventoryDoc.exists()) {
                    InventoryItem item = inventoryDoc.toObject(InventoryItem.class);
                    return FavoriteResponse.builder()
                            .id(favorite.getId())
                            .itemId(favorite.getItemId())
                            .itemType(favorite.getItemType())
                            .itemName(item.getName())
                            .price(item.getPrice())
                            .createdAt(favorite.getCreatedAt())
                            // Campos adicionales específicos de inventario
                            .quantity(item.getQuantity())
                            .minThreshold(item.getMinThreshold())
                            .status(calculateStatus(item))
                            .build();
                }
            }

            return null;
        } catch (Exception e) {
            throw new CustomExceptions.ProcessingException(
                    "Error enriching favorite response: " + e.getMessage());
        }
    }


    private String getCurrentUserUid() {
        return SecurityContextHolder.getContext().getAuthentication().getName();
    }
    private boolean checkItemExists(String itemId, ItemType itemType) throws Exception {
        DocumentSnapshot doc;

        if (itemType == ItemType.VETERINARY_SERVICE) {
            doc = firestore.collection("veterinary_services")
                    .document(itemId)
                    .get()
                    .get();
        } else {
            doc = firestore.collection("inventory")
                    .document(itemId)
                    .get()
                    .get();
        }

        return doc.exists();
    }
    private String calculateStatus(InventoryItem item) {
        if (item.getQuantity() <= 0) {
            return "CRITICAL";
        } else if (item.getQuantity() <= item.getMinThreshold()) {
            return "WARNING";
        }
        return "OK";
    }
}

Estructura: service
Archivo: HistorialClinicoService.java
--------------------------------------------------
package com.example.demo.service;


import com.example.demo.dto.HistorialClinicoDTOs.*;
import com.example.demo.dto.PetDTOs;
import com.example.demo.dto.ServiceVeterinaryDTOs;
import com.example.demo.dto.UserDTOs;
import com.example.demo.exception.CustomExceptions;
import com.example.demo.model.HistorialClinico;
import com.example.demo.model.ServicioAdicional;
import com.example.demo.model.ServicioRealizado;
import com.google.cloud.firestore.*;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Service;

import java.util.*;
import java.util.concurrent.ExecutionException;
import java.util.stream.Collectors;

@Service
public class HistorialClinicoService {

    @Autowired
    private Firestore firestore;

    @Autowired
    private UserService userService;

    @Autowired
    private PetService petService;

    @Autowired
    private ServiceVeterinaryService serviceVeterinaryService;

    public HistorialClinicoResponse createHistorial(String petId, CreateHistorialRequest request) {
        String veterinarianId = SecurityContextHolder.getContext().getAuthentication().getName();

        try {
            // Verificar que la mascota existe
            PetDTOs.PetResponse pet = petService.getPetById(petId);
            if (pet == null) {
                throw new CustomExceptions.NotFoundException("Mascota no encontrada");
            }

            // Procesar servicios realizados
            List<ServicioRealizado> serviciosRealizados = new ArrayList<>();
            double precioTotal = 0.0;

            if (request.getServiciosRealizados() != null) {
                for (ServicioRealizadoRequest servicioRequest : request.getServiciosRealizados()) {
                    // Obtener detalles del servicio
                    ServiceVeterinaryDTOs.ServiceDetailResponse serviceDetail =
                            serviceVeterinaryService.getServiceDetails(servicioRequest.getServiceId());

                    // Calcular precio final del servicio
                    double precioServicio = servicioRequest.getPrecioPersonalizado() != null
                            ? servicioRequest.getPrecioPersonalizado()
                            : serviceDetail.getPrice();

                    // Crear registro del servicio
                    ServicioRealizado servicio = ServicioRealizado.builder()
                            .serviceId(serviceDetail.getId())
                            .serviceName(serviceDetail.getName())
                            .precioBase(serviceDetail.getPrice())
                            .precioPersonalizado(servicioRequest.getPrecioPersonalizado())
                            .notas(servicioRequest.getNotas())
                            .build();

                    serviciosRealizados.add(servicio);
                    precioTotal += precioServicio;
                }
            }

            // Procesar servicios adicionales
            List<ServicioAdicional> serviciosAdicionales = new ArrayList<>();
            if (request.getServiciosAdicionales() != null) {
                for (ServicioAdicionalRequest servicioRequest : request.getServiciosAdicionales()) {
                    ServicioAdicional servicio = ServicioAdicional.builder()
                            .descripcion(servicioRequest.getDescripcion())
                            .precio(servicioRequest.getPrecio())
                            .notas(servicioRequest.getNotas())
                            .build();

                    serviciosAdicionales.add(servicio);
                    precioTotal += servicioRequest.getPrecio();
                }
            }

            // Crear el historial clínico
            HistorialClinico historial = HistorialClinico.builder()
                    .id(UUID.randomUUID().toString())
                    .petId(petId)
                    .veterinarianId(veterinarianId)
                    .fechaVisita(new Date())
                    .motivoConsulta(request.getMotivoConsulta())
                    .diagnostico(request.getDiagnostico())
                    .tratamiento(request.getTratamiento())
                    .observaciones(request.getObservaciones())
                    .serviciosRealizados(serviciosRealizados)
                    .serviciosAdicionales(serviciosAdicionales)
                    .precioTotal(precioTotal)
                    .fechaCreacion(new Date())
                    .fechaActualizacion(new Date())
                    .estado("ACTIVO")
                    .build();

            // Guardar en Firestore
            firestore.collection("historial_clinico")
                    .document(historial.getId())
                    .set(historial)
                    .get();

            return enrichHistorialResponse(historial);
        } catch (Exception e) {
            throw new CustomExceptions.ProcessingException(
                    "Error creating historial clinico: " + e.getMessage());
        }
    }

    public HistorialClinicoResponse updateHistorial(String historialId, UpdateHistorialRequest request) {
        try {
            DocumentReference historialRef = firestore.collection("historial_clinico").document(historialId);
            DocumentSnapshot historialDoc = historialRef.get().get();

            if (!historialDoc.exists()) {
                throw new CustomExceptions.NotFoundException("Historial clínico no encontrado");
            }

            HistorialClinico historial = historialDoc.toObject(HistorialClinico.class);

            // Actualizar campos básicos
            historial.setMotivoConsulta(request.getMotivoConsulta());
            historial.setDiagnostico(request.getDiagnostico());
            historial.setTratamiento(request.getTratamiento());
            historial.setObservaciones(request.getObservaciones());

            // Actualizar servicios realizados y recalcular precio total
            double precioTotal = 0.0;

            if (request.getServiciosRealizados() != null) {
                List<ServicioRealizado> serviciosRealizados = new ArrayList<>();
                for (ServicioRealizadoRequest servicioRequest : request.getServiciosRealizados()) {
                    // Obtener detalles del servicio
                    ServiceVeterinaryDTOs.ServiceDetailResponse serviceDetail =
                            serviceVeterinaryService.getServiceDetails(servicioRequest.getServiceId());

                    // Calcular precio final del servicio
                    double precioServicio = servicioRequest.getPrecioPersonalizado() != null
                            ? servicioRequest.getPrecioPersonalizado()
                            : serviceDetail.getPrice();

                    // Crear registro del servicio
                    ServicioRealizado servicio = ServicioRealizado.builder()
                            .serviceId(serviceDetail.getId())
                            .serviceName(serviceDetail.getName())
                            .precioBase(serviceDetail.getPrice())
                            .precioPersonalizado(servicioRequest.getPrecioPersonalizado())
                            .notas(servicioRequest.getNotas())
                            .build();

                    serviciosRealizados.add(servicio);
                    precioTotal += precioServicio;
                }
                historial.setServiciosRealizados(serviciosRealizados);
            }

            // Actualizar servicios adicionales
            if (request.getServiciosAdicionales() != null) {
                List<ServicioAdicional> serviciosAdicionales = new ArrayList<>();
                for (ServicioAdicionalRequest servicioRequest : request.getServiciosAdicionales()) {
                    ServicioAdicional servicio = ServicioAdicional.builder()
                            .descripcion(servicioRequest.getDescripcion())
                            .precio(servicioRequest.getPrecio())
                            .notas(servicioRequest.getNotas())
                            .build();

                    serviciosAdicionales.add(servicio);
                    precioTotal += servicioRequest.getPrecio();
                }
                historial.setServiciosAdicionales(serviciosAdicionales);
            }

            // Actualizar precio total y fecha de actualización
            historial.setPrecioTotal(precioTotal);
            historial.setFechaActualizacion(new Date());

            // Guardar cambios
            historialRef.set(historial).get();

            return enrichHistorialResponse(historial);
        } catch (Exception e) {
            throw new CustomExceptions.ProcessingException("Error updating historial clinico: " + e.getMessage());
        }
    }

    public List<HistorialClinicoResponse> getHistorialByPetId(String petId) {
        try {
            QuerySnapshot querySnapshot = firestore.collection("historial_clinico")
                    .whereEqualTo("petId", petId)
                    .orderBy("fechaVisita", Query.Direction.DESCENDING)
                    .get()
                    .get();

            List<HistorialClinicoResponse> historialList = new ArrayList<>();
            for (DocumentSnapshot doc : querySnapshot.getDocuments()) {
                HistorialClinico historial = doc.toObject(HistorialClinico.class);
                historialList.add(enrichHistorialResponse(historial));
            }

            return historialList;
        } catch (Exception e) {
            throw new CustomExceptions.ProcessingException("Error fetching historial clinico: " + e.getMessage());
        }
    }

    public HistorialClinicoResponse getHistorialById(String historialId) {
        try {
            DocumentSnapshot doc = firestore.collection("historial_clinico")
                    .document(historialId)
                    .get()
                    .get();

            if (!doc.exists()) {
                throw new CustomExceptions.NotFoundException("Historial clínico no encontrado");
            }

            HistorialClinico historial = doc.toObject(HistorialClinico.class);
            return enrichHistorialResponse(historial);
        } catch (Exception e) {
            throw new CustomExceptions.ProcessingException("Error fetching historial clinico: " + e.getMessage());
        }
    }

    private HistorialClinicoResponse enrichHistorialResponse(HistorialClinico historial) {
        try {
            // Obtener información del veterinario
            UserDTOs.UserResponse veterinarian = userService.getUserById(historial.getVeterinarianId());

            // Obtener información de la mascota
            PetDTOs.PetResponse pet = petService.getPetById(historial.getPetId());

            // Obtener información del dueño
            UserDTOs.UserResponse owner = userService.getUserById(pet.getOwnerId());

            // Convertir servicios realizados
            List<ServicioRealizadoResponse> serviciosRealizadosResponse =
                    historial.getServiciosRealizados().stream()
                            .map(servicio -> ServicioRealizadoResponse.builder()
                                    .serviceId(servicio.getServiceId())
                                    .serviceName(servicio.getServiceName())
                                    .precioBase(servicio.getPrecioBase())
                                    .precioPersonalizado(servicio.getPrecioPersonalizado())
                                    .notas(servicio.getNotas())
                                    .build())
                            .collect(Collectors.toList());

            // Convertir servicios adicionales
            List<ServicioAdicionalResponse> serviciosAdicionalesResponse =
                    historial.getServiciosAdicionales().stream()
                            .map(servicio -> ServicioAdicionalResponse.builder()
                                    .descripcion(servicio.getDescripcion())
                                    .precio(servicio.getPrecio())
                                    .notas(servicio.getNotas())
                                    .build())
                            .collect(Collectors.toList());

            return HistorialClinicoResponse.builder()
                    .id(historial.getId())
                    .petId(historial.getPetId())
                    .veterinarianId(historial.getVeterinarianId())
                    .veterinarianName(veterinarian.getNombre() + " " + veterinarian.getApellido())
                    .petName(pet.getName())
                    .ownerName(owner.getNombre() + " " + owner.getApellido())
                    .fechaVisita(historial.getFechaVisita())
                    .motivoConsulta(historial.getMotivoConsulta())
                    .diagnostico(historial.getDiagnostico())
                    .tratamiento(historial.getTratamiento())
                    .observaciones(historial.getObservaciones())
                    .serviciosRealizados(serviciosRealizadosResponse)
                    .serviciosAdicionales(serviciosAdicionalesResponse)
                    .precioTotal(historial.getPrecioTotal())
                    .fechaCreacion(historial.getFechaCreacion())
                    .fechaActualizacion(historial.getFechaActualizacion())
                    .estado(historial.getEstado())
                    .build();
        } catch (Exception e) {
            throw new CustomExceptions.ProcessingException("Error enriching historial response: " + e.getMessage());
        }
    }
}

Estructura: service
Archivo: InventoryAlertService.java
--------------------------------------------------
package com.example.demo.service;

import com.example.demo.dto.InventoryDTOs;
import com.example.demo.exception.CustomExceptions;
import com.example.demo.model.*;
import com.google.cloud.firestore.*;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Service;

import java.util.*;
import java.util.stream.Collectors;

@Service
@Slf4j
public class InventoryAlertService {

    @Autowired
    private Firestore firestore;

    @Autowired
    private NotificationService notificationService;

    /**
     * Verifica periódicamente los niveles de stock
     */
    @Scheduled(fixedRate = 3600000) // Cada hora
    public void checkInventoryLevels() {
        try {
            QuerySnapshot snapshot = firestore.collection("inventory").get().get();

            for (DocumentSnapshot doc : snapshot.getDocuments()) {
                InventoryItem item = doc.toObject(InventoryItem.class);
                if (item != null && isLowStock(item)) {
                    createStockAlert(item);
                }
            }
        } catch (Exception e) {
            log.error("Error checking inventory levels: {}", e.getMessage());
        }
    }

    /**
     * Obtiene todos los productos con stock bajo
     */
    public List<InventoryDTOs.LowStockAlertDTO> getLowStockAlerts() {
        try {
            List<InventoryDTOs.LowStockAlertDTO> alerts = new ArrayList<>();
            QuerySnapshot snapshot = firestore.collection("inventory")
                    .get().get();

            for (DocumentSnapshot doc : snapshot.getDocuments()) {
                InventoryItem item = doc.toObject(InventoryItem.class);
                if (item != null && isLowStock(item)) {
                    alerts.add(createAlertDTO(item));
                }
            }
            return alerts;
        } catch (Exception e) {
            throw new CustomExceptions.ProcessingException("Error fetching low stock alerts");
        }
    }

    /**
     * Actualiza el umbral mínimo de un producto
     */
    public InventoryDTOs.InventoryItemResponse updateThreshold(String productId, int newThreshold) {
        try {
            if (newThreshold < 0) {
                throw new IllegalArgumentException("Threshold cannot be negative");
            }

            DocumentReference docRef = firestore.collection("inventory")
                    .document(productId);
            InventoryItem item = docRef.get().get().toObject(InventoryItem.class);

            if (item == null) {
                throw new CustomExceptions.NotFoundException("Product not found");
            }

            item.setMinThreshold(newThreshold);
            docRef.set(item).get();

            // Verificar si necesita generar alerta con el nuevo umbral
            if (isLowStock(item)) {
                createStockAlert(item);
            }

            return convertToResponse(item);
        } catch (Exception e) {
            throw new CustomExceptions.ProcessingException("Error updating threshold");
        }
    }

    /**
     * Crea una orden de reabastecimiento
     */
    public InventoryDTOs.RestockOrderDTO createRestockOrder(InventoryDTOs.CreateRestockOrderRequest request) {
        try {
            String currentUserId = SecurityContextHolder.getContext()
                    .getAuthentication().getName();

            RestockOrder order = RestockOrder.builder()
                    .id(UUID.randomUUID().toString())
                    .productId(request.getProductId())
                    .quantityToOrder(request.getQuantity())
                    .status(InventoryDTOs.OrderStatus.PENDING)
                    .orderDate(new Date())
                    .requestedBy(currentUserId)
                    .notes(request.getNotes())
                    .build();

            firestore.collection("restockOrders")
                    .document(order.getId())
                    .set(order)
                    .get();

            notifyRestockOrderCreated(order);
            return convertToRestockDTO(order);
        } catch (Exception e) {
            throw new CustomExceptions.ProcessingException("Error creating restock order");
        }
    }

    private boolean isLowStock(InventoryItem item) {
        return item.getQuantity() <= item.getMinThreshold();
    }

    private void createStockAlert(InventoryItem item) {
        try {
            LowStockAlert alert = LowStockAlert.builder()
                    .id(UUID.randomUUID().toString())
                    .productId(item.getId())
                    .productName(item.getName())
                    .currentStock(item.getQuantity())
                    .minThreshold(item.getMinThreshold())
                    .status(calculateAlertStatus(item))
                    .createdAt(new Date())
                    .isAcknowledged(false)
                    .build();

            // Guardar alerta
            firestore.collection("lowStockAlerts")
                    .document(alert.getId())
                    .set(alert)
                    .get();

            // Enviar notificación
            notificationService.sendLowStockAlert(alert);
        } catch (Exception e) {
            log.error("Error creating stock alert: {}", e.getMessage());
        }
    }

    private AlertStatus calculateAlertStatus(InventoryItem item) {
        double ratio = (double) item.getQuantity() / item.getMinThreshold();
        return ratio <= 0.5 ? AlertStatus.CRITICAL : AlertStatus.WARNING;
    }
    private InventoryDTOs.LowStockAlertDTO createAlertDTO(InventoryItem item) {
        return InventoryDTOs.LowStockAlertDTO.builder()
                .id(UUID.randomUUID().toString())
                .productId(item.getId())
                .productName(item.getName())
                .currentStock(item.getQuantity())
                .minThreshold(item.getMinThreshold())
                .status(calculateAlertStatus(item))
                .createdAt(new Date())
                .isAcknowledged(false)
                .build();
    }

    /**
     * Convierte un InventoryItem a InventoryItemResponse
     */
    private InventoryDTOs.InventoryItemResponse convertToResponse(InventoryItem item) {
        return InventoryDTOs.InventoryItemResponse.builder()
                .id(item.getId())
                .name(item.getName())
                .quantity(item.getQuantity())
                .minThreshold(item.getMinThreshold())
                .recommendedOrderQuantity(calculateRecommendedOrderQuantity(item))
                .dateAdded(item.getDateAdded())
                .lastUpdated(new Date())
                .status(calculateAlertStatus(item).toString())
                .needsReorder(isLowStock(item))
                .build();
    }

    /**
     * Convierte RestockOrder a RestockOrderDTO
     */
    private InventoryDTOs.RestockOrderDTO convertToRestockDTO(RestockOrder order) {
        return InventoryDTOs.RestockOrderDTO.builder()
                .id(order.getId())
                .productId(order.getProductId())
                .productName(order.getProductName())
                .currentStock(order.getCurrentStock())
                .quantityToOrder(order.getQuantityToOrder())
                .status(order.getStatus())
                .orderDate(order.getOrderDate())
                .requestedBy(order.getRequestedBy())
                .notes(order.getNotes())
                .build();
    }

    /**
     * Notifica la creación de una nueva orden de reabastecimiento
     */
    private void notifyRestockOrderCreated(RestockOrder order) {
        try {
            // Obtener el producto
            InventoryItem item = firestore.collection("inventory")
                    .document(order.getProductId())
                    .get()
                    .get()
                    .toObject(InventoryItem.class);

            if (item == null) {
                log.error("Producto no encontrado para notificación de reorden: {}",
                        order.getProductId());
                return;
            }

            String subject = "Nueva Orden de Reabastecimiento Creada";
            String content = generateRestockOrderEmailContent(order, item);

            // Enviar notificación a veterinarios
            List<String> veterinarianEmails = getUserEmailsByRole(Role.VETERINARIO);
            for (String email : veterinarianEmails) {
                notificationService.sendEmail(email, subject, content);
            }

            log.info("Notificación de orden de reabastecimiento enviada para producto: {}",
                    item.getName());
        } catch (Exception e) {
            log.error("Error enviando notificación de reabastecimiento: {}", e.getMessage());
        }
    }

    /**
     * Calcula la cantidad recomendada de reorden
     */
    private int calculateRecommendedOrderQuantity(InventoryItem item) {
        // Fórmula básica: Doble del umbral mínimo menos el stock actual
        int recommended = (item.getMinThreshold() * 2) - item.getQuantity();
        return Math.max(recommended, 1); // Mínimo 1 unidad
    }

    /**
     * Genera el contenido del email para órdenes de reabastecimiento
     */
    private String generateRestockOrderEmailContent(RestockOrder order, InventoryItem item) {
        return String.format("""
            <html>
            <body>
                <h2>Nueva Orden de Reabastecimiento</h2>
                <div style="background-color: #e3f2fd; padding: 20px; border-radius: 5px;">
                    <h3>Producto: %s</h3>
                    <p><strong>Stock Actual:</strong> %d unidades</p>
                    <p><strong>Cantidad Solicitada:</strong> %d unidades</p>
                    <p><strong>Solicitado por:</strong> %s</p>
                    <p><strong>Notas:</strong> %s</p>
                </div>
                <p>Por favor, revisa y aprueba esta orden lo antes posible.</p>
                <a href="http://tu-aplicacion.com/inventory/restock-orders/%s" 
                   style="background-color: #4CAF50; color: white; padding: 10px 20px; 
                          text-decoration: none; border-radius: 5px;">
                    Ver Orden
                </a>
            </body>
            </html>
            """,
                item.getName(),
                order.getCurrentStock(),
                order.getQuantityToOrder(),
                order.getRequestedBy(),
                order.getNotes(),
                order.getId()
        );
    }

    private List<String> getUserEmailsByRole(Role role) {
        try {
            return firestore.collection("users")
                    .whereArrayContains("roles", role)
                    .get()
                    .get()
                    .getDocuments()
                    .stream()
                    .map(doc -> doc.getString("email"))
                    .filter(Objects::nonNull)
                    .collect(Collectors.toList());
        } catch (Exception e) {
            log.error("Error obteniendo emails por rol: {}", e.getMessage());
            return new ArrayList<>();
        }
    }
}

Estructura: service
Archivo: InventoryService.java
--------------------------------------------------
package com.example.demo.service;

import com.example.demo.dto.InventoryDTOs;
import com.example.demo.dto.InventoryDTOs.*;
import com.example.demo.dto.PaginatedResponse;
import com.example.demo.dto.PaginationRequest;
import com.example.demo.exception.CustomExceptions;
import com.example.demo.model.AlertStatus;
import com.example.demo.model.InventoryItem;
import com.example.demo.model.RestockOrder;
import com.example.demo.util.FirestorePaginationUtils;
import com.google.cloud.firestore.*;
import com.google.firebase.cloud.FirestoreClient;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Service;

import java.util.*;
import java.util.concurrent.ExecutionException;
import java.util.stream.Collectors;

@Service
@Slf4j
public class InventoryService {
    @Autowired
    private Firestore firestore;

    private Firestore getFirestore() {
        return FirestoreClient.getFirestore();
    }

    public PaginatedResponse<InventoryItemResponse> getAllItems(PaginationRequest request) {
        try {
            CollectionReference inventoryRef = firestore.collection("inventory");
            Query query = inventoryRef;

            // Aplicar filtros
            if (request.getFilterBy() != null && request.getFilterValue() != null) {
                query = query.whereEqualTo(request.getFilterBy(), request.getFilterValue());
            }

            // Ordenamiento
            Query.Direction direction = request.getSortDirection().equalsIgnoreCase("DESC")
                    ? Query.Direction.DESCENDING
                    : Query.Direction.ASCENDING;
            query = query.orderBy(request.getSortBy(), direction);

            // Paginación
            query = query.offset(request.getPage() * request.getSize())
                    .limit(request.getSize());

            QuerySnapshot querySnapshot = query.get().get();

            List<InventoryItemResponse> items = querySnapshot.getDocuments().stream()
                    .map(doc -> {
                        InventoryItem item = doc.toObject(InventoryItem.class);
                        return convertToInventoryItemResponse(item);
                    })
                    .collect(Collectors.toList());

            long totalElements = FirestorePaginationUtils.getTotalElements(inventoryRef);

            return PaginatedResponse.of(items, request, totalElements);
        } catch (Exception e) {
            throw new CustomExceptions.ProcessingException(
                    "Error fetching inventory items: " + e.getMessage());
        }
    }
    public PaginatedResponse<InventoryItemResponse> searchByName(String searchTerm, PaginationRequest request) {
        try {
            CollectionReference inventoryRef = firestore.collection("inventory");
            Query query = inventoryRef;

            // Búsqueda case-insensitive por nombre
            if (searchTerm != null && !searchTerm.isEmpty()) {
                // Límite superior para la búsqueda
                String upperBound = searchTerm + "\uf8ff";
                query = query.whereGreaterThanOrEqualTo("name", searchTerm)
                        .whereLessThanOrEqualTo("name", upperBound);
            }

            // Aplicar ordenamiento
            Query.Direction direction = request.getSortDirection().equalsIgnoreCase("DESC") ?
                    Query.Direction.DESCENDING : Query.Direction.ASCENDING;
            query = query.orderBy("name", direction);

            // Paginación
            query = query.offset(request.getPage() * request.getSize())
                    .limit(request.getSize());

            QuerySnapshot querySnapshot = query.get().get();
            List<InventoryItemResponse> items = querySnapshot.getDocuments().stream()
                    .map(doc -> {
                        InventoryItem item = doc.toObject(InventoryItem.class);
                        return convertToInventoryItemResponse(item);
                    })
                    .collect(Collectors.toList());

            // Obtener total de elementos
            long totalElements = FirestorePaginationUtils.getTotalElements(inventoryRef);

            return PaginatedResponse.of(items, request, totalElements);
        } catch (Exception e) {
            throw new CustomExceptions.ProcessingException("Error searching inventory items: " + e.getMessage());
        }
    }


    public InventoryItemResponse addItem(AddInventoryItemRequest request) {
        InventoryItem item = new InventoryItem();
        item.setId(UUID.randomUUID().toString());
        item.setName(request.getName());
        item.setQuantity(request.getQuantity());
        item.setMinThreshold(request.getMinThreshold());
        item.setDateAdded(new Date());
        item.setPrice(request.getPrice());

        try {
            getFirestore().collection("inventory").document(item.getId()).set(item).get();
            return convertToInventoryItemResponse(item);
        } catch (InterruptedException | ExecutionException e) {
            throw new CustomExceptions.ProcessingException("Error adding inventory item: " + e.getMessage());
        }
    }

    public InventoryItemResponse updateItem(String id, UpdateInventoryItemRequest request) {
        try {
            InventoryItem item = getFirestore().collection("inventory").document(id).get().get().toObject(InventoryItem.class);
            if (item == null) {
                throw new CustomExceptions.NotFoundException("Inventory item not found with id: " + id);
            }
            item.setQuantity(request.getQuantity());
            item.setPrice(request.getPrice());
            item.setMinThreshold(request.getMinThreshold());

            getFirestore().collection("inventory").document(id).set(item).get();
            return convertToInventoryItemResponse(item);
        } catch (InterruptedException | ExecutionException e) {
            throw new CustomExceptions.ProcessingException("Error updating inventory item: " + e.getMessage());
        }
    }

    public PaginatedResponse<LowStockAlertDTO> getLowStockItems(PaginationRequest request) {
        try {
            if (request.getSortBy() == null) request.setSortBy("name");
            if (request.getSortDirection() == null) request.setSortDirection("ASC");
            if (request.getSize() == 0) request.setSize(10);

            CollectionReference inventoryRef = firestore.collection("inventory");

            // Obtener todos los documentos del inventario
            QuerySnapshot querySnapshot = inventoryRef.get().get();

            // Filtrar en memoria los items con stock bajo
            List<LowStockAlertDTO> alerts = querySnapshot.getDocuments().stream()
                    .map(doc -> doc.toObject(InventoryItem.class))
                    .filter(item -> item != null && item.getQuantity() <= item.getMinThreshold())
                    .map(this::createAlertDTO)
                    .collect(Collectors.toList());

            // Aplicar paginación manual
            int start = request.getPage() * request.getSize();
            int end = Math.min(start + request.getSize(), alerts.size());
            List<LowStockAlertDTO> paginatedAlerts = alerts.subList(start, end);

            return PaginatedResponse.of(paginatedAlerts, request, alerts.size());
        } catch (Exception e) {
            throw new CustomExceptions.ProcessingException("Error fetching low stock items: " + e.getMessage());
        }
    }
    /**
     * Obtiene el total de items con bajo stock
     */
    private long getTotalLowStockItems(CollectionReference inventoryRef) throws ExecutionException, InterruptedException {
        return inventoryRef
                .whereGreaterThan("minThreshold", 0)
                .whereLessThanOrEqualTo("quantity", "minThreshold")
                .get()
                .get()
                .size();
    }



    private InventoryItemResponse convertToInventoryItemResponse(InventoryItem item) {
        InventoryItemResponse response = new InventoryItemResponse();
        response.setId(item.getId());
        response.setName(item.getName());
        response.setQuantity(item.getQuantity());
        response.setMinThreshold(item.getMinThreshold());
        response.setDateAdded(item.getDateAdded());
        response.setPrice(item.getPrice());
        return response;
    }
    private LowStockAlertDTO createAlertDTO(InventoryItem item) {
        return LowStockAlertDTO.builder()
                .id(UUID.randomUUID().toString())
                .productId(item.getId())
                .productName(item.getName())
                .currentStock(item.getQuantity())
                .minThreshold(item.getMinThreshold())
                .status(item.getQuantity() <= 0 ? AlertStatus.CRITICAL : AlertStatus.WARNING)
                .createdAt(new Date())
                .isAcknowledged(false)
                .build();
    }
    private AlertStatus calculateAlertStatus(InventoryItem item) {
        if (item.getQuantity() <= 0) {
            return AlertStatus.CRITICAL;
        } else if (item.getQuantity() <= item.getMinThreshold()) {
            double ratio = (double) item.getQuantity() / item.getMinThreshold();
            return ratio <= 0.5 ? AlertStatus.CRITICAL : AlertStatus.WARNING;
        }
        return AlertStatus.OK;
    }
    public InventoryItemResponse updateThreshold(String productId, int newThreshold) {
        try {
            DocumentReference docRef = firestore.collection("inventory").document(productId);
            DocumentSnapshot doc = docRef.get().get();

            if (!doc.exists()) {
                throw new CustomExceptions.NotFoundException("Product not found");
            }

            InventoryItem item = doc.toObject(InventoryItem.class);
            if (item != null) {
                item.setMinThreshold(newThreshold);
                docRef.set(item).get();
                return convertToInventoryItemResponse(item);
            }

            throw new CustomExceptions.ProcessingException("Error updating threshold");
        } catch (Exception e) {
            throw new CustomExceptions.ProcessingException(
                    "Error updating threshold: " + e.getMessage());
        }
    }
    public RestockOrderDTO createRestockOrder(CreateRestockOrderRequest request) {
        try {
            String currentUserId = SecurityContextHolder.getContext()
                    .getAuthentication().getName();

            // Verificar que el producto existe
            DocumentSnapshot productDoc = firestore.collection("inventory")
                    .document(request.getProductId())
                    .get().get();

            if (!productDoc.exists()) {
                throw new CustomExceptions.NotFoundException("Product not found");
            }

            InventoryItem product = productDoc.toObject(InventoryItem.class);

            RestockOrder order = RestockOrder.builder()
                    .id(UUID.randomUUID().toString())
                    .productId(request.getProductId())
                    .productName(product.getName())
                    .currentStock(product.getQuantity())
                    .quantityToOrder(request.getQuantity())
                    .status(InventoryDTOs.OrderStatus.PENDING)
                    .orderDate(new Date())
                    .requestedBy(currentUserId)
                    .notes(request.getNotes())
                    .build();

            firestore.collection("restockOrders")
                    .document(order.getId())
                    .set(order)
                    .get();

            return convertToRestockDTO(order);
        } catch (Exception e) {
            throw new CustomExceptions.ProcessingException(
                    "Error creating restock order: " + e.getMessage());
        }
    }
    public InventoryItemResponse getItemById(String id) {
        try {
            // Obtener el documento del inventario
            DocumentSnapshot doc = firestore.collection("inventory")
                    .document(id)
                    .get()
                    .get();

            if (!doc.exists()) {
                throw new CustomExceptions.NotFoundException("Item not found with id: " + id);
            }

            InventoryItem item = doc.toObject(InventoryItem.class);

            // Verificar si el item es favorito para el usuario actual
            boolean isFavorite = checkIfFavorite(id);

            return convertToResponse(item, isFavorite);

        } catch (Exception e) {
            throw new CustomExceptions.ProcessingException(
                    "Error fetching inventory item: " + e.getMessage());
        }
    }
    private InventoryItemResponse convertToResponse(InventoryItem item, boolean isFavorite) {
        return InventoryItemResponse.builder()
                .id(item.getId())
                .name(item.getName())
                .quantity(item.getQuantity())
                .price(item.getPrice())
                .isFavorite(isFavorite)
                .build();
    }
    private RestockOrderDTO convertToRestockDTO(RestockOrder order) {
        if (order == null) return null;

        return RestockOrderDTO.builder()
                .id(order.getId())
                .productId(order.getProductId())
                .productName(order.getProductName())
                .currentStock(order.getCurrentStock())
                .quantityToOrder(order.getQuantityToOrder())
                .status(order.getStatus())
                .orderDate(order.getOrderDate())
                .requestedBy(order.getRequestedBy())
                .notes(order.getNotes())
                .build();
    }
    private boolean checkIfFavorite(String itemId) {
        String userId = SecurityContextHolder.getContext().getAuthentication().getName();
        try {
            // Buscar en la colección de favoritos
            QuerySnapshot snapshot = firestore.collection("favorites")
                    .whereEqualTo("userId", userId)
                    .whereEqualTo("itemId", itemId)
                    .whereEqualTo("itemType", "PRODUCT")
                    .get()
                    .get();

            return !snapshot.isEmpty();
        } catch (Exception e) {
            return false;
        }
    }


    public InventoryItem addInventoryItem(InventoryItem newItem) {
        try {
            // Generamos un ID único para el nuevo item
            String itemId = UUID.randomUUID().toString();
            newItem.setId(itemId);

            // Establecemos fechas de creación/actualización
            Date currentDate = new Date();
            newItem.setDateAdded(currentDate);
            newItem.setLastUpdated(currentDate);

            // Validamos los datos del item
            validateInventoryItem(newItem);

            // Guardamos en Firestore
            DocumentReference docRef = firestore.collection("inventory").document(itemId);
            docRef.set(newItem).get();

            return newItem;

        } catch (Exception e) {
            throw new CustomExceptions.ProcessingException("Error al agregar item al inventario: " + e.getMessage());
        }
    }

    /**
     * Actualiza un item existente en el inventario
     * @param itemId ID del item a actualizar
     * @param updatedItem Datos actualizados del item
     * @return InventoryItem actualizado
     */
    public InventoryItem updateInventoryItem(String itemId, InventoryItem updatedItem) {
        try {
            // Verificamos si el item existe
            DocumentSnapshot existingItemDoc = firestore.collection("inventory")
                    .document(itemId)
                    .get()
                    .get();

            if (!existingItemDoc.exists()) {
                throw new CustomExceptions.NotFoundException("Item no encontrado con ID: " + itemId);
            }

            // Obtener el item existente
            InventoryItem existingItem = existingItemDoc.toObject(InventoryItem.class);

            // Mantener los campos existentes y actualizar solo los nuevos
            InventoryItem mergedItem = new InventoryItem();
            mergedItem.setId(itemId);
            mergedItem.setName(existingItem.getName()); // Mantener nombre original
            mergedItem.setDateAdded(existingItem.getDateAdded());
            mergedItem.setLastUpdated(new Date());

            // Actualizar solo los campos que vienen en el request
            mergedItem.setQuantity(updatedItem.getQuantity());
            mergedItem.setMinThreshold(updatedItem.getMinThreshold());
            mergedItem.setPrice(updatedItem.getPrice());

            // Manejar recommendedOrderQuantity especialmente
            if (updatedItem.getRecommendedOrderQuantity() > 0) {
                mergedItem.setRecommendedOrderQuantity(updatedItem.getRecommendedOrderQuantity());
            } else {
                mergedItem.setRecommendedOrderQuantity(existingItem.getRecommendedOrderQuantity());
            }

            // Validar los datos actualizados
            validateInventoryItem(mergedItem);

            // Actualizar en Firestore
            firestore.collection("inventory")
                    .document(itemId)
                    .set(mergedItem)
                    .get();

            return mergedItem;

        } catch (CustomExceptions.NotFoundException e) {
            throw e;
        } catch (Exception e) {
            throw new CustomExceptions.ProcessingException("Error al actualizar item del inventario: " + e.getMessage());
        }
    }

    /**
     * Valida los datos de un item de inventario
     * @param item Item a validar
     * @throws CustomExceptions.ProcessingException si la validación falla
     */
    private void validateInventoryItem(InventoryItem item) {
        if (item.getName() == null || item.getName().trim().isEmpty()) {
            throw new CustomExceptions.ProcessingException("El nombre del item es requerido");
        }

        if (item.getQuantity() < 0) {
            throw new CustomExceptions.ProcessingException("La cantidad no puede ser negativa");
        }

        if (item.getMinThreshold() < 0) {
            throw new CustomExceptions.ProcessingException("El umbral mínimo no puede ser negativo");
        }

        if (item.getPrice() < 0) {
            throw new CustomExceptions.ProcessingException("El precio no puede ser negativo");
        }

        // Agregamos validación para el recommendedOrderQuantity
        if (item.getRecommendedOrderQuantity() < 0) {
            throw new CustomExceptions.ProcessingException("La cantidad recomendada de pedido no puede ser negativa");
        }
    }



}

Estructura: service
Archivo: NotificationService.java
--------------------------------------------------
package com.example.demo.service;


import com.example.demo.dto.PetDTOs;
import com.example.demo.dto.UserDTOs;
import com.example.demo.model.AlertStatus;
import com.example.demo.model.LowStockAlert;
import com.example.demo.model.Role;

import com.google.cloud.firestore.Firestore;
import com.google.cloud.firestore.QuerySnapshot;
import jakarta.mail.internet.MimeMessage;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import org.springframework.mail.javamail.JavaMailSender;
import org.springframework.mail.javamail.MimeMessageHelper;


import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.Objects;
import java.util.concurrent.ExecutionException;
import java.util.stream.Collectors;

@Service
@Slf4j
public class NotificationService {

    @Autowired
    private JavaMailSender emailSender;

    @Value("${spring.mail.username}")
    private String fromEmail;

    @Autowired
    private Firestore firestore;

    @Autowired
    private PetService petService;

    @Autowired
    private UserService userService;

    public void sendLowStockAlert(LowStockAlert alert) {
        try {
            // Obtener emails de recepcionistas
            List<String> recipientEmails = getUserEmailsByRole(Role.RECEPCIONISTA);

            String subject = "Alerta de Stock Bajo: " + alert.getProductName();
            String content = generateLowStockEmailContent(alert);

            // Enviar email a cada recepcionista
            for (String email : recipientEmails) {
                sendEmail(email, subject, content);
            }
        } catch (Exception e) {
            log.error("Error sending low stock alert: {}", e.getMessage());
        }
    }

    void sendEmail(String to, String subject, String content) {
        try {
            MimeMessage message = emailSender.createMimeMessage();
            MimeMessageHelper helper = new MimeMessageHelper(message, true);

            helper.setFrom(fromEmail);
            helper.setTo(to);
            helper.setSubject(subject);
            helper.setText(content, true);
            log.info("Enviando correo...");
            emailSender.send(message);
            log.info("Alert email sent to: {}", to);
        } catch (Exception e) {
            log.error("Error sending email: {}", e.getMessage());
        }
    }

    private String generateLowStockEmailContent(LowStockAlert alert) {
        return """
            <html>
            <body>
                <h2>Alerta de Stock Bajo</h2>
                <div style="background-color: %s; padding: 20px; border-radius: 5px;">
                    <h3>Producto: %s</h3>
                    <p>Stock Actual: %d</p>
                    <p>Stock Mínimo: %d</p>
                    <p>Estado: %s</p>
                </div>
                <p>Se requiere realizar un nuevo pedido.</p>
                <a href="http://tu-aplicacion.com/inventory/restock/%s">Crear Orden de Reabastecimiento</a>
            </body>
            </html>
            """.formatted(
                alert.getStatus() == AlertStatus.CRITICAL ? "#ffebee" : "#fff3e0",
                alert.getProductName(),
                alert.getCurrentStock(),
                alert.getMinThreshold(),
                alert.getStatus(),
                alert.getProductId()
        );
    }
    /**
     * Obtiene los emails de los usuarios que tienen un rol específico
     */
    public List<String> getUserEmailsByRole(Role role) {
        try {
            // Consultar todos los usuarios con el rol especificado
            QuerySnapshot querySnapshot = firestore.collection("users")
                    .whereArrayContains("roles", role)
                    .get()
                    .get();

            // Extraer y retornar los emails
            return querySnapshot.getDocuments().stream()
                    .map(doc -> doc.getString("email"))
                    .filter(Objects::nonNull)
                    .collect(Collectors.toList());

        } catch (InterruptedException | ExecutionException e) {
            log.error("Error obteniendo emails para el rol {}: {}", role, e.getMessage());
            return new ArrayList<>(); // Retornar lista vacía en caso de error
        }
    }
    //PARTE DE CITAS
    public void sendAppointmentRescheduledNotification(String clientId, String petId, Date oldDate, Date newDate) {
        try {
            PetDTOs.PetResponse pet = petService.getPetById(petId);
            UserDTOs.UserResponse client = userService.getUserById(clientId);

            String subject = "Cita reprogramada para " + pet.getName();
            String content = generateRescheduledAppointmentEmail(pet.getName(), oldDate, newDate);

            sendEmail(client.getEmail(), subject, content);
        } catch (Exception e) {
            log.error("Error sending appointment rescheduled notification: {}", e.getMessage());
        }
    }

    public void sendVeterinarianAppointmentRescheduledNotification(String veterinarianId, String petId, Date oldDate, Date newDate) {
        try {
            PetDTOs.PetResponse pet = petService.getPetById(petId);
            UserDTOs.UserResponse vet = userService.getUserById(veterinarianId);

            String subject = "Cita reprogramada - " + pet.getName();
            String content = generateVetRescheduledAppointmentEmail(pet.getName(), oldDate, newDate);

            sendEmail(vet.getEmail(), subject, content);
        } catch (Exception e) {
            log.error("Error sending vet appointment rescheduled notification: {}", e.getMessage());
        }
    }

    public void sendAppointmentCancelledNotification(String clientId, String petId, Date date) {
        try {
            PetDTOs.PetResponse pet = petService.getPetById(petId);
            UserDTOs.UserResponse client = userService.getUserById(clientId);

            String subject = "Cita cancelada - " + pet.getName();
            String content = generateCancelledAppointmentEmail(pet.getName(), date);

            sendEmail(client.getEmail(), subject, content);
        } catch (Exception e) {
            log.error("Error sending appointment cancelled notification: {}", e.getMessage());
        }
    }

    public void sendVeterinarianAppointmentCancelledNotification(String veterinarianId, String petId, Date date) {
        try {
            PetDTOs.PetResponse pet = petService.getPetById(petId);
            UserDTOs.UserResponse vet = userService.getUserById(veterinarianId);

            String subject = "Cita cancelada - " + pet.getName();
            String content = generateVetCancelledAppointmentEmail(pet.getName(), date);

            sendEmail(vet.getEmail(), subject, content);
        } catch (Exception e) {
            log.error("Error sending vet appointment cancelled notification: {}", e.getMessage());
        }
    }

    private String generateRescheduledAppointmentEmail(String petName, Date oldDate, Date newDate) {
        return String.format("""
            <html>
            <body>
                <h2>Cita Reprogramada</h2>
                <p>La cita para %s ha sido reprogramada:</p>
                <ul>
                    <li><strong>Fecha anterior:</strong> %s</li>
                    <li><strong>Nueva fecha:</strong> %s</li>
                </ul>
                <p>Si necesita hacer algún cambio adicional, por favor contáctenos.</p>
            </body>
            </html>
            """,
                petName,
                formatDate(oldDate),
                formatDate(newDate)
        );
    }

    private String generateVetRescheduledAppointmentEmail(String petName, Date oldDate, Date newDate) {
        return String.format("""
            <html>
            <body>
                <h2>Cita Reprogramada - Actualización</h2>
                <p>Una cita ha sido reprogramada:</p>
                <ul>
                    <li><strong>Paciente:</strong> %s</li>
                    <li><strong>Fecha anterior:</strong> %s</li>
                    <li><strong>Nueva fecha:</strong> %s</li>
                </ul>
            </body>
            </html>
            """,
                petName,
                formatDate(oldDate),
                formatDate(newDate)
        );
    }

    private String generateCancelledAppointmentEmail(String petName, Date date) {
        return String.format("""
            <html>
            <body>
                <h2>Cita Cancelada</h2>
                <p>La cita para %s programada para el %s ha sido cancelada.</p>
                <p>Si desea programar una nueva cita, por favor contáctenos.</p>
            </body>
            </html>
            """,
                petName,
                formatDate(date)
        );
    }

    private String generateVetCancelledAppointmentEmail(String petName, Date date) {
        return String.format("""
            <html>
            <body>
                <h2>Cita Cancelada - Notificación</h2>
                <p>La siguiente cita ha sido cancelada:</p>
                <ul>
                    <li><strong>Paciente:</strong> %s</li>
                    <li><strong>Fecha:</strong> %s</li>
                </ul>
            </body>
            </html>
            """,
                petName,
                formatDate(date)
        );
    }
    private String formatDate(Date date) {
        SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yyyy HH:mm");
        return sdf.format(date);
    }
    String generateNewAppointmentEmail(String petName, Date appointmentDate, String vetName) {
        return String.format("""
        <html>
        <body>
            <h2>Nueva Cita Programada</h2>
            <p>Se ha programado una nueva cita para %s:</p>
            <ul>
                <li><strong>Fecha:</strong> %s</li>
                <li><strong>Veterinario:</strong> Dr. %s</li>
            </ul>
            <p>Por favor, llegue 10 minutos antes de la hora programada.</p>
        </body>
        </html>
        """,
                petName,
                formatDate(appointmentDate),
                vetName
        );
    }

    String generateNewAppointmentVetEmail(String petName, Date appointmentDate, String clientName) {
        return String.format("""
        <html>
        <body>
            <h2>Nueva Cita Programada</h2>
            <p>Se ha programado una nueva cita:</p>
            <ul>
                <li><strong>Paciente:</strong> %s</li>
                <li><strong>Dueño:</strong> %s</li>
                <li><strong>Fecha:</strong> %s</li>
            </ul>
        </body>
        </html>
        """,
                petName,
                clientName,
                formatDate(appointmentDate)
        );
    }
}

Estructura: service
Archivo: PaymentHistoryService.java
--------------------------------------------------
package com.example.demo.service;

import com.example.demo.dto.PaginatedResponse;
import com.example.demo.dto.PaginationRequest;
import com.example.demo.dto.PaymentHistoryDTOs.*;
import com.example.demo.exception.CustomExceptions;
import com.example.demo.model.HistorialClinico;
import com.google.cloud.firestore.*;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Service;

import java.util.*;
import java.util.stream.Collectors;

@Slf4j
@Service
public class PaymentHistoryService {

    @Autowired
    private Firestore firestore;

    @Autowired
    private UserService userService;

    @Autowired
    private PetService petService;

    /**
     * Obtiene el historial de pagos filtrado y paginado para el cliente actual
     */
    public PaginatedResponse<PaymentHistoryResponse> getPaymentHistory(
            PaymentHistoryFilterRequest filterRequest,
            PaginationRequest paginationRequest) {

        try {
            // Obtener ID del cliente actual
            String clientId = SecurityContextHolder.getContext().getAuthentication().getName();

            // Log para debugging
            log.info("Buscando historial para cliente: {}", clientId);

            // Obtener todas las mascotas del cliente
            List<String> clientPetIds = petService.getCurrentUserPets().stream()
                    .map(pet -> pet.getId())
                    .collect(Collectors.toList());

            log.info("Mascotas encontradas: {}", clientPetIds);

            if (clientPetIds.isEmpty()) {
                return PaginatedResponse.of(new ArrayList<>(), paginationRequest, 0);
            }

            // Construir query base
            CollectionReference historicalRef = firestore.collection("historial_clinico");
            Query query = historicalRef.whereIn("petId", clientPetIds);

            // Log para debugging
            log.info("Aplicando filtros - Fecha inicio: {}, Fecha fin: {}",
                    filterRequest.getFechaInicio(), filterRequest.getFechaFin());

            // Aplicar filtros
            if (filterRequest.getFechaInicio() != null) {
                query = query.whereGreaterThanOrEqualTo("fechaVisita", filterRequest.getFechaInicio());
            }
            if (filterRequest.getFechaFin() != null) {
                query = query.whereLessThanOrEqualTo("fechaVisita", filterRequest.getFechaFin());
            }
            if (filterRequest.getPetId() != null) {
                query = query.whereEqualTo("petId", filterRequest.getPetId());
            }

            // Ordenar por fecha
            query = query.orderBy("fechaVisita", Query.Direction.DESCENDING);

            // Aplicar paginación
            query = query.offset(paginationRequest.getPage() * paginationRequest.getSize())
                    .limit(paginationRequest.getSize());

            // Ejecutar query y obtener resultados
            QuerySnapshot querySnapshot = query.get().get();

            log.info("Documentos encontrados: {}", querySnapshot.size());

            // Convertir documentos a DTOs
            List<PaymentHistoryResponse> payments = querySnapshot.getDocuments().stream()
                    .map(doc -> {
                        HistorialClinico historial = doc.toObject(HistorialClinico.class);
                        if (historial != null) {
                            historial.setId(doc.getId()); // Importante: establecer el ID del documento
                        }
                        return convertToPaymentResponse(historial);
                    })
                    .filter(payment -> isWithinMontoRange(payment, filterRequest))
                    .collect(Collectors.toList());

            // Obtener total de elementos
            long totalElements = historicalRef
                    .whereIn("petId", clientPetIds)
                    .get()
                    .get()
                    .size();

            log.info("Total de elementos encontrados: {}", totalElements);

            return new PaginatedResponse<>(
                    payments,
                    paginationRequest.getPage(),
                    paginationRequest.getSize(),
                    totalElements,
                    (int) Math.ceil((double) totalElements / paginationRequest.getSize())
            );

        } catch (Exception e) {
            log.error("Error obteniendo historial de pagos: ", e);
            throw new CustomExceptions.ProcessingException(
                    "Error al obtener historial de pagos: " + e.getMessage());
        }
    }

    /**
     * Obtiene el detalle completo de un pago específico
     */
    public PaymentHistoryResponse getPaymentDetail(String paymentId) {
        try {
            DocumentSnapshot doc = firestore.collection("historial_clinico")
                    .document(paymentId)
                    .get()
                    .get();

            if (!doc.exists()) {
                throw new CustomExceptions.NotFoundException("Payment record not found");
            }

            HistorialClinico historial = doc.toObject(HistorialClinico.class);

            // Verificar que la mascota pertenece al cliente actual
            String clientId = SecurityContextHolder.getContext().getAuthentication().getName();
            if (!isPetOwner(historial.getPetId(), clientId)) {
                throw new CustomExceptions.UnauthorizedException("Unauthorized to view this payment");
            }

            return convertToPaymentResponse(historial);

        } catch (Exception e) {
            log.error("Error getting payment detail: ", e);
            throw new CustomExceptions.ProcessingException(
                    "Error fetching payment detail: " + e.getMessage());
        }
    }

    /**
     * Obtiene el resumen de gastos por período
     */
    public Map<String, Object> getPaymentSummary(Date fechaInicio, Date fechaFin) {
        try {
            String clientId = SecurityContextHolder.getContext().getAuthentication().getName();
            List<String> clientPetIds = petService.getCurrentUserPets().stream()
                    .map(pet -> pet.getId())
                    .collect(Collectors.toList());

            QuerySnapshot querySnapshot = firestore.collection("historial_clinico")
                    .whereIn("petId", clientPetIds)
                    .whereGreaterThanOrEqualTo("fechaVisita", fechaInicio)
                    .whereLessThanOrEqualTo("fechaVisita", fechaFin)
                    .get()
                    .get();

            double totalGastado = 0.0;
            Map<String, Double> gastosPorMascota = new HashMap<>();
            Map<String, Double> gastosPorServicio = new HashMap<>();

            for (DocumentSnapshot doc : querySnapshot.getDocuments()) {
                HistorialClinico historial = doc.toObject(HistorialClinico.class);
                if (historial != null) {
                    double montoHistorial = historial.getPrecioTotal();
                    totalGastado += montoHistorial;

                    // Acumular por mascota
                    gastosPorMascota.merge(historial.getPetId(), montoHistorial, Double::sum);

                    // Acumular por tipo de servicio
                    procesarServiciosParaResumen(historial, gastosPorServicio);
                }
            }

            return Map.of(
                    "totalGastado", totalGastado,
                    "gastosPorMascota", gastosPorMascota,
                    "gastosPorServicio", gastosPorServicio
            );

        } catch (Exception e) {
            log.error("Error getting payment summary: ", e);
            throw new CustomExceptions.ProcessingException(
                    "Error calculating payment summary: " + e.getMessage());
        }
    }

    /**
     * Métodos auxiliares
     */
    private PaymentHistoryResponse convertToPaymentResponse(HistorialClinico historial) {
        try {
            return PaymentHistoryResponse.builder()
                    .id(historial.getId())
                    .fecha(historial.getFechaVisita())
                    .petId(historial.getPetId())
                    .petName(petService.getPetById(historial.getPetId()).getName())
                    .montoTotal(historial.getPrecioTotal())
                    .serviciosRealizados(convertirServiciosRealizados(historial))
                    .serviciosAdicionales(convertirServiciosAdicionales(historial))
                    .veterinarioNombre(obtenerNombreVeterinario(historial.getVeterinarianId()))
                    .razon(historial.getMotivoConsulta())
                    .build();
        } catch (Exception e) {
            log.error("Error converting payment response: ", e);
            throw new CustomExceptions.ProcessingException("Error converting payment data");
        }
    }

    private List<ServicioDetalleDTO> convertirServiciosRealizados(HistorialClinico historial) {
        return historial.getServiciosRealizados().stream()
                .map(servicio -> ServicioDetalleDTO.builder()
                        .servicioId(servicio.getServiceId())
                        .nombre(servicio.getServiceName())
                        .precioBase(servicio.getPrecioBase())
                        .precioPersonalizado(servicio.getPrecioPersonalizado())
                        .notas(servicio.getNotas())
                        .build())
                .collect(Collectors.toList());
    }

    private List<ServicioAdicionalDTO> convertirServiciosAdicionales(HistorialClinico historial) {
        return historial.getServiciosAdicionales().stream()
                .map(servicio -> ServicioAdicionalDTO.builder()
                        .descripcion(servicio.getDescripcion())
                        .precio(servicio.getPrecio())
                        .notas(servicio.getNotas())
                        .build())
                .collect(Collectors.toList());
    }
    // Continuación de PaymentHistoryService.java

    /**
     * Verifica si el monto del pago está dentro del rango especificado en el filtro
     */
    private boolean isWithinMontoRange(PaymentHistoryResponse payment, PaymentHistoryFilterRequest filter) {
        if (filter.getMontoMinimo() != null && payment.getMontoTotal() < filter.getMontoMinimo()) {
            return false;
        }
        if (filter.getMontoMaximo() != null && payment.getMontoTotal() > filter.getMontoMaximo()) {
            return false;
        }
        return true;
    }

    /**
     * Verifica si el usuario actual es dueño de la mascota
     */
    private boolean isPetOwner(String petId, String userId) throws Exception {
        return petService.getPetById(petId).getOwnerId().equals(userId);
    }

    /**
     * Obtiene el nombre completo del veterinario
     */
    private String obtenerNombreVeterinario(String veterinarianId) {
        try {
            var veterinario = userService.getUserById(veterinarianId);
            return String.format("Dr. %s %s", veterinario.getNombre(), veterinario.getApellido());
        } catch (Exception e) {
            log.warn("Error obteniendo nombre del veterinario {}: {}", veterinarianId, e.getMessage());
            return "Veterinario no disponible";
        }
    }

    /**
     * Procesa los servicios para el resumen de gastos
     */
    private void procesarServiciosParaResumen(HistorialClinico historial, Map<String, Double> gastosPorServicio) {
        // Procesar servicios regulares
        if (historial.getServiciosRealizados() != null) {
            historial.getServiciosRealizados().forEach(servicio -> {
                double precio = servicio.getPrecioPersonalizado() != null ?
                        servicio.getPrecioPersonalizado() :
                        servicio.getPrecioBase();

                gastosPorServicio.merge(servicio.getServiceName(), precio, Double::sum);
            });
        }

        // Procesar servicios adicionales
        if (historial.getServiciosAdicionales() != null) {
            historial.getServiciosAdicionales().forEach(servicio -> {
                gastosPorServicio.merge("Otros - " + servicio.getDescripcion(),
                        servicio.getPrecio(),
                        Double::sum);
            });
        }
    }
}

Estructura: service
Archivo: PetService.java
--------------------------------------------------
package com.example.demo.service;

import com.example.demo.dto.PaginatedResponse;
import com.example.demo.dto.PaginationRequest;
import com.example.demo.dto.PetDTOs.*;
import com.example.demo.exception.CustomExceptions;
import com.example.demo.model.MedicalRecord;
import com.example.demo.model.Pet;
import com.example.demo.model.User;
import com.example.demo.repository.PetRepository;
import com.example.demo.util.FirestorePaginationUtils;
import com.google.cloud.firestore.*;
import com.google.firebase.cloud.FirestoreClient;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Service;

import java.util.*;
import java.util.concurrent.ExecutionException;
import java.util.stream.Collectors;

@Service
public class PetService {
    @Autowired
    private Firestore firestore;
    @Autowired
    private PetRepository petRepository;

    private Firestore getFirestore() {
        return FirestoreClient.getFirestore();
    }
    public List<PetResponse> getCurrentUserPets() {
        String uid = getCurrentUserUid();
        return getPetsByUserId(uid);
    }

    public PetResponse createPet(CreatePetRequest request) {
        String ownerId = getCurrentUserUid();

        // Crear un nuevo documento en Firestore y obtener su ID
        DocumentReference newPetRef = firestore.collection("pets").document();
        String newPetId = newPetRef.getId();

        Pet pet = new Pet();
        pet.setId(newPetId);  // Asignar el ID generado
        pet.setName(request.getName());
        pet.setSpecies(request.getSpecies());
        pet.setBreed(request.getBreed());
        pet.setAge(request.getAge());
        pet.setOwnerId(ownerId);

        try {
            // Guardar la mascota en Firestore usando el ID generado
            newPetRef.set(pet).get();

            // Crear y devolver la respuesta
            return convertToPetResponse(pet);
        } catch (InterruptedException | ExecutionException e) {
            throw new CustomExceptions.ProcessingException("Error al crear la mascota: " + e.getMessage());
        }
    }
    private String savePetToFirestore(Pet petToSave) throws InterruptedException, ExecutionException {
        // Add the pet to Firestore and get the auto-generated ID
        return getFirestore().collection("pets").add(petToSave).get().getId();
    }

    public PetResponse updatePet(String id, UpdatePetRequest request) {
        try {
            Pet pet = getFirestore().collection("pets").document(id).get().get().toObject(Pet.class);
            if (pet == null) {
                throw new CustomExceptions.NotFoundException("Pet not found with id: " + id);
            }
            pet.setName(request.getName());
            pet.setSpecies(request.getSpecies());
            pet.setBreed(request.getBreed());
            pet.setAge(request.getAge());

            getFirestore().collection("pets").document(id).set(pet).get();
            return convertToPetResponse(pet);
        } catch (InterruptedException | ExecutionException e) {
            throw new CustomExceptions.ProcessingException("Error updating pet: " + e.getMessage());
        }
    }
    public PetResponse getPetById(String id) {
        try {
            Pet pet = getFirestore().collection("pets").document(id).get().get().toObject(Pet.class);
            if (pet == null) {
                throw new CustomExceptions.NotFoundException("Pet not found with id: " + id);
            }
            return convertToPetResponse(pet);
        } catch (InterruptedException | ExecutionException e) {
            throw new CustomExceptions.ProcessingException("Error fetching pet: " + e.getMessage());
        }
    }

    public List<PetResponse> getPetsByUserId(String userId) {
        try {
            List<PetResponse> pets = new ArrayList<>();
            getFirestore().collection("pets").whereEqualTo("ownerId", userId).get().get().getDocuments().forEach(doc -> {
                Pet pet = doc.toObject(Pet.class);
                pets.add(convertToPetResponse(pet));
            });
            return pets;
        } catch (InterruptedException | ExecutionException e) {
            throw new CustomExceptions.ProcessingException("Error fetching user's pets: " + e.getMessage());
        }
    }

    public PaginatedResponse<MedicalRecordResponse> getPetMedicalHistory(String petId, PaginationRequest request) {
        try {
            CollectionReference recordsRef = firestore.collection("pets")
                    .document(petId)
                    .collection("medicalRecords");

            Query query = recordsRef;

            // Aplicar filtros
            if (request.getFilterBy() != null && request.getFilterValue() != null) {
                query = query.whereEqualTo(request.getFilterBy(), request.getFilterValue());
            }

            // Ordenamiento
            Query.Direction direction = request.getSortDirection().equalsIgnoreCase("DESC")
                    ? Query.Direction.DESCENDING
                    : Query.Direction.ASCENDING;
            query = query.orderBy(request.getSortBy(), direction);

            // Paginación
            query = query.offset(request.getPage() * request.getSize())
                    .limit(request.getSize());

            QuerySnapshot querySnapshot = query.get().get();

            List<MedicalRecordResponse> records = querySnapshot.getDocuments().stream()
                    .map(doc -> {
                        MedicalRecord record = doc.toObject(MedicalRecord.class);
                        return convertToMedicalRecordResponse(record);
                    })
                    .collect(Collectors.toList());

            long totalElements = FirestorePaginationUtils.getTotalElements(recordsRef);

            return PaginatedResponse.of(records, request, totalElements);
        } catch (Exception e) {
            throw new CustomExceptions.ProcessingException(
                    "Error fetching medical history: " + e.getMessage());
        }
    }
    public MedicalRecordResponse addMedicalRecord(String petId, AddMedicalRecordRequest request) {
        try {
            MedicalRecordResponse record = new MedicalRecordResponse();
            record.setId(UUID.randomUUID().toString());
            record.setDate(new Date());
            record.setDiagnosis(request.getDiagnosis());
            record.setTreatment(request.getTreatment());
            record.setVeterinarianId(getCurrentUserUid());

            getFirestore().collection("pets").document(petId).collection("medicalRecords").document(record.getId()).set(record).get();
            return record;
        } catch (InterruptedException | ExecutionException e) {
            throw new CustomExceptions.ProcessingException("Error adding medical record: " + e.getMessage());
        }
    }

    public boolean isOwner(String petId) {
        String currentUserId = getCurrentUserUid();
        try {
            Pet pet = getFirestore().collection("pets").document(petId).get().get().toObject(Pet.class);
            if (pet == null) {
                throw new CustomExceptions.NotFoundException("Pet not found with id: " + petId);
            }
            return pet.getOwnerId().equals(currentUserId);
        } catch (InterruptedException | ExecutionException e) {
            throw new CustomExceptions.ProcessingException("Error checking pet ownership: " + e.getMessage());
        }
    }
    private String getCurrentUserUid() {
        return SecurityContextHolder.getContext().getAuthentication().getName();
    }

    private PetResponse convertToPetResponse(Pet pet) {
        PetResponse response=new PetResponse();
        response.setId(pet.getId());
        response.setName(pet.getName());
        response.setSpecies(pet.getSpecies());
        response.setBreed(pet.getBreed());
        response.setAge(pet.getAge());
        response.setOwnerId(pet.getOwnerId());
        return response;
    }
    private Pet convertToPet(PetResponse petResponse) {
        Pet pet = new Pet();
        pet.setId(petResponse.getId());
        pet.setName(petResponse.getName());
        pet.setAge(petResponse.getAge());
        // Set other fields as necessary
        return pet;
    }
    public void deletePet(String id) {
        try {
            // Obtener el UID del usuario actual
            String currentUserUid = getCurrentUserUid();

            // Verificar si la mascota existe y pertenece al usuario actual
            DocumentSnapshot petDoc = firestore.collection("pets").document(id).get().get();

            if (!petDoc.exists()) {
                throw new CustomExceptions.NotFoundException("Mascota no encontrada con id: " + id);
            }

            Pet pet = petDoc.toObject(Pet.class);
            if (pet == null || !pet.getOwnerId().equals(currentUserUid)) {
                throw new CustomExceptions.UnauthorizedException("No tienes permiso para eliminar esta mascota");
            }

            // Eliminar la mascota
            firestore.collection("pets").document(id).delete().get();

            // Opcionalmente, puedes también eliminar registros relacionados, como historial médico
            // Esto depende de cómo esté estructurada tu base de datos
            firestore.collection("pets").document(id).collection("medicalRecords").get().get()
                    .getDocuments().forEach(doc -> doc.getReference().delete());

        } catch (InterruptedException | ExecutionException e) {
            throw new CustomExceptions.ProcessingException("Error al eliminar la mascota: " + e.getMessage());
        }
    }
    public PaginatedResponse<PetResponse> getAllPets(PaginationRequest request) {
        try {
            // Obtener referencia a la colección
            CollectionReference petsRef = firestore.collection("pets");

            // Determinar dirección de ordenamiento
            Query.Direction direction = request.getSortDirection().equalsIgnoreCase("DESC")
                    ? Query.Direction.DESCENDING
                    : Query.Direction.ASCENDING;

            // Obtener datos paginados
            QuerySnapshot querySnapshot = FirestorePaginationUtils.getPaginatedData(
                    petsRef, request, direction
            );

            // Convertir documentos a PetResponse
            List<PetResponse> pets = querySnapshot.getDocuments().stream()
                    .map(doc -> {
                        Pet pet = doc.toObject(Pet.class);
                        return convertToPetResponse(pet);
                    })
                    .collect(Collectors.toList());

            // Obtener total de elementos
            long totalElements = FirestorePaginationUtils.getTotalElements(petsRef);

            // Crear respuesta paginada
            return PaginatedResponse.of(pets, request, totalElements);

        } catch (Exception e) {
            throw new CustomExceptions.ProcessingException("Error al obtener las mascotas: " + e.getMessage());
        }
    }
    public PaginatedResponse<PetResponse> getPetsByUserId(String userId, PaginationRequest request) {
        try {
            CollectionReference petsRef = firestore.collection("pets");
            Query query = petsRef.whereEqualTo("ownerId", userId);

            // Aplicar filtros adicionales si existen
            if (request.getFilterBy() != null && request.getFilterValue() != null) {
                query = query.whereEqualTo(request.getFilterBy(), request.getFilterValue());
            }

            // Aplicar ordenamiento
            Query.Direction direction = request.getSortDirection().equalsIgnoreCase("DESC")
                    ? Query.Direction.DESCENDING
                    : Query.Direction.ASCENDING;
            query = query.orderBy(request.getSortBy(), direction);

            // Aplicar paginación
            query = query.offset(request.getPage() * request.getSize())
                    .limit(request.getSize());

            // Ejecutar query
            QuerySnapshot querySnapshot = query.get().get();

            // Convertir resultados
            List<PetResponse> pets = querySnapshot.getDocuments().stream()
                    .map(doc -> {
                        Pet pet = doc.toObject(Pet.class);
                        return convertToPetResponse(pet);
                    })
                    .collect(Collectors.toList());

            // Obtener total de elementos para este usuario
            long totalElements = petsRef
                    .whereEqualTo("ownerId", userId)
                    .get().get().size();

            return PaginatedResponse.of(pets, request, totalElements);

        } catch (Exception e) {
            throw new CustomExceptions.ProcessingException(
                    "Error fetching user's pets: " + e.getMessage());
        }
    }
    public MedicalRecordResponse convertToMedicalRecordResponse(MedicalRecord record) {
        if (record == null) {
            return null;
        }

        MedicalRecordResponse response = new MedicalRecordResponse();
        response.setId(record.getId());
        response.setDate(record.getDate());
        response.setDiagnosis(record.getDiagnosis());
        response.setTreatment(record.getTreatment());
        response.setNotes(record.getNotes());
        response.setVeterinarianId(record.getVeterinarianId());

        // Obtener información del veterinario si está disponible
        try {
            if (record.getVeterinarianId() != null) {
                DocumentSnapshot vetDoc = firestore.collection("users")
                        .document(record.getVeterinarianId())
                        .get()
                        .get();

                if (vetDoc.exists()) {
                    User vet = vetDoc.toObject(User.class);
                    if (vet != null) {
                        response.setVeterinarianName(vet.getNombre() + " " + vet.getApellido());
                    }
                }
            }
        } catch (Exception e) {
            // Si hay error al obtener el veterinario, dejamos el nombre como null
            //logger.warn("Error getting veterinarian info for medical record: {}", e.getMessage());
        }

        return response;
    }

}

Estructura: service
Archivo: ReminderService.java
--------------------------------------------------
package com.example.demo.service;
import com.example.demo.model.*;
import com.example.demo.dto.*;
import com.google.cloud.firestore.Firestore;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Service;
import java.util.*;
import java.util.concurrent.ExecutionException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

@Service
public class ReminderService {
    private static final Logger logger = LoggerFactory.getLogger(ReminderService.class);

    @Autowired
    private Firestore firestore;

    @Autowired
    private NotificationService notificationService;

    private static final String DEFAULT_TEMPLATE = """
        <html>
        <body>
            <h2>Recordatorio de Cita Veterinaria</h2>
            <p>Estimado/a %s,</p>
            <p>Le recordamos su cita programada para:</p>
            <ul>
                <li><strong>Fecha:</strong> %s</li>
                <li><strong>Mascota:</strong> %s</li>
                <li><strong>Veterinario:</strong> Dr. %s</li>
            </ul>
            <p>Por favor, confirme su asistencia haciendo clic en el siguiente enlace:</p>
            <a href="%s" style="padding: 10px 20px; background-color: #4CAF50; color: white; text-decoration: none; border-radius: 5px;">
                Confirmar Asistencia
            </a>
            <p>Si necesita reprogramar su cita, por favor contáctenos lo antes posible.</p>
        </body>
        </html>
    """;

    // Ejecutar cada hora para verificar próximas citas
    @Scheduled(fixedRate = 3600000)
    public void checkUpcomingAppointments() {
        try {
            AppointmentReminderConfig config = getConfig();
            if (!config.isEnabled()) {
                return;
            }

            // Calcular el rango de tiempo para las citas que necesitan recordatorio
            Date now = new Date();
            Date reminderTime = new Date(now.getTime() + (config.getReminderHoursBefore() * 3600000));

            // Obtener citas próximas que aún no tienen recordatorio enviado
            var appointments = firestore.collection("appointments")
                    .whereEqualTo("status", "SCHEDULED")
                    .whereEqualTo("reminderSent", false)
                    .whereLessThan("appointmentDate", reminderTime)
                    .get()
                    .get();

            for (var doc : appointments.getDocuments()) {
                Appointment appointment = doc.toObject(Appointment.class);
                sendReminder(appointment, config);

                // Marcar recordatorio como enviado
                doc.getReference().update("reminderSent", true);
            }

        } catch (Exception e) {
            logger.error("Error checking upcoming appointments: {}", e.getMessage());
        }
    }

    public void sendReminder(Appointment appointment, AppointmentReminderConfig config) {
        try {
            // Obtener información necesaria
            var clientDoc = firestore.collection("users").document(appointment.getClientId()).get().get();
            var petDoc = firestore.collection("pets").document(appointment.getPetId()).get().get();
            var vetDoc = firestore.collection("users").document(appointment.getVeterinarianId()).get().get();

            User client = clientDoc.toObject(User.class);
            Pet pet = petDoc.toObject(Pet.class);
            User vet = vetDoc.toObject(User.class);

            // Generar enlace de confirmación único
            String confirmationLink = generateConfirmationLink(appointment.getId());

            // Generar contenido del correo
            String emailContent = String.format(
                    config.getEmailTemplate() != null ? config.getEmailTemplate() : DEFAULT_TEMPLATE,
                    client.getNombre(),
                    formatDate(appointment.getAppointmentDate()),
                    pet.getName(),
                    vet.getNombre() + " " + vet.getApellido(),
                    confirmationLink
            );

            // Enviar correo
            notificationService.sendEmail(
                    client.getEmail(),
                    "Recordatorio de Cita Veterinaria - " + pet.getName(),
                    emailContent
            );

            logger.info("Reminder sent for appointment ID: {}", appointment.getId());
        } catch (Exception e) {
            logger.error("Error sending reminder for appointment {}: {}",
                    appointment.getId(), e.getMessage());
        }
    }

    private String generateConfirmationLink(String appointmentId) {
        // Generar un token seguro para la confirmación
        String token = UUID.randomUUID().toString();
        String baseUrl = "http://tu-dominio.com/api/appointments/confirm";
        return String.format("%s?id=%s&token=%s", baseUrl, appointmentId, token);
    }

    public void updateReminderConfig(ReminderDTO config) {
        try {
            AppointmentReminderConfig reminderConfig = AppointmentReminderConfig.builder()
                    .id("default")
                    .reminderHoursBefore(config.getReminderHoursBefore())
                    .isEnabled(config.isEnabled())
                    .emailTemplate(config.getEmailTemplate())
                    .build();

            firestore.collection("configurations")
                    .document("reminderConfig")
                    .set(reminderConfig)
                    .get();

            logger.info("Reminder configuration updated successfully");
        } catch (Exception e) {
            logger.error("Error updating reminder configuration: {}", e.getMessage());
            throw new RuntimeException("Error updating reminder configuration");
        }
    }

    public void confirmAppointment(String appointmentId, String token) {
        try {
            // Verificar token y actualizar estado de la cita
            var appointmentDoc = firestore.collection("appointments")
                    .document(appointmentId)
                    .get()
                    .get();

            if (!appointmentDoc.exists()) {
                throw new RuntimeException("Appointment not found");
            }

            Appointment appointment = appointmentDoc.toObject(Appointment.class);
            appointment.setStatus(AppointmentStatus.CONFIRMED.toString());

            firestore.collection("appointments")
                    .document(appointmentId)
                    .set(appointment)
                    .get();

            logger.info("Appointment {} confirmed successfully", appointmentId);
        } catch (Exception e) {
            logger.error("Error confirming appointment {}: {}", appointmentId, e.getMessage());
            throw new RuntimeException("Error confirming appointment");
        }
    }

    private AppointmentReminderConfig getConfig() throws ExecutionException, InterruptedException {
        var configDoc = firestore.collection("configurations")
                .document("reminderConfig")
                .get()
                .get();

        if (!configDoc.exists()) {
            // Crear configuración por defecto
            AppointmentReminderConfig defaultConfig = AppointmentReminderConfig.builder()
                    .id("default")
                    .reminderHoursBefore(24) // 24 horas por defecto
                    .isEnabled(true)
                    .emailTemplate(DEFAULT_TEMPLATE)
                    .build();

            configDoc.getReference().set(defaultConfig).get();
            return defaultConfig;
        }

        return configDoc.toObject(AppointmentReminderConfig.class);
    }

    private String formatDate(Date date) {
        return date.toString(); // Implementar formato deseado
    }
}


Estructura: service
Archivo: RolePermissionService.java
--------------------------------------------------
package com.example.demo.service;

import com.example.demo.dto.UserDTOs;
import com.example.demo.exception.CustomExceptions;
import com.example.demo.model.Role;
import com.example.demo.model.User;
import com.example.demo.security.CustomUserDetails;
import com.google.api.core.ApiFuture;
import com.google.cloud.firestore.DocumentSnapshot;
import com.google.cloud.firestore.Firestore;
import com.google.cloud.firestore.QueryDocumentSnapshot;
import com.google.cloud.firestore.QuerySnapshot;
import com.google.firebase.cloud.FirestoreClient;
import lombok.Data;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ExecutionException;
import java.util.stream.Collectors;

@Service
public class RolePermissionService {
    @Autowired
    private Firestore firestore;
    private Firestore getFirestore() {
        return FirestoreClient.getFirestore();
    }

    private final Map<Role, List<String>> rolePermissions;

    public RolePermissionService() {
        rolePermissions = new HashMap<>();
        rolePermissions.put(Role.VETERINARIO, List.of("VER_USUARIOS", "GESTIONAR_USUARIOS", "GESTIONAR_ROLES"));
        rolePermissions.put(Role.RECEPCIONISTA, List.of("VER_USUARIOS"));
        rolePermissions.put(Role.CLIENTE, List.of("VER_PERFIL_PROPIO", "EDITAR_PERFIL_PROPIO"));
    }


    public boolean hasPermission(String uid, String permission) {
        try {
            List<Role> userRoles = getUserRoles(uid);
            for (Role role : userRoles) {
                List<String> rolePermissions = getRolePermissions(role.name());
                if (rolePermissions.contains(permission)) {
                    return true;
                }
            }
            return false;
        } catch (Exception e) {
            throw new CustomExceptions.ProcessingException("Error checking user permission: " + e.getMessage());
        }
    }
    public UserDTOs.RolePermissionDTO updateRolePermissions(String roleName, List<String> newPermissions) {
        try {
            List<QueryDocumentSnapshot> documents = firestore.collection("roles")
                    .whereEqualTo("name", roleName)
                    .get().get().getDocuments();
            if (!documents.isEmpty()) {
                String docId = documents.get(0).getId();
                firestore.collection("roles").document(docId).update("permissions", newPermissions).get();
                return new UserDTOs.RolePermissionDTO(roleName, newPermissions);
            } else {
                throw new RuntimeException("Role not found");
            }
        } catch (Exception e) {
            throw new RuntimeException("Error updating role permissions", e);
        }
    }
    public List<UserDTOs.RolePermissionDTO> getAllRolePermissions() {
        try {
            List<UserDTOs.RolePermissionDTO> rolePermissions = new ArrayList<>();
            ApiFuture<QuerySnapshot> future = getFirestore().collection("roles").get();
            List<QueryDocumentSnapshot> documents = future.get().getDocuments();

            for (QueryDocumentSnapshot document : documents) {
                UserDTOs.RolePermissionDTO dto = new UserDTOs.RolePermissionDTO();

                // Usar el campo 'name' como el nombre del rol en lugar del ID del documento
                String roleName = document.getString("name");
                dto.setRole(roleName != null ? roleName : document.getId());

                @SuppressWarnings("unchecked")
                List<String> permissions = (List<String>) document.get("permissions");
                dto.setPermissions(permissions);

                rolePermissions.add(dto);
            }

            return rolePermissions;
        } catch (InterruptedException | ExecutionException e) {
            throw new CustomExceptions.ProcessingException("Error fetching role permissions: " + e.getMessage());
        }
    }
    private List<Role> getUserRoles(String uid) throws ExecutionException, InterruptedException {
        DocumentSnapshot document = getFirestore().collection("users").document(uid).get().get();
        if (document.exists()) {
            @SuppressWarnings("unchecked")
            List<String> roleStrings = (List<String>) document.get("roles");
            return roleStrings.stream()
                    .map(Role::valueOf)
                    .collect(Collectors.toList());
        }
        return new ArrayList<>();
    }

    private List<String> getRolePermissions(String roleName) throws ExecutionException, InterruptedException {
        ApiFuture<QuerySnapshot> future = getFirestore().collection("roles").whereEqualTo("name", roleName).get();
        List<QueryDocumentSnapshot> documents = future.get().getDocuments();
        if (!documents.isEmpty()) {
            @SuppressWarnings("unchecked")
            List<String> permissions = (List<String>) documents.get(0).get("permissions");
            return permissions != null ? permissions : new ArrayList<>();
        }
        return new ArrayList<>();
    }
    // Obtener permisos de un rol por nombre
    public List<String> getRolePermissionsByName(String roleName) {
        try {
            List<QueryDocumentSnapshot> documents = firestore.collection("roles")
                    .whereEqualTo("name", roleName)
                    .get().get().getDocuments();
            if (!documents.isEmpty()) {
                return (List<String>) documents.get(0).get("permissions");
            } else {
                throw new RuntimeException("Role not found");
            }
        } catch (Exception e) {
            throw new RuntimeException("Error fetching role permissions", e);
        }
    }
}


Estructura: service
Archivo: RoleService.java
--------------------------------------------------
package com.example.demo.service;

import com.example.demo.dto.RoleDTOs;
import com.google.api.core.ApiFuture;
import com.google.cloud.firestore.*;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

@Service
public class RoleService {
    @Autowired
    private Firestore firestore;

    public List<RoleDTOs.RoleResponse> getAllRoles() {
        try {
            ApiFuture<QuerySnapshot> future = firestore.collection("roles").get();
            List<QueryDocumentSnapshot> documents = future.get().getDocuments();
            return documents.stream()
                    .map(this::convertToDTO)
                    .map(RoleDTOs.RoleResponse::new)
                    .collect(Collectors.toList());
        } catch (Exception e) {
            throw new RuntimeException("Error fetching roles", e);
        }
    }
/*
    public RoleDTOs.RoleDTO createRole(RoleDTOs.CreateRoleRequest request) {
        DocumentReference docRef = firestore.collection("roles").document();
        Map<String, Object> data = new HashMap<>();
        data.put("name", request.getName());
        data.put("permissions", request.getPermissions());

        try {
            docRef.set(data).get();
            return new RoleDTOs.RoleDTO(docRef.getId(), request.getName(), request.getPermissions());
        } catch (Exception e) {
            throw new RuntimeException("Error creating role", e);
        }
    }
*/
    public RoleDTOs.RoleResponse createRole(RoleDTOs.CreateRoleRequest request) {
        DocumentReference docRef = firestore.collection("roles").document();
        Map<String, Object> data = new HashMap<>();
        data.put("name", request.getName());
        Map<String, String> permissions = new HashMap<>();
        for (int i = 0; i < request.getPermissions().size(); i++) {
            permissions.put(String.valueOf(i), request.getPermissions().get(i));
        }
        data.put("permissions", permissions);

        try {
            docRef.set(data).get();
            RoleDTOs.RoleDTO roleDTO = new RoleDTOs.RoleDTO(docRef.getId(), request.getName(), request.getPermissions());
            return new RoleDTOs.RoleResponse(roleDTO);
        } catch (Exception e) {
            throw new RuntimeException("Error creating role", e);
        }
    }
//    public RoleDTOs.RoleDTO updateRole(String roleId, RoleDTOs.UpdateRoleRequest request) {
//        DocumentReference docRef = firestore.collection("roles").document(roleId);
//        Map<String, Object> updates = new HashMap<>();
//        updates.put("name", request.getName());
//
//        try {
//            docRef.update(updates).get();
//            DocumentSnapshot updatedDoc = docRef.get().get();
//            return convertToDTO(updatedDoc);
//        } catch (Exception e) {
//            throw new RuntimeException("Error updating role", e);
//        }
//    }
    public RoleDTOs.RoleResponse updateRole(String roleId, RoleDTOs.UpdateRoleRequest request) {
        DocumentReference docRef = firestore.collection("roles").document(roleId);
        Map<String, Object> updates = new HashMap<>();
        updates.put("name", request.getName());
        Map<String, String> permissions = new HashMap<>();
        for (int i = 0; i < request.getPermissions().size(); i++) {
            permissions.put(String.valueOf(i), request.getPermissions().get(i));
        }
        updates.put("permissions", permissions);

        try {
            docRef.update(updates).get();
            DocumentSnapshot updatedDoc = docRef.get().get();
            return new RoleDTOs.RoleResponse(convertToDTO(updatedDoc));
        } catch (Exception e) {
            throw new RuntimeException("Error updating role", e);
        }
    }

    public void deleteRole(String roleId) {
        try {
            firestore.collection("roles").document(roleId).delete().get();
        } catch (Exception e) {
            throw new RuntimeException("Error deleting role", e);
        }
    }

    public RoleDTOs.RoleDTO updateRolePermissions(String roleId, List<String> permissions) {
        DocumentReference docRef = firestore.collection("roles").document(roleId);
        Map<String, Object> updates = new HashMap<>();
        updates.put("permissions", permissions);

        try {
            docRef.update(updates).get();
            DocumentSnapshot updatedDoc = docRef.get().get();
            return convertToDTO(updatedDoc);
        } catch (Exception e) {
            throw new RuntimeException("Error updating role permissions", e);
        }
    }

    private RoleDTOs.RoleDTO convertToDTO(DocumentSnapshot document) {
        String id = document.getId();
        String name = document.getString("name");
        Map<String, String> permissionsMap = (Map<String, String>) document.get("permissions");
        List<String> permissions = new ArrayList<>(permissionsMap.values());
        return new RoleDTOs.RoleDTO(id, name, permissions);
    }
}


Estructura: service
Archivo: ServiceReportService.java
--------------------------------------------------
package com.example.demo.service;

import com.example.demo.dto.ServiceReportDTOs.*;
import com.example.demo.exception.CustomExceptions;
import com.example.demo.model.*;
import com.google.cloud.firestore.*;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import java.util.*;
import java.util.stream.Collectors;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

@Service
public class ServiceReportService {
    private static final Logger logger = LoggerFactory.getLogger(ServiceReportService.class);

    @Autowired
    private Firestore firestore;

    /**
     * Genera un reporte de servicios basado en los filtros proporcionados
     */
    public ServiceReportResponse generateReport(ReportFilterRequest filter) {
        try {
            validateDates(filter.getStartDate(), filter.getEndDate());

            List<HistorialClinico> historiales = getHistorialesInPeriod(
                    filter.getStartDate(),
                    filter.getEndDate()
            );

            logger.info("Found {} clinical records in period", historiales.size());

            // Si es categoría OTROS, manejamos solo servicios adicionales
            if (filter.getCategory() != null && filter.getCategory().equals("OTROS")) {
                return generateAdditionalServicesReport(historiales, filter);
            }

            // Si no hay historiales, retornar reporte vacío
            if (historiales.isEmpty()) {
                return createEmptyReport(filter.getStartDate(), filter.getEndDate());
            }

            // Extraer servicios regulares
            List<ServicioRealizado> serviciosRealizados = extractServiciosRealizados(
                    historiales,
                    filter.getCategory()
            );

            // Si no hay filtro de categoría, incluir también servicios adicionales
            List<ServiceMetricsDTO> servicesMetrics = new ArrayList<>();

            if (filter.getCategory() == null) {
                // Procesar servicios regulares
                servicesMetrics.addAll(calculateServicesMetrics(serviciosRealizados, historiales));

                // Procesar servicios adicionales
                List<ServicioAdicionalWrapper> serviciosAdicionales = new ArrayList<>();
                for (HistorialClinico historial : historiales) {
                    if (historial.getServiciosAdicionales() != null) {
                        for (ServicioAdicional servicio : historial.getServiciosAdicionales()) {
                            serviciosAdicionales.add(new ServicioAdicionalWrapper(
                                    servicio,
                                    historial.getFechaVisita()
                            ));
                        }
                    }
                }

                // Agrupar servicios adicionales por descripción
                Map<String, List<ServicioAdicionalWrapper>> serviciosPorDescripcion =
                        serviciosAdicionales.stream()
                                .collect(Collectors.groupingBy(w -> w.servicio.getDescripcion()));

                // Agregar métricas de servicios adicionales
                serviciosPorDescripcion.forEach((descripcion, servicios) -> {
                    double serviceRevenue = servicios.stream()
                            .mapToDouble(w -> w.servicio.getPrecio())
                            .sum();

                    servicesMetrics.add(ServiceMetricsDTO.builder()
                            .serviceId("adicional-" + UUID.randomUUID().toString())
                            .serviceName(descripcion)
                            .totalUsage(servicios.size())
                            .totalRevenue(serviceRevenue)
                            .averageRevenue(serviceRevenue / servicios.size())
                            .monthlyMetrics(calculateMonthlyMetricsForAdicionales(servicios))
                            .build());
                });
            } else {
                // Si hay filtro de categoría, solo incluir servicios regulares
                servicesMetrics.addAll(calculateServicesMetrics(serviciosRealizados, historiales));
            }

            // Calcular métricas por categoría
            Map<String, Double> revenueByCategory = calculateRevenueByCategory(servicesMetrics);
            Map<String, Long> usageByCategory = calculateUsageByCategory(servicesMetrics);

            // Calcular totales
            double totalRevenue = servicesMetrics.stream()
                    .mapToDouble(ServiceMetricsDTO::getTotalRevenue)
                    .sum();

            long totalServicesUsed = servicesMetrics.stream()
                    .mapToLong(ServiceMetricsDTO::getTotalUsage)
                    .sum();

            return ServiceReportResponse.builder()
                    .startDate(filter.getStartDate())
                    .endDate(filter.getEndDate())
                    .totalRevenue(totalRevenue)
                    .totalServicesUsed(totalServicesUsed)
                    .servicesMetrics(servicesMetrics)
                    .revenueByCategory(revenueByCategory)
                    .usageByCategory(usageByCategory)
                    .build();

        } catch (Exception e) {
            logger.error("Error generating service report: ", e);
            throw new CustomExceptions.ProcessingException(
                    "Error generating service report: " + e.getMessage());
        }
    }

    /**
     * Genera un reporte específico para servicios adicionales
     */
    private ServiceReportResponse generateAdditionalServicesReport(
            List<HistorialClinico> historiales,
            ReportFilterRequest filter) {

        // Extraer todos los servicios adicionales
        List<ServicioAdicionalWrapper> serviciosAdicionales = new ArrayList<>();

        for (HistorialClinico historial : historiales) {
            if (historial.getServiciosAdicionales() != null) {
                for (ServicioAdicional servicio : historial.getServiciosAdicionales()) {
                    serviciosAdicionales.add(new ServicioAdicionalWrapper(
                            servicio,
                            historial.getFechaVisita()
                    ));
                }
            }
        }

        // Calcular métricas
        double totalRevenue = serviciosAdicionales.stream()
                .mapToDouble(w -> w.servicio.getPrecio())
                .sum();

        // Agrupar por descripción para calcular uso
        Map<String, List<ServicioAdicionalWrapper>> serviciosPorDescripcion =
                serviciosAdicionales.stream()
                        .collect(Collectors.groupingBy(w -> w.servicio.getDescripcion()));

        // Crear métricas por servicio
        List<ServiceMetricsDTO> servicesMetrics = serviciosPorDescripcion.entrySet().stream()
                .map(entry -> {
                    String descripcion = entry.getKey();
                    List<ServicioAdicionalWrapper> servicios = entry.getValue();

                    double serviceRevenue = servicios.stream()
                            .mapToDouble(w -> w.servicio.getPrecio())
                            .sum();

                    return ServiceMetricsDTO.builder()
                            .serviceId("adicional-" + UUID.randomUUID().toString())
                            .serviceName(descripcion)
                            .totalUsage(servicios.size())
                            .totalRevenue(serviceRevenue)
                            .averageRevenue(serviceRevenue / servicios.size())
                            .monthlyMetrics(calculateMonthlyMetricsForAdicionales(servicios))
                            .build();
                })
                .collect(Collectors.toList());

        return ServiceReportResponse.builder()
                .startDate(filter.getStartDate())
                .endDate(filter.getEndDate())
                .totalRevenue(totalRevenue)
                .totalServicesUsed(serviciosAdicionales.size())
                .servicesMetrics(servicesMetrics)
                .revenueByCategory(Map.of("OTROS", totalRevenue))
                .usageByCategory(Map.of("OTROS", (long) serviciosAdicionales.size()))
                .build();
    }

    /**
     * Clase auxiliar para mantener juntos el servicio adicional y su fecha
     */
    private static class ServicioAdicionalWrapper {
        final ServicioAdicional servicio;
        final Date fecha;

        ServicioAdicionalWrapper(ServicioAdicional servicio, Date fecha) {
            this.servicio = servicio;
            this.fecha = fecha;
        }
    }

    /**
     * Valida las fechas del filtro
     */
    private void validateDates(Date startDate, Date endDate) {
        if (startDate == null || endDate == null) {
            throw new IllegalArgumentException("Start date and end date are required");
        }
        if (startDate.after(endDate)) {
            throw new IllegalArgumentException("Start date cannot be after end date");
        }
    }

    /**
     * Crea un reporte vacío con valores inicializados
     */
    private ServiceReportResponse createEmptyReport(Date startDate, Date endDate) {
        return ServiceReportResponse.builder()
                .startDate(startDate)
                .endDate(endDate)
                .totalRevenue(0.0)
                .totalServicesUsed(0)
                .servicesMetrics(new ArrayList<>())
                .revenueByCategory(new HashMap<>())
                .usageByCategory(new HashMap<>())
                .build();
    }

    /**
     * Obtiene los historiales clínicos en un período específico
     */
    private List<HistorialClinico> getHistorialesInPeriod(Date startDate, Date endDate)
            throws Exception {
        QuerySnapshot snapshot = firestore.collection("historial_clinico")
                .whereGreaterThanOrEqualTo("fechaVisita", startDate)
                .whereLessThanOrEqualTo("fechaVisita", endDate)
                .get()
                .get();

        return snapshot.getDocuments().stream()
                .map(doc -> {
                    HistorialClinico historial = doc.toObject(HistorialClinico.class);
                    if (historial != null) {
                        historial.setId(doc.getId());
                    }
                    return historial;
                })
                .filter(Objects::nonNull)
                .collect(Collectors.toList());
    }

    /**
     * Extrae y filtra los servicios realizados
     */
    private List<ServicioRealizado> extractServiciosRealizados(
            List<HistorialClinico> historiales,
            String categoryFilter) {

        List<ServicioRealizado> servicios = historiales.stream()
                .filter(h -> h.getServiciosRealizados() != null)
                .flatMap(h -> h.getServiciosRealizados().stream())
                .collect(Collectors.toList());

        // Si no hay filtro de categoría, retornamos todos
        if (categoryFilter == null || categoryFilter.isEmpty()) {
            return servicios;
        }

        // Filtrar por categoría
        try {
            ServiceCategory targetCategory = ServiceCategory.valueOf(categoryFilter);
            return servicios.stream()
                    .filter(s -> {
                        try {
                            DocumentSnapshot serviceDoc = firestore.collection("veterinary_services")
                                    .document(s.getServiceId())
                                    .get()
                                    .get();

                            return serviceDoc.exists() &&
                                    targetCategory.equals(serviceDoc.get("category", ServiceCategory.class));
                        } catch (Exception e) {
                            logger.warn("Error checking service category: {}", e.getMessage());
                            return false;
                        }
                    })
                    .collect(Collectors.toList());
        } catch (IllegalArgumentException e) {
            logger.warn("Invalid category filter: {}", categoryFilter);
            return new ArrayList<>();
        }
    }

    /**
     * Calcula las métricas para cada servicio
     */
    private List<ServiceMetricsDTO> calculateServicesMetrics(
            List<ServicioRealizado> servicios,
            List<HistorialClinico> historiales) {

        // Agrupar servicios por ID
        Map<String, List<ServicioRealizado>> serviciosPorId = servicios.stream()
                .collect(Collectors.groupingBy(ServicioRealizado::getServiceId));

        // Obtener fechas por servicio
        Map<String, List<Date>> fechasPorServicio = createFechasPorServicio(
                historiales,
                serviciosPorId.keySet()
        );

        // Calcular métricas para cada servicio
        return serviciosPorId.entrySet().stream()
                .map(entry -> {
                    String serviceId = entry.getKey();
                    List<ServicioRealizado> usos = entry.getValue();
                    List<Date> fechasUso = fechasPorServicio.get(serviceId);

                    double totalRevenue = usos.stream()
                            .mapToDouble(s -> s.getPrecioPersonalizado() != null ?
                                    s.getPrecioPersonalizado() : s.getPrecioBase())
                            .sum();

                    return ServiceMetricsDTO.builder()
                            .serviceId(serviceId)
                            .serviceName(usos.get(0).getServiceName())
                            .totalUsage(usos.size())
                            .totalRevenue(totalRevenue)
                            .averageRevenue(totalRevenue / usos.size())
                            .monthlyMetrics(calculateMonthlyMetricsForServicios(usos, fechasUso))
                            .build();
                })
                .collect(Collectors.toList());
    }

    /**
     * Crea un mapa de fechas de uso por servicio
     */
    private Map<String, List<Date>> createFechasPorServicio(
            List<HistorialClinico> historiales,
            Set<String> serviceIds) {

        Map<String, List<Date>> fechasPorServicio = new HashMap<>();

        for (HistorialClinico historial : historiales) {
            Date fecha = historial.getFechaVisita();
            if (fecha == null) continue;

            if (historial.getServiciosRealizados() != null) {
                for (ServicioRealizado servicio : historial.getServiciosRealizados()) {
                    if (servicio != null && serviceIds.contains(servicio.getServiceId())) {
                        fechasPorServicio
                                .computeIfAbsent(servicio.getServiceId(), k -> new ArrayList<>())
                                .add(fecha);
                    }
                }
            }
        }

        return fechasPorServicio;
    }

    /**
     * Calcula métricas mensuales para servicios regulares
     */
    private List<MonthlyMetric> calculateMonthlyMetricsForServicios(
            List<ServicioRealizado> servicios,
            List<Date> fechas) {

        if (fechas == null || fechas.isEmpty()) {
            return new ArrayList<>();
        }

        Map<String, MonthlyMetricBuilder> monthlyData = new HashMap<>();

        for (int i = 0; i < servicios.size(); i++) {
            ServicioRealizado servicio = servicios.get(i);
            Date fecha = fechas.get(i);

            if (fecha != null) {
                Calendar cal = Calendar.getInstance();
                cal.setTime(fecha);
                String key = cal.get(Calendar.YEAR) + "-" + cal.get(Calendar.MONTH);

                MonthlyMetricBuilder builder = monthlyData.computeIfAbsent(
                        key,
                        k -> new MonthlyMetricBuilder(
                                cal.get(Calendar.YEAR),
                                cal.get(Calendar.MONTH)
                        )
                );

                builder.addUsage();
                builder.addRevenue(servicio.getPrecioPersonalizado() != null ?
                        servicio.getPrecioPersonalizado() : servicio.getPrecioBase());
            }
        }

        return monthlyData.values().stream()
                .map(MonthlyMetricBuilder::build)
                .sorted(Comparator
                        .comparingInt(MonthlyMetric::getYear)
                        .thenComparingInt(MonthlyMetric::getMonth))
                .collect(Collectors.toList());
    }

    /**
     * Calcula métricas mensuales para servicios adicionales
     */
    private List<MonthlyMetric> calculateMonthlyMetricsForAdicionales(
            List<ServicioAdicionalWrapper> servicios) {

        Map<String, MonthlyMetricBuilder> monthlyData = new HashMap<>();

        for (ServicioAdicionalWrapper wrapper : servicios) {
            if (wrapper.fecha != null) {
                Calendar cal = Calendar.getInstance();
                cal.setTime(wrapper.fecha);
                String key = cal.get(Calendar.YEAR) + "-" + cal.get(Calendar.MONTH);

                MonthlyMetricBuilder builder = monthlyData.computeIfAbsent(
                        key,
                        k -> new MonthlyMetricBuilder(
                                cal.get(Calendar.YEAR),
                                cal.get(Calendar.MONTH)
                        )
                );

                builder.addUsage();
                builder.addRevenue(wrapper.servicio.getPrecio());
            }
        }

        return monthlyData.values().stream()
                .map(MonthlyMetricBuilder::build)
                .sorted(Comparator
                        .comparingInt(MonthlyMetric::getYear)
                        .thenComparingInt(MonthlyMetric::getMonth))
                .collect(Collectors.toList());
    }
    private static class MonthlyMetricBuilder {
        private final int year;
        private final int month;
        private long usage;
        private double revenue;

        MonthlyMetricBuilder(int year, int month) {
            this.year = year;
            this.month = month;
            this.usage = 0;
            this.revenue = 0.0;
        }

        void addUsage() {
            usage++;
        }

        void addRevenue(double amount) {
            revenue += amount;
        }

        MonthlyMetric build() {
            return MonthlyMetric.builder()
                    .year(year)
                    .month(month)
                    .usage(usage)
                    .revenue(revenue)
                    .build();
        }
    }

    /**
     * Calcula los ingresos por categoría
     */
    private Map<String, Double> calculateRevenueByCategory(List<ServiceMetricsDTO> servicesMetrics) {
        Map<String, Double> revenueByCategory = new HashMap<>();

        for (ServiceMetricsDTO metric : servicesMetrics) {
            try {
                // Si es un servicio adicional
                if (metric.getServiceId().startsWith("adicional-")) {
                    revenueByCategory.merge(
                            ServiceCategory.OTROS.name(),
                            metric.getTotalRevenue(),
                            Double::sum
                    );
                    continue;
                }

                // Para servicios regulares
                DocumentSnapshot serviceDoc = firestore.collection("veterinary_services")
                        .document(metric.getServiceId())
                        .get()
                        .get();

                if (serviceDoc.exists()) {
                    ServiceCategory category = serviceDoc.get("category", ServiceCategory.class);
                    if (category != null) {
                        revenueByCategory.merge(
                                category.name(),
                                metric.getTotalRevenue(),
                                Double::sum
                        );
                    }
                }
            } catch (Exception e) {
                logger.warn("Error calculating revenue for service {}: {}",
                        metric.getServiceId(), e.getMessage());
            }
        }

        return revenueByCategory;
    }

    /**
     * Calcula el uso por categoría
     */
    private Map<String, Long> calculateUsageByCategory(List<ServiceMetricsDTO> servicesMetrics) {
        Map<String, Long> usageByCategory = new HashMap<>();

        for (ServiceMetricsDTO metric : servicesMetrics) {
            try {
                // Si es un servicio adicional
                if (metric.getServiceId().startsWith("adicional-")) {
                    usageByCategory.merge(
                            ServiceCategory.OTROS.name(),
                            metric.getTotalUsage(),
                            Long::sum
                    );
                    continue;
                }

                // Para servicios regulares
                DocumentSnapshot serviceDoc = firestore.collection("veterinary_services")
                        .document(metric.getServiceId())
                        .get()
                        .get();

                if (serviceDoc.exists()) {
                    ServiceCategory category = serviceDoc.get("category", ServiceCategory.class);
                    if (category != null) {
                        usageByCategory.merge(
                                category.name(),
                                metric.getTotalUsage(),
                                Long::sum
                        );
                    }
                }
            } catch (Exception e) {
                logger.warn("Error calculating usage for service {}: {}",
                        metric.getServiceId(), e.getMessage());
            }
        }

        return usageByCategory;
    }

    /**
     * Calcula el ingreso total de todos los servicios
     */
    private double calculateTotalRevenue(List<ServicioRealizado> servicios) {
        return servicios.stream()
                .mapToDouble(s -> s.getPrecioPersonalizado() != null ?
                        s.getPrecioPersonalizado() : s.getPrecioBase())
                .sum();
    }
}




Estructura: service
Archivo: ServiceVeterinaryService.java
--------------------------------------------------
package com.example.demo.service;

import com.example.demo.dto.PaginatedResponse;
import com.example.demo.dto.PaginationRequest;
import com.example.demo.dto.ServiceVeterinaryDTOs.*;
import com.example.demo.exception.CustomExceptions;
import com.example.demo.model.ServiceCategory;
import com.example.demo.model.ServiceVeterinary;
import com.google.cloud.firestore.*;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.Date;
import java.util.UUID;
import java.util.List;
import java.util.concurrent.ExecutionException;
import java.util.stream.Collectors;

@Service
public class ServiceVeterinaryService {

    @Autowired
    private Firestore firestore;

    /**
     * Obtiene todos los servicios veterinarios con paginación
     */
    public PaginatedResponse<ServiceResponse> getAllServices(PaginationRequest request) {
        try {
            // Crear referencia a la colección
            CollectionReference servicesRef = firestore.collection("veterinary_services");
            Query query = servicesRef;

            // Aplicar filtros si existen
            if (request.getFilterBy() != null && request.getFilterValue() != null) {
                // Si el filtro es por categoría, necesitamos convertir el string a enum
                if (request.getFilterBy().equals("category")) {
                    try {
                        ServiceCategory category = ServiceCategory.valueOf(request.getFilterValue());
                        query = query.whereEqualTo("category", category);
                    } catch (IllegalArgumentException e) {
                        throw new CustomExceptions.ProcessingException("Invalid category value");
                    }
                } else {
                    // Para otros filtros mantener el comportamiento actual
                    query = query.whereEqualTo(request.getFilterBy(), request.getFilterValue());
                }
            }

            // Ordenamiento
            Query.Direction direction = request.getSortDirection().equalsIgnoreCase("DESC")
                    ? Query.Direction.DESCENDING
                    : Query.Direction.ASCENDING;
            query = query.orderBy(request.getSortBy(), direction);

            // Paginación
            query = query.offset(request.getPage() * request.getSize())
                    .limit(request.getSize());

            // Ejecutar query
            QuerySnapshot querySnapshot = query.get().get();

            // Convertir resultados
            List<ServiceResponse> services = querySnapshot.getDocuments().stream()
                    .map(doc -> {
                        ServiceVeterinary service = doc.toObject(ServiceVeterinary.class);
                        return convertToServiceResponse(service);
                    })
                    .collect(Collectors.toList());

            // Obtener total de elementos filtrados
            long totalElements;
            if (request.getFilterBy() != null && request.getFilterBy().equals("category")) {
                totalElements = firestore.collection("veterinary_services")
                        .whereEqualTo("category", ServiceCategory.valueOf(request.getFilterValue()))
                        .get().get().size();
            } else {
                totalElements = firestore.collection("veterinary_services")
                        .get().get().size();
            }

            return PaginatedResponse.of(services, request, totalElements);

        } catch (Exception e) {
            throw new CustomExceptions.ProcessingException(
                    "Error fetching services: " + e.getMessage());
        }
    }

    /**
     * Crea un nuevo servicio veterinario
     */
    public ServiceResponse createService(CreateServiceRequest request) {
        try {
            // Crear nuevo servicio
            ServiceVeterinary service = ServiceVeterinary.builder()
                    .id(UUID.randomUUID().toString())
                    .name(request.getName())
                    .description(request.getDescription())
                    .price(request.getPrice())
                    .durationMinutes(request.getDurationMinutes())
                    .isActive(true)
                    .createdAt(new Date())
                    .updatedAt(new Date())
                    .recommendations(request.getRecommendations())
                    .warnings(request.getWarnings())
                    .requirements(request.getRequirements())
                    .category(request.getCategory())
                    .build();

            // Guardar en Firestore
            firestore.collection("veterinary_services")
                    .document(service.getId())
                    .set(service)
                    .get();

            return convertToServiceResponse(service);
        } catch (Exception e) {
            throw new CustomExceptions.ProcessingException(
                    "Error creating service: " + e.getMessage());
        }
    }

    /**
     * Actualiza un servicio existente
     */
    public ServiceResponse updateService(String id, UpdateServiceRequest request) {
        try {
            // Verificar que el servicio existe
            DocumentSnapshot doc = firestore.collection("veterinary_services")
                    .document(id)
                    .get()
                    .get();

            if (!doc.exists()) {
                throw new CustomExceptions.NotFoundException("Service not found");
            }

            // Actualizar servicio
            ServiceVeterinary service = doc.toObject(ServiceVeterinary.class);
            service.setName(request.getName());
            service.setDescription(request.getDescription());
            service.setPrice(request.getPrice());
            service.setDurationMinutes(request.getDurationMinutes());
            service.setUpdatedAt(new Date());
            service.setRecommendations(request.getRecommendations());
            service.setWarnings(request.getWarnings());
            service.setRequirements(request.getRequirements());
            service.setCategory(request.getCategory());


            // Guardar cambios
            firestore.collection("veterinary_services")
                    .document(id)
                    .set(service)
                    .get();

            return convertToServiceResponse(service);
        } catch (Exception e) {
            throw new CustomExceptions.ProcessingException(
                    "Error updating service: " + e.getMessage());
        }
    }

    /**
     * Elimina un servicio verificando que no tenga citas activas
     */
    public void deleteService(String id) {
        try {
            // Verificar que el servicio existe
            DocumentSnapshot serviceDoc = firestore.collection("veterinary_services")
                    .document(id)
                    .get()
                    .get();

            if (!serviceDoc.exists()) {
                throw new CustomExceptions.NotFoundException("Service not found");
            }

            // Verificar si hay citas activas que usen este servicio
            QuerySnapshot activeAppointments = firestore.collection("appointments")
                    .whereEqualTo("serviceId", id)
                    .whereIn("status", List.of("SCHEDULED", "CONFIRMED"))
                    .get()
                    .get();

            if (!activeAppointments.isEmpty()) {
                throw new CustomExceptions.ProcessingException(
                        "Cannot delete service with active appointments");
            }

            // Eliminar servicio
            firestore.collection("veterinary_services")
                    .document(id)
                    .delete()
                    .get();

        } catch (Exception e) {
            throw new CustomExceptions.ProcessingException(
                    "Error deleting service: " + e.getMessage());
        }
    }

    /**
     * Activa o desactiva un servicio
     */
    public ServiceResponse toggleServiceStatus(String id) {
        try {
            DocumentSnapshot doc = firestore.collection("veterinary_services")
                    .document(id)
                    .get()
                    .get();

            if (!doc.exists()) {
                throw new CustomExceptions.NotFoundException("Service not found");
            }

            ServiceVeterinary service = doc.toObject(ServiceVeterinary.class);
            service.setActive(!service.isActive());
            service.setUpdatedAt(new Date());

            firestore.collection("veterinary_services")
                    .document(id)
                    .set(service)
                    .get();

            return convertToServiceResponse(service);
        } catch (Exception e) {
            throw new CustomExceptions.ProcessingException(
                    "Error toggling service status: " + e.getMessage());
        }
    }

    public ServiceDetailResponse getServiceDetails(String id) {
        try {
            DocumentSnapshot doc = firestore.collection("veterinary_services")
                    .document(id)
                    .get()
                    .get();

            if (!doc.exists()) {
                throw new CustomExceptions.NotFoundException("Servicio no encontrado");
            }

            ServiceVeterinary service = doc.toObject(ServiceVeterinary.class);
            return convertToServiceDetailResponse(service);
        } catch (Exception e) {
            throw new CustomExceptions.ProcessingException(
                    "Error obteniendo detalles del servicio: " + e.getMessage());
        }
    }
    /**
     * Obtiene la lista de servicios activos con sus detalles completos
     * @return Lista de servicios activos
     */
    public List<ServiceDetailResponse> getActiveServices() {
        try {
            QuerySnapshot snapshot = firestore.collection("veterinary_services")
                    .whereEqualTo("active", true)
                    .orderBy("name")
                    .get()
                    .get();

            return snapshot.getDocuments().stream()
                    .map(doc -> doc.toObject(ServiceVeterinary.class))
                    .map(this::convertToServiceDetailResponse)
                    .collect(Collectors.toList());
        } catch (Exception e) {
            throw new CustomExceptions.ProcessingException(
                    "Error obteniendo servicios activos: " + e.getMessage());
        }
    }
    private ServiceDetailResponse convertToServiceDetailResponse(ServiceVeterinary service) {
        if (service == null) return null;

        return ServiceDetailResponse.builder()
                .id(service.getId())
                .name(service.getName())
                .description(service.getDescription())
                .price(service.getPrice())
                .durationMinutes(service.getDurationMinutes())
                .requirements(service.getRequirements())
                .recommendations(service.getRecommendations())
                .warnings(service.getWarnings())
                .isActive(service.isActive())
                .createdAt(service.getCreatedAt())
                .updatedAt(service.getUpdatedAt())
                .category(service.getCategory())
                .build();
    }


    /**
     * Convierte un ServiceVeterinary a ServiceResponse
     */
    private ServiceResponse convertToServiceResponse(ServiceVeterinary service) {
        return ServiceResponse.builder()
                .id(service.getId())
                .name(service.getName())
                .description(service.getDescription())
                .price(service.getPrice())
                .durationMinutes(service.getDurationMinutes())
                .isActive(service.isActive())
                .createdAt(service.getCreatedAt())
                .updatedAt(service.getUpdatedAt())
                .category(service.getCategory())
                .build();
    }
}

Estructura: service
Archivo: UserDetailsServiceImpl.java
--------------------------------------------------
package com.example.demo.service;

import com.google.firebase.auth.FirebaseAuth;
import com.google.firebase.auth.FirebaseToken;
import com.google.firebase.auth.UserRecord;
import com.example.demo.model.User;
import com.example.demo.repository.UserRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;

import java.util.ArrayList;
import java.util.List;

@Service
public class UserDetailsServiceImpl implements UserDetailsService {

    @Autowired
    private UserRepository userRepository;

    @Autowired
    private FirebaseAuth firebaseAuth;

    @Override
    public UserDetails loadUserByUsername(String email) throws UsernameNotFoundException {
        try {
            // Obtener el usuario de Firebase
            UserRecord userRecord = firebaseAuth.getUserByEmail(email);

            // Obtener información adicional del usuario desde tu base de datos
            User user = userRepository.findByEmail(email)
                    .orElseThrow(() -> new UsernameNotFoundException("User not found with email: " + email));

            List<SimpleGrantedAuthority> authorities = new ArrayList<>();
            user.getRoles().forEach(role -> {
                authorities.add(new SimpleGrantedAuthority("ROLE_" + role.toString().toUpperCase()));
            });

            return new org.springframework.security.core.userdetails.User(
                    userRecord.getEmail(),
                    userRecord.getUid(), // Usamos el UID de Firebase como "contraseña"
                    userRecord.isEmailVerified(),
                    true,
                    true,
                    !userRecord.isDisabled(),
                    authorities);
        } catch (Exception e) {
            throw new UsernameNotFoundException("User not found with email: " + email, e);
        }
    }

    public UserDetails loadUserByToken(String idToken) throws UsernameNotFoundException {
        try {
            // Verificar el token ID de Firebase
            FirebaseToken decodedToken = firebaseAuth.verifyIdToken(idToken);
            String uid = decodedToken.getUid();

            // Obtener el usuario de Firebase
            UserRecord userRecord = firebaseAuth.getUser(uid);

            // Obtener información adicional del usuario desde tu base de datos
            User user = userRepository.findByEmail(userRecord.getEmail())
                    .orElseThrow(() -> new UsernameNotFoundException("User not found with email: " + userRecord.getEmail()));

            List<SimpleGrantedAuthority> authorities = new ArrayList<>();
            user.getRoles().forEach(role -> {
                authorities.add(new SimpleGrantedAuthority("ROLE_" + role.toString().toUpperCase()));
            });

            return new org.springframework.security.core.userdetails.User(
                    userRecord.getEmail(),
                    userRecord.getUid(),
                    userRecord.isEmailVerified(),
                    true,
                    true,
                    !userRecord.isDisabled(),
                    authorities);
        } catch (Exception e) {
            throw new UsernameNotFoundException("Failed to authenticate token", e);
        }
    }
}

Estructura: service
Archivo: UserService.java
--------------------------------------------------
package com.example.demo.service;

import com.example.demo.dto.AuthDTOs.RegisterRequest;
import com.example.demo.dto.PaginatedResponse;
import com.example.demo.dto.PaginationRequest;
import com.example.demo.dto.PetDTOs;
import com.example.demo.dto.UserDTOs.*;
import com.example.demo.exception.CustomExceptions;
import com.example.demo.model.Role;
import com.example.demo.model.User;
import com.google.cloud.firestore.*;
import com.google.firebase.auth.FirebaseAuth;
import com.google.firebase.auth.FirebaseAuthException;
import com.google.firebase.auth.UserRecord;
import com.google.firebase.cloud.FirestoreClient;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContext;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Service;

import java.util.*;
import java.util.concurrent.ExecutionException;
import java.util.stream.Collectors;

@Service
public class UserService {

    private static final Logger logger = LoggerFactory.getLogger(UserService.class);

    @Autowired
    PetService petService;
    @Autowired
    private FirebaseAuth firebaseAuth;
    @Autowired
    private Firestore firestore;
    private Firestore getFirestore() {
        return FirestoreClient.getFirestore();
    }
    public List<Map<String, Object>> getUserNotes(String userId) {
        try {
            List<Map<String, Object>> notes = new ArrayList<>();
            getFirestore().collection("users").document(userId).collection("notes").get().get()
                    .getDocuments().forEach(doc -> notes.add(doc.getData()));
            return notes;
        } catch (InterruptedException | ExecutionException e) {
            throw new CustomExceptions.ProcessingException("Error fetching user notes: " + e.getMessage());
        }
    }
    // En UserService.java
    public PaginatedResponse<UserResponse> searchUsers(String searchTerm, PaginationRequest request) {
        try {
            CollectionReference usersRef = firestore.collection("users");

            // Crear una consulta base que filtre primero por el rol CLIENTE
            Query baseQuery = usersRef.whereArrayContains("roles", Role.CLIENTE);

            // Obtener todos los documentos que son clientes
            QuerySnapshot allClientsSnapshot = baseQuery.get().get();

            // Filtrar en memoria por el término de búsqueda (case insensitive)
            List<UserResponse> filteredUsers = allClientsSnapshot.getDocuments().stream()
                    .map(doc -> doc.toObject(User.class))
                    .filter(user ->
                            (user.getNombre() + " " + user.getApellido())
                                    .toLowerCase()
                                    .contains(searchTerm.toLowerCase()) ||
                                    user.getEmail().toLowerCase().contains(searchTerm.toLowerCase()) ||
                                    user.getTelefono().contains(searchTerm)
                    )
                    .map(this::convertToUserResponse)
                    .collect(Collectors.toList());

            // Calcular el total de elementos y páginas
            long totalElements = filteredUsers.size();
            int totalPages = (int) Math.ceil((double) totalElements / request.getSize());

            // Aplicar paginación a los resultados filtrados
            List<UserResponse> paginatedUsers = filteredUsers.stream()
                    .skip((long) request.getPage() * request.getSize())
                    .limit(request.getSize())
                    .collect(Collectors.toList());

            return new PaginatedResponse<>(
                    paginatedUsers,
                    request.getPage(),
                    request.getSize(),
                    totalElements,
                    totalPages
            );
        } catch (Exception e) {
            throw new CustomExceptions.ProcessingException("Error searching users: " + e.getMessage());
        }
    }

    public UserResponse createUser(RegisterRequest request) {
        try {
            // Primero, verifica si el usuario ya existe en Firestore
            Optional<User> existingUser = findByEmail(request.getEmail());
            if (existingUser.isPresent()) {
                // Si el usuario ya existe, actualiza sus datos y devuelve la respuesta
                User user = existingUser.get();
                updateUserData(user, request);
                return convertToUserResponse(user);
            }

            // Si el usuario no existe, crea uno nuevo
            User newUser = new User();
            newUser.setUid(request.getUid()); // Esto debería ser el UID de Firebase
            newUser.setEmail(request.getEmail());
            newUser.setNombre(request.getNombre());
            newUser.setApellido(request.getApellido());
            newUser.setTelefono(request.getTelefono());
            newUser.setDireccion(request.getDireccion());
            newUser.setRoles(request.getRoles());
            newUser.setEnabled(true);
            newUser.setActive(true);

            // Guarda el nuevo usuario en Firestore
            getFirestore().collection("users").document(newUser.getUid()).set(newUser).get();

            return convertToUserResponse(newUser);
        } catch (InterruptedException | ExecutionException e) {
            throw new CustomExceptions.ProcessingException("Error creating user: " + e.getMessage());
        }
    }
    public UserResponse createUserWithRoles(RegisterRequest request) {
        try {
            // Create user in Firebase Authentication
            UserRecord.CreateRequest createRequest = new UserRecord.CreateRequest()
                    .setEmail(request.getEmail())
                    .setPassword(request.getPassword())
                    .setDisplayName(request.getNombre() + " " + request.getApellido());

            UserRecord userRecord = FirebaseAuth.getInstance().createUser(createRequest);

            // Use the Firebase UID for the Firestore user record
            User newUser = new User();
            newUser.setUid(userRecord.getUid());
            newUser.setEmail(request.getEmail());
            newUser.setNombre(request.getNombre());
            newUser.setApellido(request.getApellido());
            newUser.setTelefono(request.getTelefono());
            newUser.setDireccion(request.getDireccion());
            newUser.setRoles(request.getRoles()); // Assign roles from the frontend
            newUser.setEnabled(true);
            newUser.setActive(true);

            // Save the user to Firestore
            getFirestore().collection("users").document(newUser.getUid()).set(newUser).get();

            // Set custom claims for roles in Firebase Authentication
            Map<String, Object> claims = new HashMap<>();
            List<String> rolesWithPrefix = request.getRoles().stream()
                    .map(role -> "ROLE_" + role.name())
                    .collect(Collectors.toList());
            claims.put("roles", rolesWithPrefix);
            FirebaseAuth.getInstance().setCustomUserClaims(userRecord.getUid(), claims);

            return convertToUserResponse(newUser);

        } catch (FirebaseAuthException | InterruptedException | ExecutionException e) {
            throw new CustomExceptions.ProcessingException("Error creating user: " + e.getMessage());
        }
    }
    private void updateUserData(User user, RegisterRequest request) {
        user.setNombre(request.getNombre());
        user.setApellido(request.getApellido());
        user.setTelefono(request.getTelefono());
        user.setDireccion(request.getDireccion());
        user.setRoles(request.getRoles());
        // Actualiza el usuario en Firestore
        try {
            getFirestore().collection("users").document(user.getUid()).set(user).get();
        } catch (InterruptedException e) {
            System.err.println(e);
            throw new RuntimeException(e);
        } catch (ExecutionException e) {
            System.err.println(e);
            throw new RuntimeException(e);
        }
    }
    public Optional<User> findByEmail(String email) {
        try {
            QuerySnapshot querySnapshot = getFirestore().collection("users")
                    .whereEqualTo("email", email)
                    .get()
                    .get();
            if (!querySnapshot.isEmpty()) {
                DocumentSnapshot document = querySnapshot.getDocuments().get(0);
                return Optional.of(document.toObject(User.class));
            }
            return Optional.empty();
        } catch (InterruptedException | ExecutionException e) {
            throw new CustomExceptions.ProcessingException("Error finding user by email: " + e.getMessage());
        }
    }

    public UserResponse getUserById(String id) {
        try {
            User user = getFirestore().collection("users").document(id).get().get().toObject(User.class);
            if (user == null) {
                throw new CustomExceptions.UserNotFoundException("User not found with id: " + id);
            }
            return convertToUserResponse(user);
        } catch (InterruptedException | ExecutionException e) {
            throw new CustomExceptions.ProcessingException("Error fetching user: " + e.getMessage());
        }
    }

    // En UserService.java
    // En UserService.java
    public PaginatedResponse<UserResponse> getAllUsers(PaginationRequest request,
                                                       Boolean isActive, String role) {
        try {
            CollectionReference usersRef = getFirestore().collection("users");
            Query query = usersRef;

            // Aplicar filtros específicos
            if (isActive != null) {
                query = query.whereEqualTo("active", isActive);
            }
            if (role != null) {
                query = query.whereArrayContains("roles", Role.valueOf(role.toUpperCase()));
            }

            // Aplicar filtros generales si existen
            if (request.getFilterBy() != null && request.getFilterValue() != null) {
                query = query.whereEqualTo(request.getFilterBy(), request.getFilterValue());
            }

            // Aplicar ordenamiento
            Query.Direction direction = request.getSortDirection().equalsIgnoreCase("DESC")
                    ? Query.Direction.DESCENDING
                    : Query.Direction.ASCENDING;
            query = query.orderBy(request.getSortBy(), direction);

            // Aplicar paginación
            query = query.offset(request.getPage() * request.getSize())
                    .limit(request.getSize());

            // Ejecutar query
            QuerySnapshot querySnapshot = query.get().get();

            // Convertir resultados
            List<UserResponse> users = querySnapshot.getDocuments().stream()
                    .map(doc -> {
                        User user = doc.toObject(User.class);
                        user.setUid(doc.getId());
                        return convertToUserResponse(user);
                    })
                    .collect(Collectors.toList());

            // Contar total de elementos
            long totalElements = usersRef.get().get().size();

            return PaginatedResponse.of(users, request, totalElements);

        } catch (Exception e) {
            throw new CustomExceptions.ProcessingException("Error fetching users: " + e.getMessage());
        }
    }
    public PaginatedResponse<UserResponse> getVeterinarians(PaginationRequest request) {
        try {
            CollectionReference usersRef = firestore.collection("users");
            Query query = usersRef;

            // Filtrar solo veterinarios
            query = query.whereArrayContains("roles", Role.VETERINARIO)
                    .whereEqualTo("active", true); // Solo veterinarios activos

            // Aplicar ordenamiento
            Query.Direction direction = request.getSortDirection().equalsIgnoreCase("DESC")
                    ? Query.Direction.DESCENDING
                    : Query.Direction.ASCENDING;
            query = query.orderBy(request.getSortBy(), direction);

            // Aplicar paginación
            query = query.offset(request.getPage() * request.getSize())
                    .limit(request.getSize());

            // Ejecutar query
            QuerySnapshot querySnapshot = query.get().get();

            // Convertir resultados
            List<UserResponse> veterinarians = querySnapshot.getDocuments().stream()
                    .map(doc -> {
                        User user = doc.toObject(User.class);
                        user.setUid(doc.getId()); // Asegurar que el ID esté establecido
                        return convertToUserResponse(user);
                    })
                    .collect(Collectors.toList());

            // Obtener el total de elementos
            Query countQuery = usersRef.whereArrayContains("roles", Role.VETERINARIO)
                    .whereEqualTo("active", true);
            long totalElements = countQuery.get().get().size();

            // Crear y retornar la respuesta paginada
            return PaginatedResponse.of(veterinarians, request, totalElements);

        } catch (Exception e) {
            throw new CustomExceptions.ProcessingException("Error fetching veterinarians: " + e.getMessage());
        }
    }

    public UserResponse updateUser(String id, UpdateUserRequest request) {
        try {
            User user = getFirestore().collection("users").document(id).get().get().toObject(User.class);
            if (user == null) {
                throw new CustomExceptions.UserNotFoundException("User not found with id: " + id);
            }
            user.setEmail(request.getEmail());
            user.setNombre(request.getNombre());
            user.setApellido(request.getApellido());
            user.setTelefono(request.getTelefono());
            user.setDireccion(request.getDireccion());
            user.setRoles(request.getRoles());

            getFirestore().collection("users").document(id).set(user).get();
            return convertToUserResponse(user);
        } catch (InterruptedException | ExecutionException e) {
            throw new CustomExceptions.ProcessingException("Error updating user: " + e.getMessage());
        }
    }

    public void deleteUser(String id) {
        try {
            FirebaseAuth.getInstance().deleteUser(id);
            getFirestore().collection("users").document(id).delete().get();
        } catch (FirebaseAuthException | InterruptedException | ExecutionException e) {
            throw new CustomExceptions.ProcessingException("Error deleting user: " + e.getMessage());
        }
    }

    public void changePassword(String userId, ChangePasswordRequest request) {
        try {
            // Verificar la contraseña actual
            if (!verifyCurrentPassword(userId, request.getCurrentPassword())) {
                throw new CustomExceptions.UnauthorizedException("La contraseña actual es incorrecta");
            }

            // Validar la nueva contraseña
            if (!isValidPassword(request.getNewPassword())) {
                throw new CustomExceptions.InvalidPasswordException("La nueva contraseña no cumple con los requisitos de seguridad");
            }

            // Actualizar la contraseña
            UserRecord.UpdateRequest updateRequest = new UserRecord.UpdateRequest(userId)
                    .setPassword(request.getNewPassword());
            firebaseAuth.updateUser(updateRequest);

        } catch (FirebaseAuthException e) {
            // Log the exception details

            throw new CustomExceptions.ProcessingException("Error changing password: " + e.getMessage());
        } catch (Exception e) {
            // Log any unexpected exceptions
            logger.error("Unexpected error in changePassword: ", e);
            throw new CustomExceptions.ProcessingException("Unexpected error occurred: " + e.getMessage());
        }
    }
    private boolean isValidPassword(String password) {
        // Implementar la validación de contraseña
        String regex = "^(?=.*[0-9])(?=.*[a-z])(?=.*[A-Z])(?=.*[@#$%^&+=])(?=\\S+$).{8,}$";
        return password.matches(regex);
    }
    private boolean verifyCurrentPassword(String userId, String currentPassword) {
        try {
            // Obtener el usuario de Firebase
            UserRecord userRecord = firebaseAuth.getUser(userId);

            // Intentar autenticar al usuario con el email y la contraseña actual
            // Nota: Este método no está disponible directamente en FirebaseAuth,
            // por lo que necesitamos usar una alternativa

            // Una opción es usar la API de Firebase Auth REST
            // Esto requiere una implementación adicional que no está directamente
            // disponible en el SDK de Admin de Firebase

            // Por ahora, como placeholder, asumiremos que la verificación es exitosa
            // En una implementación real, necesitarías integrar con la API de Firebase Auth
            return true;
        } catch (FirebaseAuthException e) {
            return false;
        }
    }

    public UserResponse toggleUserStatus(String id, ToggleUserStatusRequest request) {
        try {
            User user = getFirestore().collection("users").document(id).get().get().toObject(User.class);
            if (user == null) {
                throw new CustomExceptions.UserNotFoundException("User not found with id: " + id);
            }
            user.setActive(request.isActive());
            getFirestore().collection("users").document(id).set(user).get();
            return convertToUserResponse(user);
        } catch (InterruptedException | ExecutionException e) {
            throw new CustomExceptions.ProcessingException("Error toggling user status: " + e.getMessage());
        }
    }

    public void addNote(String userId, AddNoteRequest request) {
        try {
            Map<String, Object> note = new HashMap<>();
            note.put("content", request.getContent());
            note.put("timestamp", new Date());

            getFirestore().collection("users").document(userId).collection("notes").add(note).get();
        } catch (InterruptedException | ExecutionException e) {
            throw new CustomExceptions.ProcessingException("Error adding note: " + e.getMessage());
        }
    }

    private UserResponse convertToUserResponse(User user) {
        UserResponse response = new UserResponse();
        response.setUid(user.getUid());
        response.setEmail(user.getEmail());
        response.setNombre(user.getNombre());
        response.setApellido(user.getApellido());
        response.setTelefono(user.getTelefono());
        response.setDireccion(user.getDireccion());
        response.setRoles(user.getRoles() != null ? user.getRoles() : new ArrayList<>());
        response.setEnabled(user.isEnabled());
        response.setActive(user.isActive());
        return response;
    }
    /*
    public UserResponse updateUserProfile(UpdateProfileRequest request) {
        String uid = getCurrentUserUid();
        try {
            User user = getFirestore().collection("users").document(uid).get().get().toObject(User.class);
            if (user == null) {
                throw new CustomExceptions.UserNotFoundException("User not found with id: " + uid);
            }
            user.setNombre(request.getNombre());
            user.setApellido(request.getApellido());
            user.setTelefono(request.getTelefono());
            user.setDireccion(request.getDireccion());

            getFirestore().collection("users").document(uid).set(user).get();
            return convertToUserResponse(user);
        } catch (InterruptedException | ExecutionException e) {
            throw new CustomExceptions.ProcessingException("Error updating user profile: " + e.getMessage());
        }
    }

     */
    public boolean existsByEmail(String email) {
        try {
            return getFirestore().collection("users")
                    .whereEqualTo("email", email)
                    .get()
                    .get()
                    .size() > 0;
        } catch (InterruptedException | ExecutionException e) {
            throw new CustomExceptions.ProcessingException("Error checking user existence: " + e.getMessage());
        }
    }

//    private String getCurrentUserUid() {
//        // Obtener el contexto de seguridad actual
//        SecurityContext securityContext = SecurityContextHolder.getContext();
//        Authentication authentication = securityContext.getAuthentication();
//
//        // Verificar si hay un usuario autenticado
//        if (authentication != null && authentication.isAuthenticated()) {
//            // El nombre principal en este caso será el UID de Firebase
//            return authentication.getName();
//        }
//
//        // Si no hay usuario autenticado, lanzar una excepción
//        throw new CustomExceptions.AuthenticationException("No authenticated user found");
//    }
    public UserResponse updateUserProfile(UpdateProfileRequest request) {
        String uid = getCurrentUserUid();
        try {
            User user = getFirestore().collection("users").document(uid).get().get().toObject(User.class);
            if (user == null) {
                throw new CustomExceptions.UserNotFoundException("User not found with id: " + uid);
            }
            User updatedUser = User.builder()
                    .uid(user.getUid())
                    .email(user.getEmail())
                    .nombre(request.getNombre())
                    .apellido(request.getApellido())
                    .telefono(request.getTelefono())
                    .direccion(request.getDireccion())
                    .roles(user.getRoles())  // Mantener roles existentes
                    .isEnabled(user.isEnabled())
                    .active(user.isActive())
                    .build();

            getFirestore().collection("users").document(uid).set(user).get();
            return convertToUserResponse(user);
        } catch (InterruptedException | ExecutionException e) {
            throw new CustomExceptions.ProcessingException("Error updating user profile: " + e.getMessage());
        }
    }
    public List<PetDTOs.PetResponse> getUserPets(String userId) {
        return petService.getPetsByUserId(userId);
    }
    public UserResponse updateUserRoles(String id, List<Role> roles) {
        try {
            User user = getFirestore().collection("users").document(id).get().get().toObject(User.class);
            if (user == null) {
                throw new CustomExceptions.UserNotFoundException("User not found with id: " + id);
            }
            user.setRoles(roles);
            getFirestore().collection("users").document(id).set(user).get();
            return convertToUserResponse(user);
        } catch (InterruptedException | ExecutionException e) {
            throw new CustomExceptions.ProcessingException("Error updating user roles: " + e.getMessage());
        }
    }
    public UserResponse getCurrentUserProfile() {
        String uid = getCurrentUserUid();
        return getUserById(uid);
    }
    public UserResponse updateCurrentUserProfile(UpdateProfileRequest request) {
        String uid = getCurrentUserUid();
        try {
            User user = getFirestore().collection("users").document(uid).get().get().toObject(User.class);
            if (user == null) {
                throw new CustomExceptions.UserNotFoundException("User not found with id: " + uid);
            }
            User updatedUser = User.builder()
                    .uid(user.getUid())
                    .email(user.getEmail())
                    .nombre(request.getNombre())
                    .apellido(request.getApellido())
                    .telefono(request.getTelefono())
                    .direccion(request.getDireccion())
                    .roles(user.getRoles())  // Mantener roles existentes
                    .isEnabled(user.isEnabled())
                    .active(user.isActive())
                    .build();

            getFirestore().collection("users").document(uid).set(updatedUser).get();
            return convertToUserResponse(user);
        } catch (InterruptedException | ExecutionException e) {
            throw new CustomExceptions.ProcessingException("Error updating user profile: " + e.getMessage());
        }
    }

    public List<PetDTOs.PetResponse> getCurrentUserPets() {
        String uid = getCurrentUserUid();
        return petService.getPetsByUserId(uid);
    }
    private String getCurrentUserUid() {
        return SecurityContextHolder.getContext().getAuthentication().getName();
    }
    private UpdateUserRequest convertToUpdateUserRequest(User user) {
        UpdateUserRequest request = new UpdateUserRequest();
        request.setNombre(user.getNombre());
        request.setApellido(user.getApellido());
        request.setTelefono(user.getTelefono());
        request.setDireccion(user.getDireccion());
        return request;
    }
    private User getUserEntityById(String id) {
        try {
            Firestore firestore = FirestoreClient.getFirestore();
            DocumentSnapshot document = firestore.collection("users").document(id).get().get();

            if (!document.exists()) {
                throw new CustomExceptions.UserNotFoundException("User not found with id: " + id);
            }

            User user = document.toObject(User.class);
            if (user == null) {
                throw new CustomExceptions.ProcessingException("Error converting Firestore document to User object");
            }

            // Asegúrate de que el ID del usuario esté establecido
            user.setUid(id);

            return user;
        } catch (InterruptedException | ExecutionException e) {
            throw new CustomExceptions.ProcessingException("Error fetching user from Firestore: " + e.getMessage());
        }
    }

}

Estructura: service
Archivo: VeterinaryService.java
--------------------------------------------------
package com.example.demo.service;

import com.example.demo.dto.PaginatedResponse;
import com.example.demo.dto.PaginationRequest;
import com.example.demo.dto.PetDTOs;
import com.example.demo.dto.UserDTOs;
import com.example.demo.exception.CustomExceptions;
import com.example.demo.model.MedicalRecord;
import com.example.demo.model.Pet;
import com.example.demo.model.Role;
import com.example.demo.model.User;
import com.example.demo.util.FirestorePaginationUtils;
import com.google.cloud.firestore.*;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Service;

import java.time.LocalDate;
import java.time.ZoneId;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.UUID;
import java.util.concurrent.ExecutionException;
import java.util.stream.Collectors;

@Service
public class VeterinaryService {
    private static final Logger logger = LoggerFactory.getLogger(VeterinaryService.class);

    // Constantes para mensajes de error comunes
    private static final String ERROR_FETCHING_PETS = "Error al obtener las mascotas: {}";
    private static final String ERROR_FETCHING_HISTORY = "Error al obtener el historial médico: {}";
    private static final String ERROR_VETERINARIAN_NOT_FOUND = "No se pudo encontrar el veterinario con ID: {}";
    private static final String ERROR_CONVERTING_RECORD = "Error al convertir el registro médico: {}";


    @Autowired
    private Firestore firestore;

    @Autowired
    private UserService userService;

    @Autowired
    private PetService petService;

    /**
     * Busca clientes y sus mascotas según los criterios especificados
     */
    /*
    public List<UserDTOs.ClientWithPetsDTO> searchClients(UserDTOs.ClientSearchCriteria criteria) {
        try {
            // Crear query base
            Query query = firestore.collection("users");

            // Aplicar filtros según los criterios
            if (criteria.getClientName() != null) {
                query = query.whereGreaterThanOrEqualTo("nombre", criteria.getClientName())
                        .whereLessThanOrEqualTo("nombre", criteria.getClientName() + '\uf8ff');
            }

            // Ejecutar query
            QuerySnapshot querySnapshot = query.get().get();
            List<UserDTOs.ClientWithPetsDTO> results = new ArrayList<>();

            for (DocumentSnapshot document : querySnapshot.getDocuments()) {
                User user = document.toObject(User.class);
                if (user != null) {
                    // Obtener mascotas del cliente
                    List<PetDTOs.PetWithHistoryDTO> pets = getPetsWithHistory(user.getUid());

                    // Filtrar por nombre de mascota si es necesario
                    if (criteria.getPetName() != null) {
                        pets = pets.stream()
                                .filter(pet -> pet.getName().toLowerCase()
                                        .contains(criteria.getPetName().toLowerCase()))
                                .collect(Collectors.toList());
                    }

                    // Filtrar por fecha de consulta si es necesario
                    if (criteria.getConsultationDate() != null) {
                        pets = filterPetsByConsultationDate(pets, criteria.getConsultationDate());
                    }

                    // Si hay mascotas que cumplen con los filtros, agregar el cliente al resultado
                    if (!pets.isEmpty()) {
                        UserDTOs.ClientWithPetsDTO clientDTO = convertToClientWithPetsDTO(user, pets);
                        results.add(clientDTO);
                    }
                }
            }

            return results;
        } catch (Exception e) {
            throw new CustomExceptions.ProcessingException("Error searching clients: " + e.getMessage());
        }
    }

     */
    public PaginatedResponse<UserDTOs.ClientWithPetsDTO> searchClients(
            UserDTOs.ClientSearchCriteria criteria, PaginationRequest request) {
        try {
            CollectionReference usersRef = firestore.collection("users");
            Query query = usersRef;

            // Aplicar filtros de búsqueda
            if (criteria.getClientName() != null) {
                query = query.whereGreaterThanOrEqualTo("nombre", criteria.getClientName())
                        .whereLessThanOrEqualTo("nombre", criteria.getClientName() + '\uf8ff');
            }

            // Aplicar filtros adicionales
            if (request.getFilterBy() != null && request.getFilterValue() != null) {
                query = query.whereEqualTo(request.getFilterBy(), request.getFilterValue());
            }

            // Ordenamiento
            Query.Direction direction = request.getSortDirection().equalsIgnoreCase("DESC")
                    ? Query.Direction.DESCENDING
                    : Query.Direction.ASCENDING;
            query = query.orderBy(request.getSortBy(), direction);

            // Paginación
            query = query.offset(request.getPage() * request.getSize())
                    .limit(request.getSize());

            QuerySnapshot querySnapshot = query.get().get();

            List<UserDTOs.ClientWithPetsDTO> clients = new ArrayList<>();

            for (DocumentSnapshot doc : querySnapshot.getDocuments()) {
                User user = doc.toObject(User.class);
                if (user != null) {
                    List<PetDTOs.PetWithHistoryDTO> pets = getPetsWithHistory(user.getUid());

                    // Filtrar por nombre de mascota si es necesario
                    if (criteria.getPetName() != null) {
                        pets = pets.stream()
                                .filter(pet -> pet.getName().toLowerCase()
                                        .contains(criteria.getPetName().toLowerCase()))
                                .collect(Collectors.toList());
                    }

                    // Filtrar por fecha de consulta si es necesario
                    if (criteria.getConsultationDate() != null) {
                        pets = filterPetsByConsultationDate(pets, criteria.getConsultationDate());
                    }

                    if (!pets.isEmpty()) {
                        clients.add(convertToClientWithPetsDTO(user, pets));
                    }
                }
            }

            long totalElements = firestore.collection("users")
                    .get().get().size();

            return PaginatedResponse.of(clients, request, totalElements);

        } catch (Exception e) {
            throw new CustomExceptions.ProcessingException(
                    "Error searching clients: " + e.getMessage());
        }
    }

    /**
     * Agrega un registro médico a una mascota
     */
    public PetDTOs.MedicalRecordResponse addMedicalRecord(String petId, PetDTOs.AddMedicalRecordRequest request) {
        String currentVetId = SecurityContextHolder.getContext().getAuthentication().getName();

        try {
            // Verificar que la mascota existe
            PetDTOs.PetResponse pet = petService.getPetById(petId);
            if (pet == null) {
                throw new CustomExceptions.NotFoundException("Mascota no encontrada");
            }

            // Crear el registro médico
            MedicalRecord record = new MedicalRecord();
            record.setId(UUID.randomUUID().toString());
            record.setDate(new Date());
            record.setDiagnosis(request.getDiagnosis());
            record.setTreatment(request.getTreatment());
            record.setNotes(request.getNotes());
            record.setVeterinarianId(currentVetId);

            // Guardar el registro
            firestore.collection("pets").document(petId)
                    .collection("medicalRecords")
                    .document(record.getId())
                    .set(record)
                    .get();

            // Notificar al dueño
            notifyOwner(pet.getOwnerId(), "Nuevo registro médico",
                    "Se ha actualizado el historial médico de " + pet.getName());

            return convertToMedicalRecordResponse(record);
        } catch (Exception e) {
            throw new CustomExceptions.ProcessingException("Error adding medical record: " + e.getMessage());
        }
    }

    /**
     * Obtiene el historial médico de una mascota
     */
    public PaginatedResponse<PetDTOs.MedicalRecordResponse> getMedicalHistory(
            String petId, PaginationRequest request) {
        try {
            CollectionReference recordsRef = firestore.collection("pets")
                    .document(petId)
                    .collection("medicalRecords");

            Query query = recordsRef;

            // Aplicar filtros
            if (request.getFilterBy() != null && request.getFilterValue() != null) {
                query = query.whereEqualTo(request.getFilterBy(), request.getFilterValue());
            }

            // Ordenamiento por defecto por fecha si no se especifica otro campo
            String sortBy = request.getSortBy().equals("id") ? "date" : request.getSortBy();
            Query.Direction direction = request.getSortDirection().equalsIgnoreCase("DESC")
                    ? Query.Direction.DESCENDING
                    : Query.Direction.ASCENDING;
            query = query.orderBy(sortBy, direction);

            // Paginación
            query = query.offset(request.getPage() * request.getSize())
                    .limit(request.getSize());

            QuerySnapshot querySnapshot = query.get().get();

            List<PetDTOs.MedicalRecordResponse> history = new ArrayList<>();
            for (DocumentSnapshot doc : querySnapshot.getDocuments()) {
                MedicalRecord record = doc.toObject(MedicalRecord.class);
                if (record != null) {
                    history.add(convertToMedicalRecordResponse(record));
                }
            }

            long totalElements = FirestorePaginationUtils.getTotalElements(recordsRef);

            return PaginatedResponse.of(history, request, totalElements);

        } catch (Exception e) {
            throw new CustomExceptions.ProcessingException(
                    "Error fetching medical history: " + e.getMessage());
        }
    }

    // Métodos privados auxiliares...




    private void notifyOwner(String ownerId, String title, String message) {
        // Implementar notificación (por ejemplo, usando Firebase Cloud Messaging)
    }
    private UserDTOs.ClientWithPetsDTO convertToClientWithPetsDTO(User user, List<PetDTOs.PetWithHistoryDTO> pets) {
        UserDTOs.ClientWithPetsDTO dto = new UserDTOs.ClientWithPetsDTO();
        dto.setUid(user.getUid());
        dto.setNombre(user.getNombre());
        dto.setApellido(user.getApellido());
        dto.setEmail(user.getEmail());
        dto.setTelefono(user.getTelefono());
        dto.setDireccion(user.getDireccion());
        dto.setMascotas(pets);
        return dto;
    }

    /**
     * Convierte una Pet y su historial médico a PetWithHistoryDTO
     */
    private PetDTOs.PetWithHistoryDTO convertToPetWithHistoryDTO(Pet pet, List<PetDTOs.MedicalRecordResponse> history) {
        PetDTOs.PetWithHistoryDTO dto = new PetDTOs.PetWithHistoryDTO();
        dto.setId(pet.getId());
        dto.setName(pet.getName());
        dto.setSpecies(pet.getSpecies());
        dto.setBreed(pet.getBreed());
        dto.setAge(pet.getAge());
        dto.setMedicalHistory(history);
        return dto;
    }

    /**
     * Convierte un MedicalRecord a MedicalRecordResponse
     * Incluye información del veterinario
     */
    private PetDTOs.MedicalRecordResponse convertToMedicalRecordResponse(MedicalRecord record) {
        PetDTOs.MedicalRecordResponse response = new PetDTOs.MedicalRecordResponse();
        response.setId(record.getId());
        response.setDate(record.getDate());
        response.setDiagnosis(record.getDiagnosis());
        response.setTreatment(record.getTreatment());
        response.setNotes(record.getNotes());
        response.setVeterinarianId(record.getVeterinarianId());

        // Obtener el nombre del veterinario
        try {
            UserDTOs.UserResponse veterinarian = userService.getUserById(record.getVeterinarianId());
            response.setVeterinarianName(veterinarian.getNombre() + " " + veterinarian.getApellido());
        } catch (Exception e) {
            response.setVeterinarianName("Veterinario no encontrado");
            //logger.warn("No se pudo obtener el nombre del veterinario para el registro médico: " + record.getId());
        }

        return response;
    }

    /**
     * Obtiene las mascotas con su historial médico para un cliente específico
     */
    private List<PetDTOs.PetWithHistoryDTO> getPetsWithHistory(String userId) throws ExecutionException, InterruptedException {
        // Obtener todas las mascotas del usuario
        QuerySnapshot petsSnapshot = firestore.collection("pets")
                .whereEqualTo("ownerId", userId)
                .get()
                .get();

        List<PetDTOs.PetWithHistoryDTO> petsWithHistory = new ArrayList<>();
        for (DocumentSnapshot petDoc : petsSnapshot.getDocuments()) {
            Pet pet = petDoc.toObject(Pet.class);
            if (pet != null) {
                // Obtener historial médico básico (últimas 5 entradas)
                QuerySnapshot historySnapshot = firestore.collection("pets")
                        .document(pet.getId())
                        .collection("medicalRecords")
                        .orderBy("date", Query.Direction.DESCENDING)
                        .limit(5)
                        .get()
                        .get();

                List<PetDTOs.MedicalRecordResponse> history = historySnapshot.getDocuments().stream()
                        .map(doc -> {
                            MedicalRecord record = doc.toObject(MedicalRecord.class);
                            return convertToMedicalRecordResponse(record);
                        })
                        .collect(Collectors.toList());

                petsWithHistory.add(convertToPetWithHistoryDTO(pet, history));
            }
        }

        return petsWithHistory;
    }
    /**
     * Convierte un AddMedicalRecordRequest a MedicalRecord
     */
    private MedicalRecord convertToMedicalRecord(PetDTOs.AddMedicalRecordRequest request, String veterinarianId) {
        MedicalRecord record = new MedicalRecord();
        record.setId(UUID.randomUUID().toString());
        record.setDate(new Date());
        record.setDiagnosis(request.getDiagnosis());
        record.setTreatment(request.getTreatment());
        record.setNotes(request.getNotes());
        record.setVeterinarianId(veterinarianId);
        record.setAttachments(new ArrayList<>()); // Lista vacía de adjuntos inicialmente
        return record;
    }

    /**
     * Convierte datos del Firestore a MedicalRecord
     */
    private MedicalRecord convertFirestoreToMedicalRecord(DocumentSnapshot doc) {
        MedicalRecord record = new MedicalRecord();
        record.setId(doc.getId());
        record.setDate(doc.getDate("date"));
        record.setDiagnosis(doc.getString("diagnosis"));
        record.setTreatment(doc.getString("treatment"));
        record.setNotes(doc.getString("notes"));
        record.setVeterinarianId(doc.getString("veterinarianId"));

        // Convertir la lista de adjuntos si existe
        @SuppressWarnings("unchecked")
        List<String> attachments = (List<String>) doc.get("attachments");
        record.setAttachments(attachments != null ? attachments : new ArrayList<>());

        return record;
    }

    //----
    public UserDTOs.ClientWithPetsDTO getClientWithPets(String clientId) {
        try {
            // Verificar que el usuario actual es veterinario
            String currentUserId = SecurityContextHolder.getContext().getAuthentication().getName();
            UserDTOs.UserResponse currentUser = userService.getUserById(currentUserId);
            /*
            if (!currentUser.getRoles().contains(Role.VETERINARIO) ) {
                throw new CustomExceptions.UnauthorizedException("Solo los veterinarios pueden acceder a esta información");
            }

             */
            // Obtener información del cliente
            DocumentSnapshot clientDoc = firestore.collection("users")
                    .document(clientId)
                    .get()
                    .get();

            if (!clientDoc.exists()) {
                logger.warn("Cliente no encontrado con ID: {}", clientId);
                throw new CustomExceptions.NotFoundException("Cliente no encontrado");
            }

            User client = clientDoc.toObject(User.class);
            if (client == null) {
                logger.error("Error al convertir documento a User para el cliente ID: {}", clientId);
                throw new CustomExceptions.ProcessingException("Error al procesar información del cliente");
            }

            // Obtener todas las mascotas del cliente con su historial médico
            List<PetDTOs.PetWithHistoryDTO> petsWithHistory = getPetsWithHistory(clientId);

            // Organizar mascotas por última visita
            petsWithHistory.sort((pet1, pet2) -> {
                Date lastVisit1 = getLastVisitDate(pet1.getMedicalHistory());
                Date lastVisit2 = getLastVisitDate(pet2.getMedicalHistory());
                return lastVisit2.compareTo(lastVisit1); // Orden descendente
            });

            // Convertir y retornar el DTO completo
            UserDTOs.ClientWithPetsDTO clientDTO = convertToClientWithPetsDTO(client, petsWithHistory);

            logger.info("Información recuperada exitosamente para cliente ID: {}", clientId);
            return clientDTO;

        } catch (InterruptedException | ExecutionException e) {
            logger.error("Error al obtener información del cliente y mascotas: {}", e.getMessage());
            throw new CustomExceptions.ProcessingException("Error al obtener información del cliente: " + e.getMessage());
        }
    }
    // Método auxiliar para filtrar mascotas por fecha de consulta
    private List<PetDTOs.PetWithHistoryDTO> filterPetsByConsultationDate(
            List<PetDTOs.PetWithHistoryDTO> pets, LocalDate consultationDate) {
        return pets.stream()
                .filter(pet -> pet.getMedicalHistory().stream()
                        .anyMatch(record -> isSameDate(record.getDate(), consultationDate)))
                .collect(Collectors.toList());
    }

    // Método auxiliar para verificar si dos fechas son iguales
    private boolean isSameDate(Date date1, LocalDate date2) {
        if (date1 == null || date2 == null) return false;
        LocalDate localDate1 = date1.toInstant()
                .atZone(ZoneId.systemDefault())
                .toLocalDate();
        return localDate1.equals(date2);
    }

    /**
     * Obtiene la fecha de la última visita del historial médico
     * @param history Lista de registros médicos
     * @return Date con la fecha de la última visita o fecha actual si no hay historial
     */
    private Date getLastVisitDate(List<PetDTOs.MedicalRecordResponse> history) {
        if (history == null || history.isEmpty()) {
            return new Date(0L); // Si no hay historial, retorna la fecha más antigua posible
        }
        return history.stream()
                .map(PetDTOs.MedicalRecordResponse::getDate)
                .max(Date::compareTo)
                .orElse(new Date(0L));
    }

    /**
     * Verifica si una mascota tiene consulta en una fecha específica
     * @param history Historial médico de la mascota
     * @param targetDate Fecha a verificar
     * @return true si hay consulta en esa fecha
     */
    private boolean hasConsultationOnDate(List<PetDTOs.MedicalRecordResponse> history, LocalDate targetDate) {
        if (history == null || history.isEmpty()) {
            return false;
        }

        return history.stream()
                .map(record -> record.getDate().toInstant()
                        .atZone(ZoneId.systemDefault())
                        .toLocalDate())
                .anyMatch(date -> date.equals(targetDate));
    }

    /**
     * Agrega información adicional relevante al DTO del cliente
     * @param clientDTO DTO base del cliente
     * @param petsWithHistory Lista de mascotas con historial
     * @return ClientWithPetsDTO enriquecido con información adicional
     */
    private void enrichClientDTO(UserDTOs.ClientWithPetsDTO clientDTO, List<PetDTOs.PetWithHistoryDTO> petsWithHistory) {
        // Calcular estadísticas útiles para el veterinario
        int totalPets = petsWithHistory.size();
        long activePets = petsWithHistory.stream()
                .filter(pet -> !pet.getMedicalHistory().isEmpty())
                .count();

        // Aquí podrías agregar más información relevante al DTO si es necesario
        // Por ejemplo, última visita general, próximas vacunas pendientes, etc.
    }

    /**
     * Valida los permisos del veterinario para acceder a la información
     * @param veterinarianId ID del veterinario
     * @throws CustomExceptions.UnauthorizedException si no tiene permisos
     */
    private void validateVeterinarianAccess(String veterinarianId) {
        try {
            UserDTOs.UserResponse veterinarian = userService.getUserById(veterinarianId);
            if (!veterinarian.getRoles().contains(Role.VETERINARIO)) {
                logger.warn("Intento de acceso no autorizado por usuario ID: {}", veterinarianId);
                throw new CustomExceptions.UnauthorizedException("No tiene permisos para acceder a esta información");
            }
        } catch (CustomExceptions.UserNotFoundException e) {
            logger.error("Veterinario no encontrado ID: {}", veterinarianId);
            throw new CustomExceptions.UnauthorizedException("Usuario no autorizado");
        }
    }
}

Estructura: service
Archivo: VetServiceListService.java
--------------------------------------------------
package com.example.demo.service;

import com.example.demo.dto.*;
import com.example.demo.exception.CustomExceptions;
import com.example.demo.model.ServiceCategory;
import com.example.demo.model.ServiceVeterinary;
import com.google.cloud.firestore.*;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.*;
import java.util.stream.Collectors;

@Service
public class VetServiceListService {

    @Autowired
    private Firestore firestore;

    /**
     * Obtiene la lista de servicios aplicando filtros y paginación
     */
    /*
    public PaginatedResponse<ServiceDTO> getServiceList(ServiceSearchRequest searchRequest, PaginationRequest paginationRequest) {
        try {
            CollectionReference servicesRef = firestore.collection("veterinary_services");
            Query query = servicesRef.whereEqualTo("active", true);

            // Solo aplicar filtro si filterBy y filterValue están presentes
            boolean hasNameFilter = paginationRequest.getFilterBy() != null &&
                    paginationRequest.getFilterValue() != null &&
                    !paginationRequest.getFilterValue().isEmpty() &&
                    "name".equalsIgnoreCase(paginationRequest.getFilterBy());

            // Obtener todos los servicios activos
            QuerySnapshot allServices = query.get().get();
            List<ServiceDTO> filteredServices;

            if (hasNameFilter) {
                // Filtrado por nombre (case-insensitive)
                String searchTerm = paginationRequest.getFilterValue().toLowerCase();
                filteredServices = allServices.getDocuments().stream()
                        .map(doc -> {
                            ServiceVeterinary service = doc.toObject(ServiceVeterinary.class);
                            if (service != null) {
                                service.setId(doc.getId());
                                return service;
                            }
                            return null;
                        })
                        .filter(Objects::nonNull)
                        .filter(service -> service.getName().toLowerCase().contains(searchTerm))
                        .map(this::convertToServiceDTO)
                        .collect(Collectors.toList());
            } else {
                // Sin filtro - convertir todos los servicios
                filteredServices = allServices.getDocuments().stream()
                        .map(doc -> {
                            ServiceVeterinary service = doc.toObject(ServiceVeterinary.class);
                            if (service != null) {
                                service.setId(doc.getId());
                                return convertToServiceDTO(service);
                            }
                            return null;
                        })
                        .filter(Objects::nonNull)
                        .collect(Collectors.toList());
            }

            // Ordenar resultados si se especifica
            if (paginationRequest.getSortBy() != null && paginationRequest.getSortDirection() != null) {
                boolean isAscending = paginationRequest.getSortDirection().equalsIgnoreCase("ASC");
                filteredServices.sort((s1, s2) -> {
                    int comparison = s1.getName().compareToIgnoreCase(s2.getName());
                    return isAscending ? comparison : -comparison;
                });
            }

            // Aplicar paginación
            int startIndex = paginationRequest.getPage() * paginationRequest.getSize();
            int endIndex = Math.min(startIndex + paginationRequest.getSize(), filteredServices.size());

            List<ServiceDTO> paginatedServices = filteredServices.subList(
                    startIndex,
                    Math.max(startIndex, endIndex)
            );

            return new PaginatedResponse<>(
                    paginatedServices,
                    paginationRequest.getPage(),
                    paginationRequest.getSize(),
                    filteredServices.size(),
                    (int) Math.ceil((double) filteredServices.size() / paginationRequest.getSize())
            );

        } catch (Exception e) {
            throw new CustomExceptions.ProcessingException("Error fetching services: " + e.getMessage());
        }
    }

     */
    public PaginatedResponse<ServiceDTO> getServiceList(ServiceSearchRequest searchRequest, PaginationRequest paginationRequest) {
        try {
            CollectionReference servicesRef = firestore.collection("veterinary_services");
            Query query = servicesRef.whereEqualTo("active", true);

            // Obtener todos los servicios activos
            QuerySnapshot allServices = query.get().get();
            List<ServiceDTO> filteredServices = new ArrayList<>();

            // Verificar si hay filtros
            boolean hasNameFilter = paginationRequest.getFilterBy() != null &&
                    paginationRequest.getFilterValue() != null &&
                    !paginationRequest.getFilterValue().isEmpty() &&
                    "name".equalsIgnoreCase(paginationRequest.getFilterBy());

            boolean hasCategoryFilter = searchRequest.getCategory() != null;

            // Aplicar filtros
            filteredServices = allServices.getDocuments().stream()
                    .map(doc -> {
                        ServiceVeterinary service = doc.toObject(ServiceVeterinary.class);
                        if (service != null) {
                            service.setId(doc.getId());
                            return service;
                        }
                        return null;
                    })
                    .filter(Objects::nonNull)
                    .filter(service -> {
                        boolean matchesName = true;
                        boolean matchesCategory = true;

                        // Filtrar por nombre si existe el filtro
                        if (hasNameFilter) {
                            String searchTerm = paginationRequest.getFilterValue().toLowerCase();
                            matchesName = service.getName().toLowerCase().contains(searchTerm);
                        }

                        // Filtrar por categoría si existe el filtro
                        if (hasCategoryFilter) {
                            matchesCategory = service.getCategory().equals(ServiceCategory.valueOf(searchRequest.getCategory()));
                        }

                        return matchesName && matchesCategory;
                    })
                    .map(this::convertToServiceDTO)
                    .collect(Collectors.toList());

            // Ordenar resultados si se especifica
            if (paginationRequest.getSortBy() != null && paginationRequest.getSortDirection() != null) {
                boolean isAscending = paginationRequest.getSortDirection().equalsIgnoreCase("ASC");
                filteredServices.sort((s1, s2) -> {
                    int comparison = s1.getName().compareToIgnoreCase(s2.getName());
                    return isAscending ? comparison : -comparison;
                });
            }

            // Aplicar paginación
            int startIndex = paginationRequest.getPage() * paginationRequest.getSize();
            int endIndex = Math.min(startIndex + paginationRequest.getSize(), filteredServices.size());

            List<ServiceDTO> paginatedServices = filteredServices.subList(
                    startIndex,
                    Math.max(startIndex, endIndex)
            );

            return new PaginatedResponse<>(
                    paginatedServices,
                    paginationRequest.getPage(),
                    paginationRequest.getSize(),
                    filteredServices.size(),
                    (int) Math.ceil((double) filteredServices.size() / paginationRequest.getSize())
            );

        } catch (Exception e) {
            throw new CustomExceptions.ProcessingException("Error fetching services: " + e.getMessage());
        }
    }
    /**
     * Obtiene los servicios agrupados por categoría
     */
    public ServiceListResponse getServicesByCategory(ServiceSearchRequest searchRequest) {
        try {
            // Obtener todos los servicios activos
            CollectionReference servicesRef = firestore.collection("veterinary_services");
            Query query = servicesRef.whereEqualTo("active", true);

            // Aplicar búsqueda si existe término
            if (searchRequest.getSearchTerm() != null && !searchRequest.getSearchTerm().isEmpty()) {
                String searchTermLower = searchRequest.getSearchTerm().toLowerCase();
                query = query.orderBy("name")
                        .startAt(searchTermLower)
                        .endAt(searchTermLower + "\uf8ff");
            }

            // Ejecutar query
            QuerySnapshot querySnapshot = query.get().get();

            // Agrupar por categoría
            Map<String, List<ServiceDTO>> servicesByCategory = querySnapshot.getDocuments().stream()
                    .map(doc -> convertToServiceDTO(doc.toObject(ServiceVeterinary.class)))
                    .collect(Collectors.groupingBy(
                            service -> service.getCategory().name(),
                            TreeMap::new,
                            Collectors.toList()
                    ));

            return ServiceListResponse.builder()
                    .servicesByCategory(servicesByCategory)
                    .totalServices(querySnapshot.size())
                    .build();

        } catch (Exception e) {
            throw new CustomExceptions.ProcessingException(
                    "Error fetching services by category: " + e.getMessage());
        }
    }

    /**
     * Convierte un ServiceVeterinary a ServiceDTO
     */
    private ServiceDTO convertToServiceDTO(ServiceVeterinary service) {
        return ServiceDTO.builder()
                .id(service.getId())
                .name(service.getName())
                .category(ServiceCategory.valueOf(service.getCategory().name()))
                .description(service.getDescription())
                .price(service.getPrice())
                .isActive(service.isActive())
                .build();
    }
}

Estructura: util
Archivo: FirestorePaginationUtils.java
--------------------------------------------------
package com.example.demo.util;

import com.google.cloud.firestore.*;
import com.example.demo.dto.PaginationRequest;
import java.util.List;
import java.util.concurrent.ExecutionException;
import java.util.stream.Collectors;

public class FirestorePaginationUtils {

    public static <T> QuerySnapshot getPaginatedData(
            CollectionReference collection,
            PaginationRequest request,
            Query.Direction sortDirection) throws ExecutionException, InterruptedException {

        // Construir query base
        Query query = collection;

        // Aplicar filtros si existen
        if (request.getFilterBy() != null && request.getFilterValue() != null) {
            query = query.whereEqualTo(request.getFilterBy(), request.getFilterValue());
        }

        // Aplicar ordenamiento
        query = query.orderBy(request.getSortBy(), sortDirection);

        // Aplicar paginación
        query = query.offset(request.getPage() * request.getSize())
                .limit(request.getSize());

        // Ejecutar query
        return query.get().get();
    }

    public static <T> List<T> convertToList(QuerySnapshot snapshot, Class<T> clazz) {
        return snapshot.getDocuments().stream()
                .map(doc -> doc.toObject(clazz))
                .collect(Collectors.toList());
    }

    public static long getTotalElements(CollectionReference collection)
            throws ExecutionException, InterruptedException {
        return collection.get().get().size();
    }
}

Estructura: util
Archivo: JwtUtils.java
--------------------------------------------------
package com.example.demo.util;

import io.jsonwebtoken.Claims;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.SignatureAlgorithm;
import io.jsonwebtoken.io.Decoders;
import io.jsonwebtoken.security.Keys;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.stereotype.Component;

import java.security.Key;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;
import java.util.function.Function;

@Component
public class JwtUtils {

    @Value("${jwt.secret}")
    private String SECRET_KEY;

    @Value("${jwt.expiration}")
    private long jwtExpiration;

    public String extractUsername(String token) {
        return extractClaim(token, Claims::getSubject);
    }

    public Date extractExpiration(String token) {
        return extractClaim(token, Claims::getExpiration);
    }

    public <T> T extractClaim(String token, Function<Claims, T> claimsResolver) {
        final Claims claims = extractAllClaims(token);
        return claimsResolver.apply(claims);
    }

    private Claims extractAllClaims(String token) {
        return Jwts
                .parserBuilder()
                .setSigningKey(getSignInKey())
                .build()
                .parseClaimsJws(token)
                .getBody();
    }

    private Boolean isTokenExpired(String token) {
        return extractExpiration(token).before(new Date());
    }

    public String generateToken(UserDetails userDetails) {
        return generateToken(new HashMap<>(), userDetails);
    }

    public String generateToken(
            Map<String, Object> extraClaims,
            UserDetails userDetails
    ) {
        return Jwts
                .builder()
                .setClaims(extraClaims)
                .setSubject(userDetails.getUsername())
                .setIssuedAt(new Date(System.currentTimeMillis()))
                .setExpiration(new Date(System.currentTimeMillis() + jwtExpiration))
                .signWith(getSignInKey(), SignatureAlgorithm.HS256)
                .compact();
    }

    public boolean isTokenValid(String token, UserDetails userDetails) {
        final String username = extractUsername(token);
        return (username.equals(userDetails.getUsername())) && !isTokenExpired(token);
    }

    private Key getSignInKey() {
        byte[] keyBytes = Decoders.BASE64.decode(SECRET_KEY);
        return Keys.hmacShaKeyFor(keyBytes);
    }
}

